{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CodeLab Adapter ¶ Turn the world into your playground! 是什么？ ¶ CodeLab Adapter 是一个由 Python 构建的软件(构建在消息之上( Everything Is a Message ))， 致力于连接万物，无论是软件还是硬件，无论是 AI、开源硬件、现实世界的物体、还是虚拟世界的动画角色，接入 CodeLab Adapter，皆可彼此互动。 \"连接能力\" 和 \"可扩展性\" 是它的主要特色。 在 CodeLab Adapter 驱动的环境里，通过使用 Scratch 或 Python 编程，你可以与万物沟通: 你可以在朋友生日那天，在 Ta 进门的一刻，将手中的魔杖一挥，在空中划一个字母 L 的轨迹，瞬间，点亮房间里五彩的灯光。 具体请看下面两个演示案例： 在上方视频中, 我们做了一场魔法烟花秀: 请看视频左侧，当挥动手中的魔杖实施第一个魔法，时间被冻结，视频右侧烟花静止在空中；实施第二个魔法，将烟花\"解冻\"; 实施第三个魔法-- 百花齐放。 Adapter 负责将烟花(虚拟)与魔杖(实物)连接在一起，用户在一个 创作平台 中即可同时操控两者，演绎自己编写的故事。 上方第二个视频演示了如何构建一个 理解 你当前处境的 AI，当你正在阅读时，AI 将为你把灯打开；当你合上书，AI 将为你把灯关掉，让你沉浸在黑暗中思考。 Adapter 负责接入外部 AI 与现实空间内的智能灯具，辅助你在 创作平台 中通过编程控制他们。 下面请看案例集锦视频，更多的在 这里 。 能做什么？ ¶ CodeLab Adapter 的典型用途包括: 扩展 Scratch 的能力（ 比 Scratch Link 更强大 ） 为它接入 AI、IoT、开源硬件、始就玩起来实物、虚拟角色...使Scratch成为酷上加酷的 创作平台 Python 入门 Adapter 由 Python 构建，对 Scratch 的增强也是通过使用 Python 写的插件实现。因此，Python 入门者通过简单修改现成插件代码为己所用、或编写新的插件代码，即可快速上手玩起来 构建可编程空间 构建 Dynamic Table 扩展在线编程平台(Blockly 等)的能力 特性有哪些？ ¶ 开放 高度可扩展 插件(Extension) 和 节点(Node) 万物皆消息(EIM, Everything Is a Message) RESTful API 支持多门编程语言(34+) 将 Scratch 和 Python 视为一等公民","text_tokens":[",","的","(","扩展","百花齐放","可以","一个","划","百花","用户","时","内","第二","你","上","第二个","黑暗","典型","比","into","我们","就","灯光","软件","简单","特性","玩起来","（","下面","做","手中","一起","编写","冻结","五彩","负责","一等","辅助","；","什么","无论是","dynamic","齐放","scratch","平台","故事","合","他们","成为","为","codelab","虚拟","adapter","了","酷上","第三","+","新","restful","哪些","接入","物体","上方","即可","让","playground","-","现成","挥动",":","在","实现","ai","主要","实施","l","\"","关掉","两个","或","入门","开放","生日","处境","语言","硬件","extension","编程语言","实物","your","turn","第一","灯","玩起","世界","视为","和","被",")","致力","增强","world","将","自己","ta","那天","python","当前","灯具","link","中","进门","二个","对","通过","一场","上书","演示","这里","、","案例","演绎","...","入门者","支持","当","eim","具体","强大","!","因此","可扩展性","用途","为己","外部","如何","加酷","点亮","高度","。","：","打开",";","动画","也","，","现实","一挥","彼此","万物","由","可编程","之上","构建","连接","阅读","无论","可","第一个","看","静止","message","展性","起来","快速","iot","开源","blockly","？","皆","多","等","特色","把","操控","瞬间","驱动","请","解冻","所用","有","魔法","使","还是","右侧","¶","在线","第三个","集锦","写","a","api","34","）","三个","空间","正在","沉浸","里","魔杖","始","空中","智能","互动","烟花","字母","插件","理解","使用","虚拟世界","更","node","轨迹","创作","两者"," ","时间","扩展性","它","视频","思考","编程","能","与","代码","可编","the","节点","修改","多门","everything","是","环境","房间","角色","消息","秀","包括","手","公民","朋友","table","致力于","左侧","能力","同时","沟通","is","一刻","控制"],"title":"主页(Home)","title_tokens":["主页",")","home","("]},{"location":"#codelab-adapter","text":"Turn the world into your playground!","text_tokens":["!","into","playground","world","your","turn"," ","the"],"title":"CodeLab Adapter","title_tokens":["adapter"," ","codelab"]},{"location":"#_1","text":"CodeLab Adapter 是一个由 Python 构建的软件(构建在消息之上( Everything Is a Message ))， 致力于连接万物，无论是软件还是硬件，无论是 AI、开源硬件、现实世界的物体、还是虚拟世界的动画角色，接入 CodeLab Adapter，皆可彼此互动。 \"连接能力\" 和 \"可扩展性\" 是它的主要特色。 在 CodeLab Adapter 驱动的环境里，通过使用 Scratch 或 Python 编程，你可以与万物沟通: 你可以在朋友生日那天，在 Ta 进门的一刻，将手中的魔杖一挥，在空中划一个字母 L 的轨迹，瞬间，点亮房间里五彩的灯光。 具体请看下面两个演示案例： 在上方视频中, 我们做了一场魔法烟花秀: 请看视频左侧，当挥动手中的魔杖实施第一个魔法，时间被冻结，视频右侧烟花静止在空中；实施第二个魔法，将烟花\"解冻\"; 实施第三个魔法-- 百花齐放。 Adapter 负责将烟花(虚拟)与魔杖(实物)连接在一起，用户在一个 创作平台 中即可同时操控两者，演绎自己编写的故事。 上方第二个视频演示了如何构建一个 理解 你当前处境的 AI，当你正在阅读时，AI 将为你把灯打开；当你合上书，AI 将为你把灯关掉，让你沉浸在黑暗中思考。 Adapter 负责接入外部 AI 与现实空间内的智能灯具，辅助你在 创作平台 中通过编程控制他们。 下面请看案例集锦视频，更多的在 这里 。","text_tokens":[",","的","(","扩展","百花齐放","可以","一个","划","百花","用户","时","内","第二","你","第二个","黑暗","我们","灯光","软件","下面","做","手中","一起","编写","冻结","五彩","负责","辅助","；","无论是","齐放","scratch","平台","故事","合","他们","为","codelab","虚拟","adapter","了","第三","接入","物体","上方","即可","让","-","挥动",":","在","ai","主要","实施","l","\"","关掉","两个","或","生日","处境","硬件","实物","第一","灯","世界","和","被",")","致力","将","自己","ta","那天","python","当前","灯具","中","进门","二个","通过","一场","上书","演示","这里","、","案例","演绎","当","具体","可扩展性","外部","如何","点亮","。","：","打开",";","动画","，","现实","一挥","彼此","万物","由","之上","构建","连接","阅读","无论","可","第一个","看","静止","message","展性","开源","皆","多","特色","把","操控","瞬间","驱动","请","解冻","魔法","还是","右侧","第三个","集锦","a","三个","空间","正在","沉浸","里","魔杖","空中","智能","互动","烟花","字母","理解","使用","虚拟世界","更","轨迹","创作","两者"," ","时间","扩展性","它","视频","思考","编程","与","everything","是","环境","房间","角色","消息","秀","朋友","致力于","左侧","能力","同时","沟通","is","一刻","控制"],"title":"是什么？","title_tokens":["是","什么","？"]},{"location":"#_2","text":"CodeLab Adapter 的典型用途包括: 扩展 Scratch 的能力（ 比 Scratch Link 更强大 ） 为它接入 AI、IoT、开源硬件、始就玩起来实物、虚拟角色...使Scratch成为酷上加酷的 创作平台 Python 入门 Adapter 由 Python 构建，对 Scratch 的增强也是通过使用 Python 写的插件实现。因此，Python 入门者通过简单修改现成插件代码为己所用、或编写新的插件代码，即可快速上手玩起来 构建可编程空间 构建 Dynamic Table 扩展在线编程平台(Blockly 等)的能力","text_tokens":["的","扩展","(","上","典型","比","就","简单","玩起来","（","编写","dynamic","成为","scratch","平台","为","codelab","虚拟","adapter","酷上","新","接入","即可","现成",":","实现","ai","入门","或","硬件","玩起","实物",")","增强","python","link","对","通过","、","...","入门者","强大","因此","用途","为己","加酷","。","也","，","由","可编程","构建","起来","快速","iot","开源","blockly","等","所用","使","在线","写","）","空间","始","插件","使用","更","创作"," ","它","编程","代码","可编","修改","是","角色","包括","手","table","能力"],"title":"能做什么？","title_tokens":["？","能","做","什么"]},{"location":"#_3","text":"开放 高度可扩展 插件(Extension) 和 节点(Node) 万物皆消息(EIM, Everything Is a Message) RESTful API 支持多门编程语言(34+) 将 Scratch 和 Python 视为一等公民","text_tokens":[",","扩展","(","高度","开放","插件","语言","编程语言","extension","node","万物","视为"," ","和",")","可","编程","message","一等","将","皆","python","节点","多门","everything","scratch","a","消息","公民","支持","+","34","eim","api","is","restful"],"title":"特性有哪些？","title_tokens":["哪些","？","有","特性"]},{"location":"changelog/","text":"changelog ¶ 2018.5.26 v0.1.0 2018.5.28 v0.1.1 fix extension_cozmo bug 2018.10.24 v0.2.0， 重构笔记 2018.11.30 v0.2.3 2018.12.03 0.3.0 支持eim_script 2018.12.14 0.3.1 fix bug：多个 ws 通道重复 pub；直接展示插件 2019.01.16 0.4.0 支持第三方网站接入 增加插件 完善插件的管理，退出后自动清理子进程 第三方库支持 requests pyserial Pillow 2019.01.29 0.5.0 修复 read 阻塞问题（导致需要额外的一条消息才能推出插件） 支持前端启停插件 将消息用作内部管理机制 rename scratch3-adapter to codelab-adapter 添加树莓派插件（gpiozero） 支撑多个 client 并行作为 UI（同步） 2019.01.30 0.5.1 添加调试（Debug）页面 2019.02.14 0.6.0 添加 REST API 统一消息体命名规范：message.data/message.message -> message.payload 添加 打开本地文件目录 功能 内置微信插件（extension_wechat） 添加 typing 库 完善 cli mode 2019.02.14 0.6.1 提高微信插件（extension_wechat）的易用性（内置） 2019.02.15 0.6.2 fix bug 2019.02.16 0.7.0 允许跨域访问 websocket/REST API, 方便开发者调试 为 webdebug 添加 REST API 调试工具 2019.02.23 0.7.1 让 Cozmo/Vector 插件支持同步模式（通过添加 messageID），至于采用同步模式还是异步模式，由 client 决定 添加 extension_mpfshell 扩展（by junhuanchen ） 2019.02.26 0.8.0 允许用户添加自定义配置： ~/codelab_adapter/user_settings.py 典型的配置包括： cli_load_extension_threads = [\"extension_iot\"] 命令行模式（./codelab-adapter --mode cli）默认启动插件 add gpiozero for raspberrypi platform 内置 mqtt client/broker： hbmqtt 内置 extension_iot 更新 extension_mpfshell 2019.03.16 0.8.1 微信插件支持收发群消息 添加 web 日志页面 添加重构之后的 blender 插件 2019.08.28 2.3.1 2019.09.10 2.5.0 安全性改进 2019.09.23 2.5.1 使用 Scratch 配色风格的 Web UI 版本号更新提醒（只提醒旧版本，不提醒测试版升级） 报告 adapter core 信息（version） 2019.09.23 2.5.3 将 GUI menu 迁移到 Web UI 2019.11.13 2.6.0 2.6.x 专注于提高健壮性 添加 rate limit 机制：TokenBucket 为 usb_microbit 添加 TokenBucket 提升 token 安全性（每次启动随机生成；也允许用户在配置文件里固化token） 添加 token 复制按钮（用于粘贴到外部网站） 将 token 添加到 scratch 启动 url 里（提高安全性） 2019.11.13 2.6.1 Scratch3Lab -> CodeLabClub 2019.11.13 2.6.2 支持 headless 模式（linux），用于开机自启、无人值守的环境 2020.04.17 3.0.0 发行说明 2020.04.30 3.1.0 自动更新 adapter home 目录 插件市场支持extension/node下载(统称为plugin)，node可以是任何有效的url链接 Cozmo 插件支持 event、sensor Adapter 默认随最后一个client关闭而关闭，允许用户配置该行为 重构 WebUI 的 Adatper socketio client，使其易于二次开发 2020.12.28 4.0.0 提供 Linda 支持！ 支持激光雷达，将普通地面变为交互式 Scratch 舞台（社区版暂未提供相关支持，目前近提供给CodeLab合作方） 与CodeLab IP访问方式兼容 修复与 token 有关的安全风险 webui, 基于最新codelab_adapter_base.js 解决websocket input token潜在风险 2021.12.31 4.1.0 修复目录字符问题（空格、中文） WebUI 支持 Linda 可视化 修复4.0.0引起的魔杖问题","text_tokens":["管理机制",",","升级","的","一个","开发","典型","内置","1","提升","2019.03","说明","version","settings","工具","messageid","健壮","mpfshell","相关","需要","scratch","js","模式","为","兼容","作为","usb","让","-","16","2018.11","机制","在","重复","市场","event","cozmo","改进","复制","24","微信","extension","pub","添加","更新","任何","2019.02","目录","2","eim","二次","未","方式","页面","web","直接","iot","无人","！","命令","统一","¶","访问","而","2018.12","10","自动更新","3.1","插件","="," ","旧版","webdebug","统称","生成","linda","rest","到","2018.10","v0.2","2.5","重构","by","第三方","2019.09","扩展","前端","threads","最新","0.6","易用性","行为","版本号","2.3","其","笔记","规范","问题","read","]","自启",".","启动","for","有关","第三","0.8","自动","fix","旧版本","基于","文件目录","下载","add","14","随","派",")","发行","普通","按钮","增加","并行","03","解决","menu","、","webui","配置","测试版","支持","提醒","合作方","最后","打开","3","typing","sensor","库","scratch3","platform","易于","requests","message","该","还是","异步","client","4.0","）","粘贴","提供","开发者","29","方便","决定","关闭","13","[","每次","与","26","2.6","报告","28","0.5","base","消息","包括","2019.11","headless","目前","跨域","(","用户","可以","debug","二次开发","core","data","2019.01","mode","15","值守","websocket","scratch3lab","内部","迁移","功能","blender","测试","接入","开机","近","py","子","hbmqtt","激光雷达","体","wechat","token","之后","版暂","vector","bug","文件","junhuanchen","激光","合作","三方","命名","/","将","自定","pyserial","_","空格","通过","raspberrypi","linux","23","只","socketio","交互式","收发","展示","2018.5","用于","codelabclub","：","microbit","0","x","完善","给","由","to","17","安全性","清理","v0.1","允许","才能","使","默认","交互","字符","api","修复","url","load","日志","里","信息","同步","changelog","2020.04","node","plugin","中文","安全","命令行","退出","环境","adatper","阻塞","payload","31","2020.12","一条","ws","地面","进程","gpiozero","0.7","多个","自定义",">","（","风格","4.1","limit","用作","0.3","于","script","社区","；","通道","提高","后","2021.12","配色","rate","codelab","adapter","cli","网站","启停","tokenbucket","本地","有效","~","mqtt","\"","ui","变为","健壮性","ip","链接","30","舞台","home","可视化","潜在","专注","管理","配置文件","外部","gui","群","也","树莓","，","调试","额外","定义","可视","pillow","易用","推出","雷达","版本","魔杖","风险","导致","至于","随机","使用","2019.08","采用","固化","不","引起","rename","user","0.4","是","支撑","3.0","input","broker"],"title":"历史(changelog)","title_tokens":[")","历史","changelog","("]},{"location":"changelog/#changelog","text":"2018.5.26 v0.1.0 2018.5.28 v0.1.1 fix extension_cozmo bug 2018.10.24 v0.2.0， 重构笔记 2018.11.30 v0.2.3 2018.12.03 0.3.0 支持eim_script 2018.12.14 0.3.1 fix bug：多个 ws 通道重复 pub；直接展示插件 2019.01.16 0.4.0 支持第三方网站接入 增加插件 完善插件的管理，退出后自动清理子进程 第三方库支持 requests pyserial Pillow 2019.01.29 0.5.0 修复 read 阻塞问题（导致需要额外的一条消息才能推出插件） 支持前端启停插件 将消息用作内部管理机制 rename scratch3-adapter to codelab-adapter 添加树莓派插件（gpiozero） 支撑多个 client 并行作为 UI（同步） 2019.01.30 0.5.1 添加调试（Debug）页面 2019.02.14 0.6.0 添加 REST API 统一消息体命名规范：message.data/message.message -> message.payload 添加 打开本地文件目录 功能 内置微信插件（extension_wechat） 添加 typing 库 完善 cli mode 2019.02.14 0.6.1 提高微信插件（extension_wechat）的易用性（内置） 2019.02.15 0.6.2 fix bug 2019.02.16 0.7.0 允许跨域访问 websocket/REST API, 方便开发者调试 为 webdebug 添加 REST API 调试工具 2019.02.23 0.7.1 让 Cozmo/Vector 插件支持同步模式（通过添加 messageID），至于采用同步模式还是异步模式，由 client 决定 添加 extension_mpfshell 扩展（by junhuanchen ） 2019.02.26 0.8.0 允许用户添加自定义配置： ~/codelab_adapter/user_settings.py 典型的配置包括： cli_load_extension_threads = [\"extension_iot\"] 命令行模式（./codelab-adapter --mode cli）默认启动插件 add gpiozero for raspberrypi platform 内置 mqtt client/broker： hbmqtt 内置 extension_iot 更新 extension_mpfshell 2019.03.16 0.8.1 微信插件支持收发群消息 添加 web 日志页面 添加重构之后的 blender 插件 2019.08.28 2.3.1 2019.09.10 2.5.0 安全性改进 2019.09.23 2.5.1 使用 Scratch 配色风格的 Web UI 版本号更新提醒（只提醒旧版本，不提醒测试版升级） 报告 adapter core 信息（version） 2019.09.23 2.5.3 将 GUI menu 迁移到 Web UI 2019.11.13 2.6.0 2.6.x 专注于提高健壮性 添加 rate limit 机制：TokenBucket 为 usb_microbit 添加 TokenBucket 提升 token 安全性（每次启动随机生成；也允许用户在配置文件里固化token） 添加 token 复制按钮（用于粘贴到外部网站） 将 token 添加到 scratch 启动 url 里（提高安全性） 2019.11.13 2.6.1 Scratch3Lab -> CodeLabClub 2019.11.13 2.6.2 支持 headless 模式（linux），用于开机自启、无人值守的环境 2020.04.17 3.0.0 发行说明 2020.04.30 3.1.0 自动更新 adapter home 目录 插件市场支持extension/node下载(统称为plugin)，node可以是任何有效的url链接 Cozmo 插件支持 event、sensor Adapter 默认随最后一个client关闭而关闭，允许用户配置该行为 重构 WebUI 的 Adatper socketio client，使其易于二次开发 2020.12.28 4.0.0 提供 Linda 支持！ 支持激光雷达，将普通地面变为交互式 Scratch 舞台（社区版暂未提供相关支持，目前近提供给CodeLab合作方） 与CodeLab IP访问方式兼容 修复与 token 有关的安全风险 webui, 基于最新codelab_adapter_base.js 解决websocket input token潜在风险 2021.12.31 4.1.0 修复目录字符问题（空格、中文） WebUI 支持 Linda 可视化 修复4.0.0引起的魔杖问题","text_tokens":["管理机制",",","升级","的","一个","开发","典型","内置","1","提升","2019.03","说明","version","settings","工具","messageid","健壮","mpfshell","相关","需要","scratch","js","模式","为","兼容","作为","usb","让","-","16","2018.11","机制","在","重复","市场","event","cozmo","改进","复制","24","微信","extension","pub","添加","更新","任何","2019.02","目录","2","eim","二次","未","方式","页面","web","直接","iot","无人","！","命令","统一","访问","而","2018.12","10","自动更新","3.1","插件","="," ","旧版","webdebug","统称","生成","linda","rest","到","2018.10","v0.2","2.5","重构","by","第三方","2019.09","扩展","前端","threads","最新","0.6","易用性","行为","版本号","2.3","其","笔记","规范","问题","read","]","自启",".","启动","for","有关","第三","0.8","自动","fix","旧版本","基于","文件目录","下载","add","14","随","派",")","发行","普通","按钮","增加","并行","03","解决","menu","、","webui","配置","测试版","支持","提醒","合作方","最后","打开","3","typing","sensor","库","scratch3","platform","易于","requests","message","该","还是","异步","client","4.0","）","粘贴","提供","开发者","29","方便","决定","关闭","13","[","每次","与","26","2.6","报告","28","0.5","base","消息","包括","2019.11","headless","目前","跨域","(","用户","可以","debug","二次开发","core","data","2019.01","mode","15","值守","websocket","scratch3lab","内部","迁移","功能","blender","测试","接入","开机","近","py","子","hbmqtt","激光雷达","体","wechat","token","之后","版暂","vector","bug","文件","junhuanchen","激光","合作","三方","命名","/","将","自定","pyserial","_","空格","通过","raspberrypi","linux","23","只","socketio","交互式","收发","展示","2018.5","用于","codelabclub","：","microbit","0","x","完善","给","由","to","17","安全性","清理","v0.1","允许","才能","使","默认","交互","字符","api","修复","url","load","日志","里","信息","同步","2020.04","node","plugin","中文","安全","命令行","退出","环境","adatper","阻塞","payload","31","2020.12","一条","ws","地面","进程","gpiozero","0.7","多个","自定义",">","（","风格","4.1","limit","用作","0.3","于","script","社区","；","通道","提高","后","2021.12","配色","rate","codelab","adapter","cli","网站","启停","tokenbucket","本地","有效","~","mqtt","\"","ui","变为","健壮性","ip","链接","30","舞台","home","可视化","潜在","专注","管理","配置文件","外部","gui","群","也","树莓","，","调试","额外","定义","可视","pillow","易用","推出","雷达","版本","魔杖","风险","导致","至于","随机","使用","2019.08","采用","固化","不","引起","rename","user","0.4","是","支撑","3.0","input","broker"],"title":"changelog","title_tokens":["changelog"]},{"location":"DynamicTable/","text":"介绍 ¶ DynamicTable 是: 集体想象的产物。 是一个工具包(toolkit)，而不是一个 APP 鼓励创作者使用剪刀、纸张、玩具等事物进行创作。 是一种开放的可编程环境 使用 Scratch 即时构建应用程序。 基于 CodeLab Adapter 连接万物 与 CodeLab 可编程空间拥有一样的设计理念，可以视为它的一个 micro 版本 实物与虚拟事物融合在桌面上，可交互 交互的规则由用户自定义 在环境中,洞悉(seeing)事物的内部/运行状态，以便于创作者真正理解复杂事物 详情参考: CodeLab DynamicTable: A Seeing World CodeLab DynamicTable: 一个可实施的技术方案","text_tokens":[",","的","(","用户","应用","一个","可以","自定义","想象","事物","融合","拥有","于","桌面上","工具","内部","杂事","设计","scratch","codelab","虚拟","介绍","adapter","一样","规则","创作者","基于",":","在","实施","鼓励","开放","不是","一种","实物","视为","参考","真正",")","理念","toolkit","/","自定","world","作者","产物","中","、","复杂","以便","纸张","dynamictable","方案","集体","micro","。","，","万物","可编程","由","状态","构建","连接","洞悉","可","定义","运行","玩具","技术","等","工具包","应用程序","即时","桌面","¶","而","交互","a","进行","空间","版本","程序","详情","理解","使用","seeing","创作","剪刀"," ","它","编程","复杂事物","面上","与","可编","是","环境","app"],"title":"介绍(introduction)","title_tokens":["介绍",")","introduction","("]},{"location":"DynamicTable/#_1","text":"DynamicTable 是: 集体想象的产物。 是一个工具包(toolkit)，而不是一个 APP 鼓励创作者使用剪刀、纸张、玩具等事物进行创作。 是一种开放的可编程环境 使用 Scratch 即时构建应用程序。 基于 CodeLab Adapter 连接万物 与 CodeLab 可编程空间拥有一样的设计理念，可以视为它的一个 micro 版本 实物与虚拟事物融合在桌面上，可交互 交互的规则由用户自定义 在环境中,洞悉(seeing)事物的内部/运行状态，以便于创作者真正理解复杂事物 详情参考: CodeLab DynamicTable: A Seeing World CodeLab DynamicTable: 一个可实施的技术方案","text_tokens":[",","的","(","用户","应用","一个","可以","自定义","想象","事物","融合","拥有","于","桌面上","工具","内部","杂事","设计","scratch","codelab","虚拟","adapter","一样","规则","创作者","基于",":","在","实施","鼓励","开放","不是","一种","实物","视为","参考","真正",")","理念","toolkit","/","自定","world","作者","产物","中","、","复杂","以便","纸张","dynamictable","方案","集体","micro","。","，","万物","可编程","由","状态","构建","连接","洞悉","可","定义","运行","玩具","技术","等","工具包","应用程序","即时","桌面","而","交互","a","进行","空间","版本","程序","详情","理解","使用","seeing","创作","剪刀"," ","它","编程","复杂事物","面上","与","可编","是","环境","app"],"title":"介绍","title_tokens":["介绍"]},{"location":"DynamicTable/hello_world/","text":"hello world ¶ 依赖 ¶ DynamicTable 依赖于 Adapter 的内置的 node_physical_blocks 插件。 node_physical_blocks 最近推出了2.0版本: physical blocks 2.0 本文目前基于1.0版本。 Scratch ¶ 打开这两个插件: ImageData Physical Blocks ImageData 负责与 Scratch 舞台区数据交互，诸如获取舞台区的截图或者视频数据等。 我们可以将这些数据传递到 Adapter 处理: node_physical_blocks 便是一个能够处理 ImageData 数据的插件，你也可以自定义插件。 获取视频中的 marker 信息 ¶ 首先我们要开启摄像头( 镜像开启 ) 获取 marker id 列表 ¶ 使用该积木可以获得摄像头里所有的 marker 的 id 列表 可以看到视频里，一共有 4 个 marker，从左到右 id 分别为 28， 27，26，25 利用这个积木，可以构建 单词拼写程序 获取 marker 旋转角 ¶ 使用该积木可以获得摄像头里某个 marker 的旋转角 Scratch-marker-angle-demo.sb3 利用旋转角可以构建纸糊方向盘: 获取 marker 位置 ¶ 使用该积木可以获得摄像头里某个 marker 的位置信息","text_tokens":["的","(","可以","一个","看到","你","demo","内置","我们","利用","自定义","获取","数据","区","像头","负责","纸糊","便是","一共","这些","scratch",".","为","adapter","了","marker","要","25","所有","27","单词","-","基于",":","处理","方向","两个","physical","摄像","拼写","诸如",")","舞台","world","赖于","将","自定","_","获得","中","某个","分别","首先","id","方向盘","镜像","dynamictable","能够","依赖","传递","列表","。","打开","也","，","或者","摄像头","hello","角","angle","旋转","构建","最近","位置","定义","2.0","本文","这","等","该","推出","有","¶","交互","1.0","截图","imagedata","版本","里","程序","4","信息","插件","使用","积木","node"," ","视频","blocks","个","与","这个","26","到","从左到右","28","依赖于","开启","sb3","目前"],"title":"hello world","title_tokens":["world"," ","hello"]},{"location":"DynamicTable/hello_world/#hello-world","text":"","text_tokens":[],"title":"hello world","title_tokens":["world"," ","hello"]},{"location":"DynamicTable/hello_world/#_1","text":"DynamicTable 依赖于 Adapter 的内置的 node_physical_blocks 插件。 node_physical_blocks 最近推出了2.0版本: physical blocks 2.0 本文目前基于1.0版本。","text_tokens":["的","dynamictable","版本","基于",":","依赖","。","physical","内置","插件","node"," ","最近","blocks","2.0","本文","赖于","_","推出","依赖于","adapter","了","1.0","目前"],"title":"依赖","title_tokens":["依赖"]},{"location":"DynamicTable/hello_world/#scratch","text":"打开这两个插件: ImageData Physical Blocks ImageData 负责与 Scratch 舞台区数据交互，诸如获取舞台区的截图或者视频数据等。 我们可以将这些数据传递到 Adapter 处理: node_physical_blocks 便是一个能够处理 ImageData 数据的插件，你也可以自定义插件。","text_tokens":["截图","的","imagedata","能够","可以","一个",":","传递","你","处理","。","两个","physical","打开","插件","我们","也","，","或者","自定义","node","获取","数据"," ","诸如","视频","blocks","舞台","区","定义","负责","自定","将","与","这","_","等","便是","这些","到","scratch","adapter","交互"],"title":"Scratch","title_tokens":["scratch"]},{"location":"DynamicTable/hello_world/#marker","text":"首先我们要开启摄像头( 镜像开启 )","text_tokens":["像头","我们","开启","(","首先","摄像头"," ","摄像","要","镜像",")"],"title":"获取视频中的 marker 信息","title_tokens":["的","获取","marker"," ","中","信息","视频"]},{"location":"DynamicTable/hello_world/#marker-id","text":"使用该积木可以获得摄像头里所有的 marker 的 id 列表 可以看到视频里，一共有 4 个 marker，从左到右 id 分别为 28， 27，26，25 利用这个积木，可以构建 单词拼写程序","text_tokens":["的","可以","里","程序","看到","列表","4","利用","使用","，","积木","摄像头"," ","摄像","拼写","构建","视频","个","像头","这个","26","获得","一共","该","有","从左到右","为","28","分别","id","marker","25","所有","27","单词"],"title":"获取 marker id 列表","title_tokens":["id","获取","列表","marker"," "]},{"location":"DynamicTable/hello_world/#marker_1","text":"使用该积木可以获得摄像头里某个 marker 的旋转角 Scratch-marker-angle-demo.sb3 利用旋转角可以构建纸糊方向盘:","text_tokens":["的","-","可以","里",":","方向","demo","利用","使用","积木","摄像头","角","angle"," ","摄像","旋转","构建","像头","纸糊","获得","该","scratch","某个",".","marker","sb3","方向盘"],"title":"获取 marker 旋转角","title_tokens":["获取","角","marker","旋转"," "]},{"location":"DynamicTable/hello_world/#marker_2","text":"使用该积木可以获得摄像头里某个 marker 的位置信息","text_tokens":["位置","像头","的","使用","积木","可以","摄像头","里","marker","获得","摄像"," ","信息","该","某个"],"title":"获取 marker 位置","title_tokens":["marker","位置"," ","获取"]},{"location":"Neverland/","text":"介绍 ¶ 这是 社区版 Neverland 相关文档。 解释 CodeLab Neverland 是什么？ ¶ CodeLab Neverland 是一个 可编程空间 。 CodeLab Neverland 核心由 CodeLab Adapter 驱动。它致力于连接万物，无论是软件还是硬件，无论是 AI、开源硬件、现实世界的物体，还是虚拟世界的动画角色，在 CodeLab Adapter 的驱动下，皆可彼此互动。 在 CodeLab Neverland，你可以与万物沟通，你可以让神经网络识别出你的身体部位，进而制作一个体感游戏，或是通过算法让整个空间变得智能。你可以在朋友生日那天，在 Ta 进门的一刻，将手中的魔杖一挥，在空中划一个字母 L 的轨迹，瞬间，点亮房间里五彩的灯光。在这儿，你将轻松做出这样的魔杖。 我们希望将你带入一个魔法世界，一个由编程驱动的世界。 同时，CodeLab Neverland 也致力于去实践约翰·杜威提倡的 Education as life. 本文档致力于帮助大家复现我们 在 Neverland 里做的好玩项目 ，以下是它们的构建和使用文档: 收工，吃饭 读书与思考 乐器演奏 (Teachable Machine)","text_tokens":["的","带入","(","可以","一个","划","解释","你","我们","灯光","软件","算法","做","手中","这儿","as","社区","五彩","杜威","什么","无论是","相关","制作",".","去","codelab","虚拟","介绍","adapter","machine","下","物体","让","这是",":","在","版","ai","l","生日","神经网络","大家","硬件","世界","和",")","致力","核心","网络","将","ta","那天","进门","通过","、","游戏","做出","整个","演奏","或是","出","它们","读书","点亮","。","文档","动画","也","好玩","，","现实","一挥","彼此","万物","可编程","由","希望","提倡","收工","连接","构建","无论","可","本","开源","实践","？","皆","以下","瞬间","驱动","约翰","神经网","魔法","还是","变得","¶","轻松","neverland","项目","空间","乐器","里","魔杖","识别","复现","智能","空中","互动","·","字母","teachable","使用","虚拟世界","身体","轨迹","education"," ","life","它","思考","编程","部位","进而","与","可编","是","房间","角色","神经","体感","帮助","朋友","致力于","吃饭","同时","沟通","一刻","这样"],"title":"介绍(introduction)","title_tokens":["介绍",")","introduction","("]},{"location":"Neverland/#_1","text":"这是 社区版 Neverland 相关文档。 解释","text_tokens":["这是","社区","解释","版","neverland","。"," ","文档","相关"],"title":"介绍","title_tokens":["介绍"]},{"location":"Neverland/#codelab-neverland","text":"CodeLab Neverland 是一个 可编程空间 。 CodeLab Neverland 核心由 CodeLab Adapter 驱动。它致力于连接万物，无论是软件还是硬件，无论是 AI、开源硬件、现实世界的物体，还是虚拟世界的动画角色，在 CodeLab Adapter 的驱动下，皆可彼此互动。 在 CodeLab Neverland，你可以与万物沟通，你可以让神经网络识别出你的身体部位，进而制作一个体感游戏，或是通过算法让整个空间变得智能。你可以在朋友生日那天，在 Ta 进门的一刻，将手中的魔杖一挥，在空中划一个字母 L 的轨迹，瞬间，点亮房间里五彩的灯光。在这儿，你将轻松做出这样的魔杖。 我们希望将你带入一个魔法世界，一个由编程驱动的世界。 同时，CodeLab Neverland 也致力于去实践约翰·杜威提倡的 Education as life. 本文档致力于帮助大家复现我们 在 Neverland 里做的好玩项目 ，以下是它们的构建和使用文档: 收工，吃饭 读书与思考 乐器演奏 (Teachable Machine)","text_tokens":["的","带入","(","可以","一个","划","你","我们","灯光","软件","算法","做","手中","这儿","as","五彩","杜威","无论是","制作",".","去","codelab","虚拟","adapter","machine","下","物体","让",":","在","ai","l","生日","神经网络","大家","硬件","世界","和",")","致力","核心","网络","将","ta","那天","进门","通过","、","游戏","做出","整个","演奏","或是","出","它们","读书","点亮","。","文档","动画","也","好玩","，","现实","一挥","彼此","万物","可编程","由","希望","提倡","收工","连接","构建","无论","可","本","开源","实践","皆","以下","瞬间","驱动","约翰","神经网","魔法","还是","变得","轻松","neverland","项目","空间","乐器","里","魔杖","识别","复现","智能","空中","互动","·","字母","teachable","使用","虚拟世界","身体","轨迹","education"," ","life","它","思考","编程","部位","进而","与","可编","是","房间","角色","神经","体感","帮助","朋友","致力于","吃饭","同时","沟通","一刻","这样"],"title":"CodeLab Neverland 是什么？","title_tokens":["codelab","？","neverland"," ","什么","是"]},{"location":"Neverland/HA/","text":"安装和配置 Home Assistant ¶ Neverland 社区版 Neverland 使用 Home Assistant 驱动家居/联网设备，用户可以使用 CodeLab Scratch、Python，或者 CodeLab Adapter 支持的 其他 34 门编程语言 ，与家居/联网设备交互。 Home Assistant 简介 ¶ Home Assistant 是一个开源家庭自动化软件，将隐私放在首位，由全球各地的志愿者构建。目前支持 1,500+ 智能家居设备。 Home Assistant 采用 Python 构建，可以运行在任何主流操作系统，以及 树莓派 中。 安装在哪里？ ¶ Home Assistant 有 多种安装方法 。如果你打算长期使用它，将其用于家庭自动化，推荐 在树莓派上安装 。 如果你安装它是为了临时使用 Scratch 来对家庭设备进行编程，则直接在你编程的电脑上安装即可。 环境依赖 ¶ Python >= 3.6 开始安装 ¶ pip3 install homeassistant 国内用户可通过更换 pypi 源加速安装过程: pip3 install homeassistant -i https://mirrors.aliyun.com/pypi/simple 启动 Home Assistant ¶ hass --open-ui 第一次启动时，会安装部分依赖项，根据网络情况不同，耗时不等。 一切准备就绪，将自动打开浏览器，进入都 Home Assistant 主页。访问地址是： http://127.0.0.1:8123 第一次使用需要填写基本用户信息，放心，数据都保存在本地。 添加智能设备 ¶ 这里展示如何接入 Yeelight 彩光灯（ 购买链接 ）和米家智能家庭套装（ 购买链接 ）。 如果你有其他智能设备需要接入，可参考 官方文档 。或者 Google 搜索 home assistant + 你想接入的设备 。 接入 Yeelight 彩光灯 ¶ 步骤 1：配网 ¶ 下载 Yeelight 手机客户端 ，按照 App 引导，为彩光灯配网。 配网完成后，你应该能使用 App 控制它。 步骤 2：局域网访问 ¶ 进入设备页，点击右下角按钮。 允许局域网访问。 步骤 3：获取设备 IP ¶ 进入设备页，点击左上角控制器，获取设备 IP。 步骤 4：添加配置信息 ¶ 将 Yeelight 彩光灯配置信息，添加到 Home Assistant 配置文件（configuration.yaml） 里。 配置文件所在路径: macOS ~/.homeassistant Linux ~/.homeassistant Windows %APPDATA%/.homeassistant 添加配置信息: yeelight : devices : 192.168.21.102 : name : Living Room 步骤 5：重启 Home Assistant ¶ 重启之后，你应该可以使用 Home Assistant 控制 Yeelight 彩光灯了！ 提醒 米家智能家庭套装似乎已经不支持局域网通信。 推荐使用兼容 HomeKit 的网关，可以直接接入 Home Assistant 步骤 1：配网 ¶ 下载 米家 手机客户端 ，按照APP引导，首先为 智能网关 配网，之后把其他设备接入进来。 配网完成后，你应该能使用 App 控制它们。 步骤 2：局域网访问 ¶ 进入 智能网关 页，点击右上角，点击 关于 。 进入关于页，猛戳空白处多下（操作听硬核的 :P）， 将出现 局域网通信协议 ， 点击进入，打开它，并记下密码： 步骤 3：添加配置信息 ¶ 将 Yeelight 彩光灯配置信息，添加到 Home Assistant配置文件（configuration.yaml） 里。 配置文件所在路径： macOS ~/.homeassistant Linux ~/.homeassistant Windows %APPDATA%/.homeassistant 添加配置信息： xiaomi_aqara : discovery_retry : 5 gateways : - key : 60n163sp2rduqx4ri 步骤 4：重启 Home Assistant ¶ 重启之后，你应该可以使用 Home Assistant 控制 米家智能家庭套装 里的设备了！ 使用 CodeLab Scratch 连接 Home Assistant ¶ 为了方便用户使用 Scratch 驱动家居设备，我们需要获取 Home Assistant 的访问 token，将其粘贴到 CodeLab Scratch 里的 Home Assistant 拓展积木里。如此一来我们就可以使用 CodeLab Scratch 来为家庭/教室里的设备编程。打个响指，把灯关掉！ 获取 Home Assistant 访问 token ¶ 如图依次按顺序（1、2、3）操作： 由于 token 只出现一次，所以你最好先复制粘贴到记事本里。 使用 CodeLab Scratch 为家庭设备编程！ ¶ 你既可以使用 CodeLab Scratch 在线版 ，也可以使用 离线版 来进行编程。 在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。 如果你使用离线版，则下载 源码文件 ，使用 Scratch 加载它即可。 加载后填入你之前记下的 token。 提醒 如果你的 Home Assistant 访问地址不是 http://127.0.0.1:8123 (诸如运行在树莓派上)，你就无法在 在线版 中连接它( 浏览器安全策略 )。有两种解决方案: 1. 使用离线版 2. 将 Home Assistant 的访问地址 http://127.0.0.1:8123 映射到 https 上，可以采用以下任何一种方案: * ngrok ：下载并运行 ngrok http 8123 ，你将 Home Assistant 的访问地址暴露到了 https 公网, 形如: https://ff4b68f8.ngrok.io . * 其他办法 提醒 如果想接入 zigbee 设备，请使用 zigbee2mqtt ，目前已支持 以下设备 拓展 ¶ 除了可以使用 CodeLab Scratch 连接 Home Assistant，我们还可以使用 CodeLab Adapter 连接 Home Assistant，这对我们在创客/IoT 实验室里展开教学，以及进行多语言教学（34+ 编程语言）都很有用。 这部分的文档我们将在未来同步过来。 参考 ¶ Installation in Python virtual environment Install Home Assistant","text_tokens":[",","的","一个","上","为了","家庭","准备就绪","除了","1","aqara","数据","家居","进来","引导","ngrok","scratch","需要","通信","为","兼容","临时","3.6","key","已经","即可","-","在","版","记事","打算","填写","复制","一种","第一","全球","耗时","0.1","添加","搜索","网络","任何","下角","硬核","密码","过程","对","appdata%","2","愿者","如","方式","并","保存","或者","不同","构建","直接","方法","iot","加载","这","等","！","把","¶","访问","似乎","已","智能网","4","出现","gateways","=","解决方案"," ","情况","网关","到","500","智能家居","策略","填入","办法","映射","主流","其","部分","网","软件","获取","重启","浏览器","关于","复制粘贴","设备","zigbee","记事本",".","启动","各地","购买","+","自动","要","右上角","点击","打开方式","自动化","关","第一次","未来","如此","关掉","操作系统","下载","homekit","派","i",")","按","来","hass","控制器","加速","按照","按钮","过来","想","项","解决","、","assistant","配置","支持","提醒","放在首位","它们","8123","方案","依赖","21.102","。","configuration","打开","3","一切","实验室","放心","开始","开源","进入","空白处","以下","请","有","devices","国内","34","项目","）","电脑","粘贴","ff4b68f8","zigbee2mqtt","io","方便","一次","操作","通信协议","与","空白","如图","安全策略","192.168","地址","目前","控制","步骤","(","用户","可以","google","如果","配网","客户端","听","com","多种","戳","应该","右上","左上","长期","猛","下","接入","这部","simple",":","homeassistant","https","局域","就绪","如此一来","install","还","不是","实验","语言","token","之后","参考","文件","诸如","和","pip3","顺序","/","将","python","_","中","官方","路径","形","上角","通过","这里","linux","首先","aliyun","只","展示","套装","用于","更换","公网","yaml","文档","：","主页","由","放在","room","？","运行","简介","系统","yeelight","所在","这部分","很","允许","交互","127.0","在线","进行","里","创客","信息","同步","左上角","之前","积木","右下","%","in","由于","open","编程","living","能","安全","windows","家","依次","源码","环境","拓展","app","installation","name","5","macos","mirrors","时","安装","所以","教学","你","我们","就",">","（","打个","基本","社区","离线","后","retry","教室","codelab","adapter","了","页","会","本地","记下","~","两种","一来","根据","灯配","志愿","ui","编程语言","ip","灯","链接","志愿者","客户","既","p","米家","home","米","局域网","彩光","配置文件","60n163sp2rduqx4ri","家庭设备","联网","*","暴露","浏览","discovery","如何","无法","也","树莓","推荐","，","完成","连接","开方","可","右下角","多","隐私","驱动","以及","其他","neverland","则","手机","展开","首位","智能","使用","哪里","pypi","准备","采用","有用","virtual","它","http","先","environment","响指","都","源","不","协议","xiaomi","是","最好","门"],"title":"安装Home Assistant","title_tokens":["安装"," ","home","assistant"]},{"location":"Neverland/HA/#home-assistant","text":"Neverland 社区版 Neverland 使用 Home Assistant 驱动家居/联网设备，用户可以使用 CodeLab Scratch、Python，或者 CodeLab Adapter 支持的 其他 34 门编程语言 ，与家居/联网设备交互。","text_tokens":["联网","的","用户","可以","版","。","使用","，","或者","语言","编程语言"," ","家居","编程","社区","home","/","设备","与","python","scratch","驱动","codelab","、","assistant","adapter","其他","neverland","交互","门","支持","34"],"title":"安装和配置 Home Assistant","title_tokens":["home","assistant","配置","安装"," ","和"]},{"location":"Neverland/HA/#home-assistant_1","text":"Home Assistant 是一个开源家庭自动化软件，将隐私放在首位，由全球各地的志愿者构建。目前支持 1,500+ 智能家居设备。 Home Assistant 采用 Python 构建，可以运行在任何主流操作系统，以及 树莓派 中。","text_tokens":[",","放在首位","的","可以","一个","自动化","在","首位","智能","主流","家庭","。","操作系统","操作","志愿","1","树莓","软件","，","采用","由","派"," ","家居","全球","志愿者","构建","放在","home","开源","设备","将","任何","python","运行","中","系统","隐私","是","各地","assistant","以及","愿者","500","智能家居","支持","自动","+","目前"],"title":"Home Assistant 简介","title_tokens":[" ","home","简介","assistant"]},{"location":"Neverland/HA/#_1","text":"Home Assistant 有 多种安装方法 。如果你打算长期使用它，将其用于家庭自动化，推荐 在树莓派上安装 。 如果你安装它是为了临时使用 Scratch 来对家庭设备进行编程，则直接在你编程的电脑上安装即可。","text_tokens":["即可","的","安装","用于","自动化","在","上","为了","你","家庭","。","其","如果","打算","推荐","使用","，","树莓","派"," ","它","直接","编程","方法","home","设备","将","来","多种","是","scratch","对","有","assistant","长期","临时","自动","则","家庭设备","进行","电脑"],"title":"安装在哪里？","title_tokens":["安装","哪里","在","？"]},{"location":"Neverland/HA/#_2","text":"Python >= 3.6","text_tokens":[">","=","3.6","python"," "],"title":"环境依赖","title_tokens":["依赖","环境"]},{"location":"Neverland/HA/#_3","text":"pip3 install homeassistant 国内用户可通过更换 pypi 源加速安装过程: pip3 install homeassistant -i https://mirrors.aliyun.com/pypi/simple","text_tokens":["-","mirrors","simple","用户","安装",":","homeassistant","更换","https","install","pypi"," ","i","可","pip3","/","com","加速","源","过程","通过",".","aliyun","国内"],"title":"开始安装","title_tokens":["开始","安装"]},{"location":"Neverland/HA/#home-assistant_2","text":"hass --open-ui 第一次启动时，会安装部分依赖项，根据网络情况不同，耗时不等。 一切准备就绪，将自动打开浏览器，进入都 Home Assistant 主页。访问地址是： http://127.0.0.1:8123 第一次使用需要填写基本用户信息，放心，数据都保存在本地。","text_tokens":["-","本地","时","8123","安装","用户",":","浏览","依赖","保存","在","第一次","就绪","信息","。","部分","一次","准备就绪","根据","：","打开","填写","ui","一切","使用","，","主页","准备","数据","第一"," ","情况","不同","耗时","0.1","基本","放心","open","浏览器","http","网络","home","/","将","hass","进入","等","都","不","是","需要","项",".","启动","assistant","访问","127.0","自动","地址","会"],"title":"启动 Home Assistant","title_tokens":["启动"," ","home","assistant"]},{"location":"Neverland/HA/#_4","text":"这里展示如何接入 Yeelight 彩光灯（ 购买链接 ）和米家智能家庭套装（ 购买链接 ）。 如果你有其他智能设备需要接入，可参考 官方文档 。或者 Google 搜索 home assistant + 你想接入的设备 。","text_tokens":["展示","的","套装","如何","你","google","智能","。","家庭","文档","如果","，","或者","（","灯","参考"," ","链接","和","可","搜索","home","设备","米","官方","家","想","yeelight","需要","有","这里","彩光","assistant","购买","其他","+","接入","）"],"title":"添加智能设备","title_tokens":["设备","智能","添加"]},{"location":"Neverland/HA/#yeelight","text":"","text_tokens":[],"title":"接入 Yeelight 彩光灯","title_tokens":["彩光","灯"," ","接入","yeelight"]},{"location":"Neverland/HA/#1","text":"下载 Yeelight 手机客户端 ，按照 App 引导，为彩光灯配网。 配网完成后，你应该能使用 App 控制它。","text_tokens":["你","。","灯配","网","下载","，","使用","客户端","配网","完成"," ","客户","它","能","按照","引导","应该","后","yeelight","app","为","彩光","控制","手机"],"title":"步骤 1：配网","title_tokens":["1","步骤","配网"," ","："]},{"location":"Neverland/HA/#2","text":"进入设备页，点击右下角按钮。 允许局域网访问。","text_tokens":["允许","右下角","，","设备","右下","下角","访问","进入","按钮","局域网","局域"," ","页","。","点击"],"title":"步骤 2：局域网访问","title_tokens":["步骤","访问","2","局域"," ","局域网","："]},{"location":"Neverland/HA/#3-ip","text":"进入设备页，点击左上角控制器，获取设备 IP。","text_tokens":["，","设备","控制器","获取","进入","ip","控制"," ","左上角","页","。","点击","左上","上角"],"title":"步骤 3：获取设备 IP","title_tokens":["3","步骤","设备","获取","ip"," ","："]},{"location":"Neverland/HA/#4","text":"将 Yeelight 彩光灯配置信息，添加到 Home Assistant 配置文件（configuration.yaml） 里。 配置文件所在路径: macOS ~/.homeassistant Linux ~/.homeassistant Windows %APPDATA%/.homeassistant 添加配置信息: yeelight : devices : 192.168.21.102 : name : Living Room","text_tokens":["里",":","homeassistant","~","21.102","yaml","信息","configuration","。","，","%","（","灯"," ","文件","room","添加","living","home","/","windows","将","macos","路径","到","yeelight","所在",".","彩光","192.168","assistant","配置","linux","appdata%","配置文件","devices","name","）"],"title":"步骤 4：添加配置信息","title_tokens":["步骤","配置"," ","4","信息","：","添加"]},{"location":"Neverland/HA/#5-home-assistant","text":"重启之后，你应该可以使用 Home Assistant 控制 Yeelight 彩光灯了！ 提醒 米家智能家庭套装似乎已经不支持局域网通信。 推荐使用兼容 HomeKit 的网关，可以直接接入 Home Assistant","text_tokens":["的","套装","可以","你","局域","智能","家庭","。","推荐","使用","，","之后","homekit","灯"," ","重启","直接","米家","home","网关","应该","不","！","局域网","yeelight","通信","彩光","兼容","assistant","了","似乎","支持","提醒","接入","控制","已经"],"title":"步骤 5：重启 Home Assistant","title_tokens":["步骤","home","assistant","5"," ","重启","："]},{"location":"Neverland/HA/#1_1","text":"下载 米家 手机客户端 ，按照APP引导，首先为 智能网关 配网，之后把其他设备接入进来。 配网完成后，你应该能使用 App 控制它们。","text_tokens":["智能网","它们","关","你","智能","。","下载","，","使用","客户端","配网","之后","完成"," ","客户","米家","能","设备","进来","按照","引导","应该","把","后","app","为","首先","其他","接入","控制","手机"],"title":"步骤 1：配网","title_tokens":["1","步骤","配网"," ","："]},{"location":"Neverland/HA/#2_1","text":"进入 智能网关 页，点击右上角，点击 关于 。 进入关于页，猛戳空白处多下（操作听硬核的 :P）， 将出现 局域网通信协议 ， 点击进入，打开它，并记下密码：","text_tokens":["智能网","的","并",":","记下","关","局域","智能","。","：","下","打开","操作","出现","，","（","听","通信协议"," ","p","它","关于","将","戳","进入","多","空白处","硬核","协议","密码","局域网","右上","空白","上角","通信","猛","页","右上角","点击","）"],"title":"步骤 2：局域网访问","title_tokens":["步骤","访问","2","局域"," ","局域网","："]},{"location":"Neverland/HA/#3","text":"将 Yeelight 彩光灯配置信息，添加到 Home Assistant配置文件（configuration.yaml） 里。 配置文件所在路径： macOS ~/.homeassistant Linux ~/.homeassistant Windows %APPDATA%/.homeassistant 添加配置信息： xiaomi_aqara : discovery_retry : 5 gateways : - key : 60n163sp2rduqx4ri","text_tokens":["-","里","homeassistant",":","~","discovery","yaml","信息","configuration","。","：","gateways","，","%","（","aqara","灯"," ","文件","添加","home","/","windows","将","_","macos","路径","xiaomi","到","yeelight","所在","retry",".","彩光","assistant","配置","linux","appdata%","配置文件","5","60n163sp2rduqx4ri","key","）"],"title":"步骤 3：添加配置信息","title_tokens":["3","步骤","配置"," ","信息","：","添加"]},{"location":"Neverland/HA/#4-home-assistant","text":"重启之后，你应该可以使用 Home Assistant 控制 米家智能家庭套装 里的设备了！","text_tokens":["的","套装","可以","里","你","智能","家庭","使用","，","之后"," ","重启","米家","home","设备","应该","！","assistant","了","控制"],"title":"步骤 4：重启 Home Assistant","title_tokens":["步骤","home","assistant"," ","4","重启","："]},{"location":"Neverland/HA/#codelab-scratch-home-assistant","text":"为了方便用户使用 Scratch 驱动家居设备，我们需要获取 Home Assistant 的访问 token，将其粘贴到 CodeLab Scratch 里的 Home Assistant 拓展积木里。如此一来我们就可以使用 CodeLab Scratch 来为家庭/教室里的设备编程。打个响指，把灯关掉！","text_tokens":["的","用户","可以","里","为了","方便","如此","。","其","一来","如此一来","家庭","关掉","我们","就","使用","，","积木","token","获取","打个","灯"," ","家居","编程","home","/","设备","将","来","响指","把","！","到","需要","scratch","驱动","拓展","教室","为","codelab","assistant","访问","粘贴"],"title":"使用 CodeLab Scratch 连接 Home Assistant","title_tokens":["codelab","使用","home","assistant"," ","连接","scratch"]},{"location":"Neverland/HA/#home-assistant-token","text":"如图依次按顺序（1、2、3）操作： 由于 token 只出现一次，所以你最好先复制粘贴到记事本里。","text_tokens":["所以","里","你","。","：","一次","记事","3","1","操作","出现","复制","，","token","（"," ","由于","先","顺序","粘贴","复制粘贴","按","依次","记事本","到","如图","、","最好","2","只","）"],"title":"获取 Home Assistant 访问 token","title_tokens":["home","assistant","访问","token","获取"," "]},{"location":"Neverland/HA/#codelab-scratch","text":"你既可以使用 CodeLab Scratch 在线版 ，也可以使用 离线版 来进行编程。 在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。 如果你使用离线版，则下载 源码文件 ，使用 Scratch 加载它即可。 加载后填入你之前记下的 token。 提醒 如果你的 Home Assistant 访问地址不是 http://127.0.0.1:8123 (诸如运行在树莓派上)，你就无法在 在线版 中连接它( 浏览器安全策略 )。有两种解决方案: 1. 使用离线版 2. 将 Home Assistant 的访问地址 http://127.0.0.1:8123 映射到 https 上，可以采用以下任何一种方案: * ngrok ：下载并运行 ngrok http 8123 ，你将 Home Assistant 的访问地址暴露到了 https 公网, 形如: https://ff4b68f8.ngrok.io . * 其他办法 提醒 如果想接入 zigbee 设备，请使用 zigbee2mqtt ，目前已支持 以下设备","text_tokens":[",","的","(","可以","上","映射","你","如果","1","就","浏览器","离线","设备","zigbee","ngrok","后","scratch",".","codelab","了","要","点击","接入","打开方式","即可","记下",":","版","在","https","两种","不是","下载","token","一种","派","链接","文件","诸如","0.1","既",")","home","/","任何","将","来","中","想","形","解决","assistant","2","支持","提醒","如","*","方式","8123","方案","并","暴露","浏览","公网","。","：","打开","无法","也","树莓","，","连接","开方","直接","加载","办法","运行","以下","请","有","访问","其他","127.0","已","在线","则","项目","进行","ff4b68f8","zigbee2mqtt","io","之前","使用","解决方案","采用"," ","它","编程","http","安全","与","是","源码","到","安全策略","地址","目前","策略","填入"],"title":"使用 CodeLab Scratch 为家庭设备编程！","title_tokens":["为","codelab","使用","设备","家庭设备"," ","！","家庭","scratch","编程"]},{"location":"Neverland/HA/#_5","text":"除了可以使用 CodeLab Scratch 连接 Home Assistant，我们还可以使用 CodeLab Adapter 连接 Home Assistant，这对我们在创客/IoT 实验室里展开教学，以及进行多语言教学（34+ 编程语言）都很有用。 这部分的文档我们将在未来同步过来。","text_tokens":["这部","的","展开","可以","里","在","教学","创客","未来","。","部分","文档","同步","除了","还","我们","实验","使用","，","实验室","语言","编程语言","（","有用"," ","连接","编程","home","/","iot","将","这","多","过来","都","scratch","这部分","对","很","codelab","assistant","adapter","以及","+","34","进行","）"],"title":"拓展","title_tokens":["拓展"]},{"location":"Neverland/HA/#_6","text":"Installation in Python virtual environment Install Home Assistant","text_tokens":["home","environment","assistant","installation","in","python"," ","virtual","install"],"title":"参考","title_tokens":["参考"]},{"location":"Neverland/finger-snapping/","text":"收工，吃饭 ¶ Scratch 、 Home Assistant 、 智能家居（smart home） 、 声音检测（Sound） 步骤 1：构建 ¶ 是什么? ¶ 打一个响指，关掉整个办公室的灯，下班回家吃饭！ 它是如何工作的? ¶ 运行 Home Assistant ，接管空间的所有智能设备。 使用 CodeLab Scratch（ 在线版 、 离线版 皆可）的 Home Assistant 扩展，控制智能设备。 使用 Scratch 中的 声音响度积木 监测环境中的声音，当声音响度超过某个值，关灯！ 你需要准备些什么 ¶ 安装和配置 Home Assistant CodeLab Scratch 智能家居设备（以下是 CodeLab 的推荐清单，任选一项即可） 米家智能家庭套装（ 购买链接 ） Yeelight 彩光灯（ 购买链接 ） 如果你是 Home Assistant 用户，则可以任意使用 任何社区接入的套件 步骤 2：编程 ¶ 在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。 如果你使用离线版，则下载 源码文件 ，使用 Scratch 加载它即可. 加载后填入你之前记下的 token。 步骤 3：发挥想象 ¶ 现在你可以使用 CodeLab Scratch 的 Home Assistant 插件自由的编程啦，试着与 Scratch 里其他有趣的积木互动吧。 如果你想让程序只对响指声作出反应，甚至只对你的响指声作出反应都是可能的，使用 AI 来做到这点！ CodeLab Adapter 已经将 Teachable Machine 接入进来了 ，你可以使用声音、肢体、各种物体与你的房间进行互动！","text_tokens":["的","步骤","扩展","用户","安装","一个","可以","你","作出","下班","家庭","如果","1","现在","响度","打","（","想象","家居","任选","接管","离线","社区","设备","进来","反应","什么","声","后","甚至","scratch","需要",".","codelab","购买","adapter","了","machine","要","所有","接入","点击","物体","打开方式","已经","即可","值","让","办公","可能","记下","版","ai","关掉","一项","各种","下载","token","灯","发挥","链接","文件","超过","和","任意","米家","home","任何","将","来","中","检测","吧","想","某个","对","彩光","、","声音","assistant","配置","整个","2","?","只","当","些","啦","工作","套装","方式","试着","smart","如何","。","：","肢体","打开","3","推荐","，","收工","构建","开方","直接","可","自由","关灯","加载","这点","运行","皆","以下","！","yeelight","回家","¶","其他","在线","则","项目","进行","）","空间","作出反应","里","程序","智能","互动","之前","插件","teachable","使用","积木","准备"," ","它","编程","与","响指","做到","都","是","公室","环境","清单","源码","房间","有趣","监测","sound","智能家居","吃饭","套件","办公室","控制","填入"],"title":"收工吃饭","title_tokens":["吃饭","收工"]},{"location":"Neverland/finger-snapping/#_1","text":"Scratch 、 Home Assistant 、 智能家居（smart home） 、 声音检测（Sound）","text_tokens":["home","、","assistant","声音","smart","（","sound","智能家居"," ","家居","智能","检测","）","scratch"],"title":"收工，吃饭","title_tokens":["吃饭","收工","，"]},{"location":"Neverland/finger-snapping/#1","text":"","text_tokens":[],"title":"步骤 1：构建","title_tokens":["1","步骤"," ","构建","："]},{"location":"Neverland/finger-snapping/#_2","text":"打一个响指，关掉整个办公室的灯，下班回家吃饭！","text_tokens":["的","，","打","整个","一个","办公","响指","灯","吃饭","！","关掉","下班","办公室","公室","回家"],"title":"是什么?","title_tokens":["是","什么","?"]},{"location":"Neverland/finger-snapping/#_3","text":"运行 Home Assistant ，接管空间的所有智能设备。 使用 CodeLab Scratch（ 在线版 、 离线版 皆可）的 Home Assistant 扩展，控制智能设备。 使用 Scratch 中的 声音响度积木 监测环境中的声音，当声音响度超过某个值，关灯！","text_tokens":["值","的","扩展","版","控制","智能","。","使用","，","响度","积木","（"," ","超过","接管","可","home","离线","关灯","设备","运行","皆","中","！","scratch","环境","某个","codelab","、","assistant","声音","监测","在线","当","所有","）","空间"],"title":"它是如何工作的?","title_tokens":["的","是","?","如何","它","工作"]},{"location":"Neverland/finger-snapping/#_4","text":"安装和配置 Home Assistant CodeLab Scratch 智能家居设备（以下是 CodeLab 的推荐清单，任选一项即可） 米家智能家庭套装（ 购买链接 ） Yeelight 彩光灯（ 购买链接 ） 如果你是 Home Assistant 用户，则可以任意使用 任何社区接入的套件","text_tokens":["即可","的","套装","用户","安装","可以","你","智能","家庭","如果","一项","推荐","使用","，","（","灯"," ","家居","链接","任选","和","任意","米家","home","社区","任何","设备","以下","是","清单","scratch","yeelight","彩光","codelab","assistant","配置","购买","智能家居","则","套件","接入","）"],"title":"你需要准备些什么","title_tokens":["准备","你","什么","些","需要"]},{"location":"Neverland/finger-snapping/#2","text":"在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。 如果你使用离线版，则下载 源码文件 ，使用 Scratch 加载它即可. 加载后填入你之前记下的 token。","text_tokens":["即可","的","方式","记下","版","你","。","之前","如果","打开","使用","，","下载","token"," ","链接","文件","它","直接","开方","离线","加载","与","后","是","源码","scratch",".","在线","则","要","项目","点击","打开方式","填入"],"title":"步骤 2：编程","title_tokens":["步骤","2"," ","：","编程"]},{"location":"Neverland/finger-snapping/#3","text":"现在你可以使用 CodeLab Scratch 的 Home Assistant 插件自由的编程啦，试着与 Scratch 里其他有趣的积木互动吧。 如果你想让程序只对响指声作出反应，甚至只对你的响指声作出反应都是可能的，使用 AI 来做到这点！ CodeLab Adapter 已经将 Teachable Machine 接入进来了 ，你可以使用声音、肢体、各种物体与你的房间进行互动！","text_tokens":["让","的","作出反应","试着","可以","可能","里","程序","ai","进行","你","作出","互动","。","肢体","如果","现在","插件","teachable","使用","，","积木","各种"," ","编程","home","自由","将","与","来","响指","做到","这点","反应","进来","都","声","！","吧","想","甚至","scratch","是","对","房间","codelab","有趣","assistant","声音","adapter","了","、","其他","只","machine","啦","接入","物体","已经"],"title":"步骤 3：发挥想象","title_tokens":["3","步骤","想象","发挥"," ","："]},{"location":"Neverland/frp/","text":"frp免费服务 ¶ chuantou.org 可以使用ngrok","text_tokens":[".","免费","使用","org","¶","可以","chuantou","服务","frp"," ","ngrok"],"title":"frp免费服务","title_tokens":["免费","frp","服务"]},{"location":"Neverland/frp/#frp","text":"chuantou.org 可以使用ngrok","text_tokens":[".","使用","org","可以","chuantou"," ","ngrok"],"title":"frp免费服务","title_tokens":["免费","frp","服务"]},{"location":"Neverland/musical-instrument-tm/","text":"乐器演奏（Teachable Machine） ¶ AI 、 Teachable Machine 、 CodeLab Adapter 、 Scratch 步骤 1：构建 ¶ 是什么? ¶ Tips 国内用户可能需要科学上网，才能访问 Teachable Machine :) 记得避免全局翻墙，否则浏览器可能无法连接到 CodeLab Adapter （我们所面临的困难许多时候是人为的） 使用 Teachable Machine 训练一个 AI 助手，教会它认识不同的乐器卡片（可任选），当看到吉他 （guitar）卡片时，在桌子上播放吉他动画，并使用吉他演奏一段音乐；当看到萨克斯（sax）卡片时，在桌子上播放萨克斯动画，并使用萨克斯演奏一段音乐， 利用投影让虚拟形象和实物在一张桌子上互动！ 它是如何工作的? ¶ 使用 Teachable Machine 中的 Image Project ，训练 AI 来识别看书与合上书的不同状态。 使用 CodeLab Adapter 将 Teachable Machine 的识别结果接入到 CodeLab Scratch 中 使用 CodeLab Scratch（ 在线版 、 离线版 皆可）进行编程，让卡通形象、音乐与实物互动。 你需要准备些什么 ¶ CodeLab Scratch CodeLab Adapter 安装 Chrome 浏览器插件： Tampermonkey 点击安装 Tampermonkey 脚本 Teachablemachine_Result.user.js ，使用它来获取 Teachable Machine 的识别结果 投影仪（我使用的是 LG PH450UG-GL 超短焦投影仪 ） 投影仪是可选的，你也可以让动画显示在电脑屏幕上，而不是投影到桌面。记得在屏幕上将舞台最大化，效果比较好。 步骤 2：编程 ¶ 准备工作 ¶ 安装完 Tampermonkey Chrome 浏览器插件和 Teachablemachine_Result.user.js 脚本后，运行下载到本地的 CodeLab Adapter 。 打开 Image Project ，页面应该会弹出提示： connected! ，表示已经将 Teachable Machine 接入 CodeLab Adapter。 接下来，可以开始你的 Teachable Machine 之旅途。我们来展示一个例子。 训练模型 ¶ 在 Teachable Machine 训练你的 AI 助手，你需要教会它识别不同卡片，如果你对 Teachable Machine 不了解，参考我们的介绍文章 CodeLab Adapter 接入 Teachable Machine 。 建立 3 个分类，分别是 guitar 、 sax 、 none （空桌面） 开始添加你的训练样本，完成训练后在页面右边测试它。 如果不满意，可以添加调整样本数据，重新训练，并再次测试它，直到满意为止。 开始在 CodeLab Scratch 中编程 ¶ 在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。未来我们会直接发布到社区里。 如果你使用离线版，则下载 源码文件 ，使用 CodeLab Scratch 加载它即可。 点击绿旗开始运行程序，将 Scratch 舞台区最大化。 如果你使用投影仪，在黑暗中效果比较好。 黑暗中如何看得见乐器卡片呢？将乐器卡片放在舞台去右上角，参考演示视频里的做法。 步骤 3：发挥想象 ¶ 这儿的核心想法是，使用摄像头捕获到舞台卡片/物体，接着使用 Teachable Machine 训练好的模型来识别它，最后通过编程让 Scratch 中的虚拟角色与识别出的物体互动！在这个想法下，可以玩的东西非常多。 你可以训练你的 AI 助手识别任何你喜欢的玩具，然后与之互动。 诸如拿出一只老虎玩偶放在舞台中，它的朋友会作何反应呢？它的敌人会如何反应呢？舞台里的一只虚拟小猫可能叫了一声，一下子就蹿远了。 构建你自己的故事吧，让真实世界和虚拟世界互动起来。 你也可以通过接入 Home Assistant ， 将整个家庭纳入到故事创作中，老虎出现时，随着一声虎啸，房间里的灯突然熄灭，预知后续如何？我们等待你的家庭剧本！ 参考 ¶ CodeLab Adapter 接入 Teachable Machine 插件（extensions）文档 - Teachable Machine","text_tokens":["的","绿旗","一个","看到","上","家庭","1","叫","右边","数据","这儿","一下子","什么","scratch","需要","js","敌人","接着","随着","已经","即可","让","-","在","版","上将","世界","添加","看书","任何","等待","模型","对","再次","剧本","分别","2","记得","当","助手","工作","!","方式","并","页面","翻墙","不同","构建","脚本","直接","加载","玩具","！","桌面","¶","访问","而","connected","出现","插件"," ","电脑屏幕","科学","lg","到","突然","房间","角色","全局","image","所","提示","吉他","利用","获取","想象","none","区","浏览器","拿出","下来",".","教会","要","右上角","点击","物体","打开方式","teachablemachine","可能","未来","萨克","下载","效果",")","作何","核心","来","吧","玩偶","演示","、","assistant","些","出","最后","老虎","表示","调整","好","形象","。","东西","打开","3","玩","摄像头","文章","超短","project","状态","开始","extensions","皆","看得","tampermonkey","最大化","比较","训练","国内","项目","）","电脑","程序","识别","互动","看得见","创作","可选","sax","个","与","result","远","朋友","困难","想法","步骤","用户","可以","大化","呢","黑暗","音乐","我","如果","一张","焦","反应","应该","右上","合","故事","测试","否则","虚拟","介绍","machine","下","接入",":","开始运行","不是","参考","文件","诸如","和","/","将","蹿","_","投影仪","中","上角","通过","上书","chrome","整个","?","guitar","演奏","建立","展示","之","例子","文档","：","放在","？","运行","避免","才能","在线","进行","里","直到","真实世界","虚拟世界","视频","为止","编程","萨克斯","后续","这个","gl","源码","旅途","重新","了解","空","时","安装","你","接下来","我们","就","分类","（","一段","任选","像头","离线","社区","；","人为","后","去","codelab","卡通","adapter","了","预知","会","本地","ai","时候","捕获","非常","虎啸","一下","实物","发挥","灯","链接","摄像","真实","舞台","home","自己","熄灭","播放","ph450ug","桌子","然后","许多","浏览","如何","认识","投影","上网","满意","无法","动画","也","，","完成","连接","接下","开方","可","起来","会弹","训练样本","做法","多","一声","下子","卡片","一只","则","乐器","结果","喜欢","teachable","使用","最大","准备","样本","它","显示","屏幕","tips","不","user","纳入","是","小猫","面临","完","克斯","发布"],"title":"乐器演奏 (Teachable Machine)","title_tokens":["teachable","(","乐器"," ","演奏","machine",")"]},{"location":"Neverland/musical-instrument-tm/#teachable-machine","text":"AI 、 Teachable Machine 、 CodeLab Adapter 、 Scratch","text_tokens":["teachable","、","codelab","adapter","ai"," ","machine","scratch"],"title":"乐器演奏（Teachable Machine）","title_tokens":["teachable","乐器","（"," ","演奏","machine","）"]},{"location":"Neverland/musical-instrument-tm/#1","text":"","text_tokens":[],"title":"步骤 1：构建","title_tokens":["1","步骤"," ","构建","："]},{"location":"Neverland/musical-instrument-tm/#_1","text":"Tips 国内用户可能需要科学上网，才能访问 Teachable Machine :) 记得避免全局翻墙，否则浏览器可能无法连接到 CodeLab Adapter （我们所面临的困难许多时候是人为的） 使用 Teachable Machine 训练一个 AI 助手，教会它认识不同的乐器卡片（可任选），当看到吉他 （guitar）卡片时，在桌子上播放吉他动画，并使用吉他演奏一段音乐；当看到萨克斯（sax）卡片时，在桌子上播放萨克斯动画，并使用萨克斯演奏一段音乐， 利用投影让虚拟形象和实物在一张桌子上互动！","text_tokens":["的","时","用户","所","一个","看到","上","吉他","音乐","我们","利用","一张","（","一段","任选","浏览器","；","人为","需要","否则","codelab","虚拟","adapter","教会","machine","让","可能",":","在","ai","时候","萨克","实物","和",")","播放","桌子","guitar","记得","演奏","当","助手","许多","并","浏览","认识","投影","上网","形象","无法","动画","，","翻墙","不同","连接","可","！","避免","才能","访问","卡片","训练","国内","）","乐器","互动","teachable","使用"," ","它","sax","萨克斯","tips","科学","到","是","面临","全局","困难","克斯"],"title":"是什么?","title_tokens":["是","什么","?"]},{"location":"Neverland/musical-instrument-tm/#_2","text":"使用 Teachable Machine 中的 Image Project ，训练 AI 来识别看书与合上书的不同状态。 使用 CodeLab Adapter 将 Teachable Machine 的识别结果接入到 CodeLab Scratch 中 使用 CodeLab Scratch（ 在线版 、 离线版 皆可）进行编程，让卡通形象、音乐与实物互动。","text_tokens":["让","的","结果","ai","识别","版","进行","形象","。","互动","音乐","teachable","使用","，","（","project","实物"," ","不同","状态","可","编程","看书","离线","将","来","与","皆","中","到","scratch","合","上书","codelab","、","卡通","adapter","训练","image","在线","machine","接入","）"],"title":"它是如何工作的?","title_tokens":["的","是","?","如何","它","工作"]},{"location":"Neverland/musical-instrument-tm/#_3","text":"CodeLab Scratch CodeLab Adapter 安装 Chrome 浏览器插件： Tampermonkey 点击安装 Tampermonkey 脚本 Teachablemachine_Result.user.js ，使用它来获取 Teachable Machine 的识别结果 投影仪（我使用的是 LG PH450UG-GL 超短焦投影仪 ） 投影仪是可选的，你也可以让动画显示在电脑屏幕上，而不是投影到桌面。记得在屏幕上将舞台最大化，效果比较好。","text_tokens":["让","的","-","大化","安装","可以","浏览","结果","在","识别","上","你","好","投影","。","：","上将","我","动画","插件","teachable","使用","，","也","不是","（","获取","最大","超短"," ","脚本","效果","它","可选","舞台","显示","浏览器","屏幕","电脑屏幕","焦","来","_","投影仪","gl","lg","user","是","scratch","到","js","桌面","result",".","ph450ug","chrome","codelab","tampermonkey","最大化","adapter","比较","而","记得","machine","点击","）","电脑","teachablemachine"],"title":"你需要准备些什么","title_tokens":["准备","你","什么","些","需要"]},{"location":"Neverland/musical-instrument-tm/#2","text":"","text_tokens":[],"title":"步骤 2：编程","title_tokens":["步骤","2"," ","：","编程"]},{"location":"Neverland/musical-instrument-tm/#_4","text":"安装完 Tampermonkey Chrome 浏览器插件和 Teachablemachine_Result.user.js 脚本后，运行下载到本地的 CodeLab Adapter 。 打开 Image Project ，页面应该会弹出提示： connected! ，表示已经将 Teachable Machine 接入 CodeLab Adapter。 接下来，可以开始你的 Teachable Machine 之旅途。我们来展示一个例子。","text_tokens":["!","展示","的","本地","之","表示","安装","可以","一个","浏览","提示","你","例子","。","：","connected","接下来","打开","插件","teachable","下载","，","页面","我们","已经","project"," ","接下","脚本","和","开始","浏览器","会弹","将","来","运行","_","应该","下来","后","user","到","js","result",".","旅途","chrome","tampermonkey","codelab","adapter","完","image","machine","接入","出","teachablemachine"],"title":"准备工作","title_tokens":["准备","工作"]},{"location":"Neverland/musical-instrument-tm/#_5","text":"在 Teachable Machine 训练你的 AI 助手，你需要教会它识别不同卡片，如果你对 Teachable Machine 不了解，参考我们的介绍文章 CodeLab Adapter 接入 Teachable Machine 。 建立 3 个分类，分别是 guitar 、 sax 、 none （空桌面） 开始添加你的训练样本，完成训练后在页面右边测试它。 如果不满意，可以添加调整样本数据，重新训练，并再次测试它，直到满意为止。","text_tokens":["的","空","可以","并","在","调整","ai","识别","你","。","如果","直到","3","满意","teachable","我们","，","分类","页面","右边","（","文章","完成","样本","参考","数据"," ","不同","它","none","个","sax","添加","开始","为止","训练样本","接入","不","后","是","需要","对","桌面","测试","再次","codelab","、","分别","介绍","adapter","卡片","重新","训练","guitar","了解","教会","machine","助手","）","建立"],"title":"训练模型","title_tokens":["模型","训练"]},{"location":"Neverland/musical-instrument-tm/#codelab-scratch","text":"在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。未来我们会直接发布到社区里。 如果你使用离线版，则下载 源码文件 ，使用 CodeLab Scratch 加载它即可。 点击绿旗开始运行程序，将 Scratch 舞台区最大化。 如果你使用投影仪，在黑暗中效果比较好。 黑暗中如何看得见乐器卡片呢？将乐器卡片放在舞台去右上角，参考演示视频里的做法。","text_tokens":["即可","绿旗","的","方式","大化","乐器","里","在","版","程序","如何","你","呢","未来","黑暗","好","投影","。","看得见","如果","打开","开始运行","我们","使用","，","下载","最大","右上角","参考"," ","链接","文件","效果","它","直接","开方","舞台","放在","开始","区","视频","做法","离线","社区","加载","将","与","？","运行","投影仪","中","右上","是","到","源码","scratch","看得","上角","去","演示","codelab","最大化","比较","卡片","在线","则","要","发布","会","项目","点击","打开方式"],"title":"开始在 CodeLab Scratch 中编程","title_tokens":["开始","codelab","在"," ","中","scratch","编程"]},{"location":"Neverland/musical-instrument-tm/#3","text":"这儿的核心想法是，使用摄像头捕获到舞台卡片/物体，接着使用 Teachable Machine 训练好的模型来识别它，最后通过编程让 Scratch 中的虚拟角色与识别出的物体互动！在这个想法下，可以玩的东西非常多。 你可以训练你的 AI 助手识别任何你喜欢的玩具，然后与之互动。 诸如拿出一只老虎玩偶放在舞台中，它的朋友会作何反应呢？它的敌人会如何反应呢？舞台里的一只虚拟小猫可能叫了一声，一下子就蹿远了。 构建你自己的故事吧，让真实世界和虚拟世界互动起来。 你也可以通过接入 Home Assistant ， 将整个家庭纳入到故事创作中，老虎出现时，随着一声虎啸，房间里的灯突然熄灭，预知后续如何？我们等待你的家庭剧本！","text_tokens":["的","时","可以","你","呢","家庭","叫","就","我们","这儿","像头","拿出","反应","一下子","scratch","故事","虚拟","了","敌人","machine","预知","下","会","接着","接入","随着","物体","让","可能","在","ai","捕获","非常","虎啸","一下","灯","摄像","诸如","世界","和","真实","作何","舞台","核心","home","/","任何","将","来","自己","等待","蹿","模型","中","吧","熄灭","通过","玩偶","剧本","assistant","整个","然后","助手","出","最后","老虎","之","如何","好","。","东西","玩","也","，","摄像头","构建","放在","起来","？","多","玩具","一声","！","下子","卡片","一只","训练","里","识别","互动","喜欢","出现","teachable","使用","真实世界","虚拟世界","创作"," ","它","编程","与","后续","这个","纳入","到","是","突然","房间","角色","远","小猫","朋友","想法"],"title":"步骤 3：发挥想象","title_tokens":["3","步骤","想象","发挥"," ","："]},{"location":"Neverland/musical-instrument-tm/#_6","text":"CodeLab Adapter 接入 Teachable Machine 插件（extensions）文档 - Teachable Machine","text_tokens":["teachable","codelab","插件","extensions","-","adapter","（"," ","machine","文档","接入","）"],"title":"参考","title_tokens":["参考"]},{"location":"Neverland/reading-thinking/","text":"读书与思考 ¶ AI 、 Scratch 、 Home Assistant 、 智能家居（smart home） 、 Teachable Machine 步骤 1：构建 ¶ 是什么? ¶ 训练一个 AI 助手，当你在阅读时，自动帮你打开书房的灯；当你合上书开始思考，自动关闭书房的灯，让你沉浸在黑暗里。 它是如何工作的? ¶ 运行 Home Assistant ，接管空间的所有智能设备。 使用 CodeLab Scratch（ 在线版 、 离线版 皆可）的 Home Assistant 扩展，控制智能设备。 使用 Scratch 中的 图片分类积木 ，训练 AI 来识别看书与合上书的不同状态。 你需要准备些什么 ¶ 安装和配置 Home Assistant CodeLab Scratch 智能家居设备（以下是 CodeLab 的推荐清单，任选一项即可） 米家智能家庭套装（ 购买链接 ） Yeelight 彩光灯（ 购买链接 ） 如果你是 Home Assistant 用户，则可以任意使用 任何社区接入的套件 步骤 2：编程 ¶ 在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。未来我们会直接发布到社区里。 如果你使用离线版，则下载 源码文件 ，使用 Scratch 加载它即可. 加载后填入你之前记下的 token。 在 home button 角色里设置你的 Home Assistant 访问 token； 点击绿旗开始运行程序； 按下 r 按键，添加 看书 样本。舞台区，你应该看到正在看书的摄像头画面； 按下 t 按键，添加 思考 样本。舞台区，你应该看到正在思考（合上书）的摄像头画面； 按下 n 按键，添加 无 样本，此时你既没在看书，也没在思考，桌子上空空如也； 按下 空格 ，开始识别你的桌面状态； 按下 q 案件，暂时结束识别。 提醒 如果关灯后你的房间完全处于黑暗，那么当你再次翻开书，摄像头将看不到你的这个行为！一般来说只有一些光线，它就能看到。如果你的房间遮光效果真的很好，可以考虑使用红外夜视摄像头。 如果它识别地并不准确，观察是否是光线造成的。重复训练，知道你对这个 AI 感到满意。 当然你也可以使用 Teachable Machine 来制作这个项目，它更加直观！ CodeLab Adapter 已经将 Teachable Machine 接入进来了 ！ 步骤 3：发挥想象 ¶ 这儿的核心想法是，使用摄像头捕获到外部世界的状态（翻开书/合上书），接着使用这些数据训练一个 AI 助手，让它对外部世界状态变化作出反馈！在这个想法下，能做的事情可太多啦。 如果你跟我一样是个懒人，则可以训练一个 AI 助手放在厨房，当摄像头识别到我早上第一次穿着睡衣出现在厨房里时，则自动启动整个早餐程序，由于 Home Assistant 已经把你的整个家庭设备加入进来，所以你可以做的事情非常丰富，把你的生活习惯交给自己训练的 AI 来打理，随着你的训练，它会越来越聪明，只有你最清楚自己的习惯，你或许不想由别人的云大脑来监视和服务你，毕竟你可能正光着膀子。 如果你家里有小孩，则可以将摄像头厨房里，让某些危险设备不对孩子的操作做反应，诸如当小孩按下烧水壶时，AI 助手可以告诉 Home Assistant 切断电源。","text_tokens":["的","绿旗","步骤","扩展","时","用户","安装","一个","可以","所以","事情","看到","上","你","行为","黑暗","作出","家庭","如果","我","随着","1","清楚","我们","就","分类","观察","（","地","想象","数据","最","家居","做","任选","接管","跟","区","直观","像头","这儿","离线","社区","设备","进来","；","反应","应该","什么","书房","早上","按下","后","制作","这些","scratch","合","需要","看不到","t",".","懒人","启动","越来","codelab","购买","adapter","了","一样","它会","翻开","设置","machine","自动","要","所有","会","接着","接入","点击","反馈","下","打开方式","已经","即可","让","暂时","毕竟","可能","记下","在","版","ai","重复","未来","不到","第一次","捕获","开始运行","非常","一项","太多","下载","处于","危险","token","不想","灯","发挥","第一","链接","文件","摄像","q","世界","和","任意","既","效果","米家","舞台","添加","遮光","是否是","某些","看书","home","核心","/","任何","此时","将","来","自己","小孩","造成","中","空格","对","考虑","再次","上书","案件","彩光","、","assistant","配置","桌子","当然","2","对外","整个","?","早餐","云","n","提醒","当","些","诸如","家庭设备","啦","助手","来说","工作","是否","套装","方式","知道","画面","smart","并","外部","如何","越来越","读书","好","着","。","：","水壶","打开","3","满意","电源","也","推荐","，","button","空空","摄像头","更加","由","聪明","不同","阅读","构建","状态","变化","放在","开方","直接","可","正光","开始","交给","孩子","关灯","加载","膀子","运行","皆","没","以下","只有","服务","！","把","别人","yeelight","大脑","对外部","习惯","有","桌面","很","睡衣","¶","访问","监视","训练","在线","穿着","则","告诉","一般来说","项目","）","光线","空间","按键","那么","正在","沉浸","加入","厨房","里","一般","程序","切断","识别","感到","智能","关闭","无","一次","之前","打理","出现","操作","teachable","使用","生活","积木","准备","帮","准确","样本"," ","生活习惯","由于","红外","或许","它","个","思考","编程","能","结束","与","可太多","这个","烧","翻开书","不","一些","丰富","家里","是","清单","到","源码","房间","角色","完全","真的","空空如也","r","智能家居","套件","图片","夜视","想法","控制","发布","填入"],"title":"读书与思考","title_tokens":["与","读书","思考"]},{"location":"Neverland/reading-thinking/#_1","text":"AI 、 Scratch 、 Home Assistant 、 智能家居（smart home） 、 Teachable Machine","text_tokens":["teachable","home","、","assistant","smart","（","ai","智能家居"," ","家居","智能","machine","）","scratch"],"title":"读书与思考","title_tokens":["与","读书","思考"]},{"location":"Neverland/reading-thinking/#1","text":"","text_tokens":[],"title":"步骤 1：构建","title_tokens":["1","步骤"," ","构建","："]},{"location":"Neverland/reading-thinking/#_2","text":"训练一个 AI 助手，当你在阅读时，自动帮你打开书房的灯；当你合上书开始思考，自动关闭书房的灯，让你沉浸在黑暗里。","text_tokens":["让","的","沉浸","时","一个","里","在","ai","你","黑暗","关闭","。","打开","，","帮","灯"," ","阅读","思考","开始","；","书房","合","上书","训练","自动","当","助手"],"title":"是什么?","title_tokens":["是","什么","?"]},{"location":"Neverland/reading-thinking/#_3","text":"运行 Home Assistant ，接管空间的所有智能设备。 使用 CodeLab Scratch（ 在线版 、 离线版 皆可）的 Home Assistant 扩展，控制智能设备。 使用 Scratch 中的 图片分类积木 ，训练 AI 来识别看书与合上书的不同状态。","text_tokens":["的","扩展","版","ai","识别","控制","智能","。","使用","，","分类","积木","（"," ","不同","状态","接管","可","看书","home","离线","设备","来","与","运行","皆","中","scratch","合","上书","codelab","、","assistant","训练","在线","所有","图片","）","空间"],"title":"它是如何工作的?","title_tokens":["的","是","?","如何","它","工作"]},{"location":"Neverland/reading-thinking/#_4","text":"安装和配置 Home Assistant CodeLab Scratch 智能家居设备（以下是 CodeLab 的推荐清单，任选一项即可） 米家智能家庭套装（ 购买链接 ） Yeelight 彩光灯（ 购买链接 ） 如果你是 Home Assistant 用户，则可以任意使用 任何社区接入的套件","text_tokens":["即可","的","套装","用户","安装","可以","你","智能","家庭","如果","一项","推荐","使用","，","（","灯"," ","家居","链接","任选","和","任意","米家","home","社区","任何","设备","以下","是","清单","scratch","yeelight","彩光","codelab","assistant","配置","购买","智能家居","则","套件","接入","）"],"title":"你需要准备些什么","title_tokens":["准备","你","什么","些","需要"]},{"location":"Neverland/reading-thinking/#2","text":"在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。未来我们会直接发布到社区里。 如果你使用离线版，则下载 源码文件 ，使用 Scratch 加载它即可. 加载后填入你之前记下的 token。 在 home button 角色里设置你的 Home Assistant 访问 token； 点击绿旗开始运行程序； 按下 r 按键，添加 看书 样本。舞台区，你应该看到正在看书的摄像头画面； 按下 t 按键，添加 思考 样本。舞台区，你应该看到正在思考（合上书）的摄像头画面； 按下 n 按键，添加 无 样本，此时你既没在看书，也没在思考，桌子上空空如也； 按下 空格 ，开始识别你的桌面状态； 按下 q 案件，暂时结束识别。 提醒 如果关灯后你的房间完全处于黑暗，那么当你再次翻开书，摄像头将看不到你的这个行为！一般来说只有一些光线，它就能看到。如果你的房间遮光效果真的很好，可以考虑使用红外夜视摄像头。 如果它识别地并不准确，观察是否是光线造成的。重复训练，知道你对这个 AI 感到满意。 当然你也可以使用 Teachable Machine 来制作这个项目，它更加直观！ CodeLab Adapter 已经将 Teachable Machine 接入进来了 ！","text_tokens":["的","绿旗","可以","看到","上","你","行为","黑暗","如果","我们","就","观察","（","地","区","直观","像头","离线","社区","进来","；","应该","按下","后","制作","scratch","合","看不到","t",".","codelab","adapter","了","翻开","设置","machine","要","会","点击","接入","打开方式","已经","即可","暂时","记下","在","版","ai","重复","未来","不到","开始运行","下载","处于","token","链接","文件","摄像","q","效果","既","舞台","添加","遮光","是否是","看书","home","此时","将","来","造成","空格","对","考虑","再次","上书","案件","assistant","当然","桌子","n","提醒","当","来说","是否","方式","知道","画面","并","好","。","打开","满意","也","，","button","空空","摄像头","更加","状态","直接","开方","开始","关灯","加载","运行","没","只有","！","桌面","很","访问","训练","在线","则","一般来说","项目","）","光线","按键","那么","正在","里","一般","程序","识别","感到","无","之前","teachable","使用","准确","样本"," ","红外","它","思考","能","结束","与","这个","翻开书","不","一些","是","到","源码","房间","角色","完全","真的","空空如也","r","夜视","发布","填入"],"title":"步骤 2：编程","title_tokens":["步骤","2"," ","：","编程"]},{"location":"Neverland/reading-thinking/#3","text":"这儿的核心想法是，使用摄像头捕获到外部世界的状态（翻开书/合上书），接着使用这些数据训练一个 AI 助手，让它对外部世界状态变化作出反馈！在这个想法下，能做的事情可太多啦。 如果你跟我一样是个懒人，则可以训练一个 AI 助手放在厨房，当摄像头识别到我早上第一次穿着睡衣出现在厨房里时，则自动启动整个早餐程序，由于 Home Assistant 已经把你的整个家庭设备加入进来，所以你可以做的事情非常丰富，把你的生活习惯交给自己训练的 AI 来打理，随着你的训练，它会越来越聪明，只有你最清楚自己的习惯，你或许不想由别人的云大脑来监视和服务你，毕竟你可能正光着膀子。 如果你家里有小孩，则可以将摄像头厨房里，让某些危险设备不对孩子的操作做反应，诸如当小孩按下烧水壶时，AI 助手可以告诉 Home Assistant 切断电源。","text_tokens":["的","时","可以","一个","所以","事情","你","作出","家庭","如果","我","清楚","（","数据","最","做","跟","这儿","像头","设备","进来","反应","早上","按下","这些","懒人","越来","合","启动","一样","它会","翻开","自动","下","接着","随着","大脑","反馈","已经","让","毕竟","可能","在","ai","第一次","捕获","非常","太多","危险","不想","第一","摄像","对外","诸如","世界","和","某些","核心","home","/","小孩","自己","来","将","对","上书","assistant","早餐","整个","云","当","家庭设备","啦","助手","外部","越来越","着","。","水壶","电源","，","摄像头","由","聪明","状态","变化","放在","正光","交给","膀子","只有","服务","！","把","别人","对外部","习惯","有","睡衣","监视","训练","穿着","则","告诉","）","加入","厨房","里","切断","程序","识别","一次","打理","出现","操作","使用","生活"," ","生活习惯","由于","或许","它","个","能","可太多","这个","烧","翻开书","不","丰富","家里","到","是","孩子","想法"],"title":"步骤 3：发挥想象","title_tokens":["3","步骤","想象","发挥"," ","："]},{"location":"Neverland/tpl/","text":"读书与思考 ¶ AI 步骤1: 构建 ¶ 是什么? ¶ 训练一个AI助手，当你在阅读时，自动帮你打开书房的灯; 当你合上书开始思考，自动关闭书房的灯，让你沉浸在黑暗里。 它是如何工作的? ¶ 运行Home Assistant ，接管空间的所有智能设备 使用CodeLab Scratch( 在线版 、 离线版 皆可)的Home Assistant扩展，控制智能设备 使用Scratch中的 声音响度积木 监测环境中的声音，当声音响度超过某个值，关灯！ 你需要准备些什么 ¶ 安装和配置Home Assistant CodeLab Scratch 智能家居设备(以下是CodeLab的推荐清单，任选一项即可) 米家智能家庭套装( 购买链接 ) Yeelight彩光灯( 购买链接 ) 如果你是Home Assistant用户，则可以任意使用 任何社区接入的套件 步骤2: 编程 ¶ 在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。未来我们会直接发布到社区里。 如果你使用离线版，则下载 源码文件 ,使用Scratch加载它即可. 加载后填入你之前记下的token。 步骤3: 发挥想象 ¶ 现在你可以使用CodeLab Scratch的Home Assistant插件自由的编程啦，试着与Scratch里其他有趣的积木互动吧。 如果你想让程序只对响指声作出反应，甚至只对你的响指声作出反应都是可能的，使用AI来做到这点！ CodeLab Adapter已经将Teachable Machine接入进来了 ，你可以使用声音、肢体、各种物体与你的房间进行互动！","text_tokens":[",","的","步骤","(","时","扩展","安装","一个","用户","可以","你","黑暗","作出","家庭","如果","1","现在","我们","响度","想象","家居","任选","接管","离线","社区","设备","进来","反应","什么","声","书房","后","甚至","scratch","合","需要",".","codelab","购买","adapter","了","自动","要","machine","所有","会","接入","点击","物体","打开方式","已经","即可","让","值","可能",":","在","版","ai","记下","未来","一项","各种","下载","token","灯","发挥","链接","文件","超过","和",")","任意","米家","home","任何","将","来","中","吧","想","某个","对","上书","彩光","、","声音","assistant","配置","2","?","只","当","些","啦","助手","工作","套装","方式","试着","如何","读书","。","肢体","打开","3",";","推荐","，","阅读","构建","开方","直接","可","开始","自由","关灯","加载","这点","运行","皆","以下","！","yeelight","¶","其他","训练","在线","则","项目","进行","空间","沉浸","作出反应","里","程序","智能","关闭","互动","之前","插件","teachable","使用","积木","准备","帮"," ","它","思考","编程","与","响指","做到","都","是","清单","环境","到","源码","房间","有趣","监测","智能家居","套件","控制","发布","填入"],"title":"读书与思考","title_tokens":["与","读书","思考"]},{"location":"Neverland/tpl/#_1","text":"AI","text_tokens":["ai"],"title":"读书与思考","title_tokens":["与","读书","思考"]},{"location":"Neverland/tpl/#1","text":"","text_tokens":[],"title":"步骤1: 构建","title_tokens":["1","步骤",":"," ","构建"]},{"location":"Neverland/tpl/#_2","text":"训练一个AI助手，当你在阅读时，自动帮你打开书房的灯; 当你合上书开始思考，自动关闭书房的灯，让你沉浸在黑暗里。","text_tokens":["让","的","沉浸","时","一个","里","在","ai","你","黑暗","关闭","。","打开",";","，","帮","灯"," ","阅读","思考","开始","书房","合","上书","训练","自动","当","助手"],"title":"是什么?","title_tokens":["是","什么","?"]},{"location":"Neverland/tpl/#_3","text":"运行Home Assistant ，接管空间的所有智能设备 使用CodeLab Scratch( 在线版 、 离线版 皆可)的Home Assistant扩展，控制智能设备 使用Scratch中的 声音响度积木 监测环境中的声音，当声音响度超过某个值，关灯！","text_tokens":["值","的","(","扩展","版","控制","智能","使用","，","响度","积木"," ","超过","接管",")","可","home","离线","关灯","设备","运行","皆","中","！","scratch","环境","某个","codelab","、","assistant","声音","监测","在线","当","所有","空间"],"title":"它是如何工作的?","title_tokens":["的","是","?","如何","它","工作"]},{"location":"Neverland/tpl/#_4","text":"安装和配置Home Assistant CodeLab Scratch 智能家居设备(以下是CodeLab的推荐清单，任选一项即可) 米家智能家庭套装( 购买链接 ) Yeelight彩光灯( 购买链接 ) 如果你是Home Assistant用户，则可以任意使用 任何社区接入的套件","text_tokens":["即可","的","套装","(","用户","安装","可以","你","智能","家庭","如果","一项","推荐","使用","，","灯"," ","家居","链接","任选","和","任意",")","米家","home","社区","任何","设备","以下","是","清单","scratch","yeelight","彩光","codelab","assistant","配置","购买","智能家居","则","套件","接入"],"title":"你需要准备些什么","title_tokens":["准备","你","什么","些","需要"]},{"location":"Neverland/tpl/#2","text":"在线版与离线版打开方式 如果你是要在线版，直接 点击项目链接 即可。未来我们会直接发布到社区里。 如果你使用离线版，则下载 源码文件 ,使用Scratch加载它即可. 加载后填入你之前记下的token。","text_tokens":["即可",",","的","方式","里","记下","版","你","未来","。","之前","如果","打开","我们","使用","，","下载","token"," ","链接","文件","它","直接","开方","离线","社区","加载","与","后","是","到","源码","scratch",".","在线","则","要","发布","会","项目","点击","打开方式","填入"],"title":"步骤2: 编程","title_tokens":["步骤","2",":"," ","编程"]},{"location":"Neverland/tpl/#3","text":"现在你可以使用CodeLab Scratch的Home Assistant插件自由的编程啦，试着与Scratch里其他有趣的积木互动吧。 如果你想让程序只对响指声作出反应，甚至只对你的响指声作出反应都是可能的，使用AI来做到这点！ CodeLab Adapter已经将Teachable Machine接入进来了 ，你可以使用声音、肢体、各种物体与你的房间进行互动！","text_tokens":["让","的","作出反应","试着","可以","可能","里","程序","ai","进行","你","作出","互动","。","肢体","如果","现在","插件","teachable","使用","，","积木","各种"," ","编程","home","自由","将","与","来","响指","做到","这点","反应","进来","都","声","！","吧","想","甚至","scratch","是","对","房间","codelab","有趣","assistant","声音","adapter","了","、","其他","只","machine","啦","接入","物体","已经"],"title":"步骤3: 发挥想象","title_tokens":["3","步骤",":","想象","发挥"," "]},{"location":"Neverland/yeelight/","text":"","text_tokens":[],"title":"Yeelight","title_tokens":["yeelight"]},{"location":"Python_Projects/I_am_reading/","text":"I am reading! ¶ 依赖 ¶ 依赖 需要身处CodeLab Neverland空间里 项目介绍 ¶ 你在房间里看《权力的游戏》，当房门突然被打开时，屏幕自动切换到阅读界面。 思路 ¶ 在 Neverland 中使用 HANode 基类与空间中的智能家居交互: 当 门窗传感器 感应到门被推开时，将信号报告给电脑，将界面切换到读书 App。 涉及的知识 ¶ 继承 面向对象（OOP） subprocess：从 Python 中调用系统命令 函数调用 CodeLab Adapter Longan 插件 想象空间 ¶ 使用 Python 为整个空间编程！ 示例 ¶ 项目源码 ¶ neverland_i_am_reading.py 使用说明 ¶ 步骤 1：安装 Python ¶ 建议通过搜索引擎，学习如何安装 Python3( >=3.6 ). 或者参考 python.org Python 3 Installation & Setup Guide 步骤 2：安装依赖 ¶ pip install codelab_adapter_client --upgrade 步骤 3：下载源码 ¶ 将 项目源码 复制或下载到本地。 步骤 4：运行 ¶ python neverland_i_am_reading.py 你的创作 ¶ 一些建议： 关上门之后你想触发什么行为？ 看看其他的例子： examples 试试 Neverland 里的其他智能设备","text_tokens":["的","hanode","步骤","时","门窗","安装","(","你","行为","知识","oop","继承","pip","1","org",">","（","longan","想象","家居","说明","关上门","setup","设备","什么","需要",".","为","codelab","》","介绍","调用","adapter","3.6","reading","权力","自动","面向","上门","-","本地","py",":","在","看看","install","或","复制","下载","之后","参考","被","i",")","房门","搜索","索引","将","python","_","中","从","传感","guide","想","传感器","通过","示例","游戏","整个","2","当","!","感器","函数","依赖","搜索引擎","如何","思路","读书","建议","例子","。","：","打开","3","给","，","或者","面向对象","引擎","阅读","《","看","切换","？","运行","！","系统","命令","python3","涉及","信号","¶","触发","身处","其他","neverland","交互","examples","am","client","项目","）","电脑","空间","推开","upgrade","基类","里","界面","&","subprocess","智能","4","插件","使用","=","创作"," ","编程","屏幕","与","函数调用","一些","报告","关上","到","源码","突然","房间","app","系统命令","试试","installation","门","智能家居","学习","对象","感应"],"title":"I am reading!","title_tokens":["!","reading"," ","am","i"]},{"location":"Python_Projects/I_am_reading/#i-am-reading","text":"","text_tokens":[],"title":"I am reading!","title_tokens":["!","reading"," ","am","i"]},{"location":"Python_Projects/I_am_reading/#_1","text":"依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","里","依赖","身处","neverland"," ","需要","空间"],"title":"依赖","title_tokens":["依赖"]},{"location":"Python_Projects/I_am_reading/#_2","text":"你在房间里看《权力的游戏》，当房门突然被打开时，屏幕自动切换到阅读界面。","text_tokens":["的","时","里","在","界面","你","。","打开","，","阅读","《","被","看","房门","屏幕","切换","到","突然","房间","游戏","》","权力","自动","当"],"title":"项目介绍","title_tokens":["项目","介绍"]},{"location":"Python_Projects/I_am_reading/#_3","text":"在 Neverland 中使用 HANode 基类与空间中的智能家居交互: 当 门窗传感器 感应到门被推开时，将信号报告给电脑，将界面切换到读书 App。","text_tokens":["感器","的","基类","hanode","门窗","时",":","在","界面","读书","智能","。","给","使用","，"," ","家居","被","切换","将","与","中","报告","传感","传感器","到","app","信号","neverland","交互","门","智能家居","当","感应","电脑","空间","推开"],"title":"思路","title_tokens":["思路"]},{"location":"Python_Projects/I_am_reading/#_4","text":"继承 面向对象（OOP） subprocess：从 Python 中调用系统命令 函数调用 CodeLab Adapter Longan 插件","text_tokens":["函数","subprocess","：","oop","继承","插件","面向对象","（","longan"," ","python","函数调用","从","中","系统","命令","系统命令","codelab","调用","adapter","对象","面向","）"],"title":"涉及的知识","title_tokens":["涉及","的","知识"]},{"location":"Python_Projects/I_am_reading/#_5","text":"使用 Python 为整个空间编程！","text_tokens":["为","使用","整个","python"," ","！","空间","编程"],"title":"想象空间","title_tokens":["空间","想象"]},{"location":"Python_Projects/I_am_reading/#_6","text":"","text_tokens":[],"title":"示例","title_tokens":["示例"]},{"location":"Python_Projects/I_am_reading/#_7","text":"neverland_i_am_reading.py","text_tokens":[".","py","reading","neverland","_","am","i"],"title":"项目源码","title_tokens":["项目","源码"]},{"location":"Python_Projects/I_am_reading/#_8","text":"","text_tokens":[],"title":"使用说明","title_tokens":["说明","使用"]},{"location":"Python_Projects/I_am_reading/#1-python","text":"建议通过搜索引擎，学习如何安装 Python3( >=3.6 ). 或者参考 python.org Python 3 Installation & Setup Guide","text_tokens":["(","安装","搜索引擎","如何","&","建议","3","，","或者",">","=","org","参考","引擎"," ",")","搜索","索引","setup","python","guide","python3","通过",".","installation","3.6","学习"],"title":"步骤 1：安装 Python","title_tokens":["1","步骤","安装","python"," ","："]},{"location":"Python_Projects/I_am_reading/#2","text":"pip install codelab_adapter_client --upgrade","text_tokens":["pip","-","codelab","adapter","_"," ","client","install","upgrade"],"title":"步骤 2：安装依赖","title_tokens":["步骤","安装","2","依赖"," ","："]},{"location":"Python_Projects/I_am_reading/#3","text":"将 项目源码 复制或下载到本地。","text_tokens":["复制","下载","本地","将"," ","到","。","项目","或","源码"],"title":"步骤 3：下载源码","title_tokens":["3","步骤","下载"," ","：","源码"]},{"location":"Python_Projects/I_am_reading/#4","text":"python neverland_i_am_reading.py","text_tokens":[".","py","python","neverland","_","reading"," ","am","i"],"title":"步骤 4：运行","title_tokens":["步骤","运行"," ","4","："]},{"location":"Python_Projects/I_am_reading/#_9","text":"一些建议： 关上门之后你想触发什么行为？ 看看其他的例子： examples 试试 Neverland 里的其他智能设备","text_tokens":["的","里","看看","你","建议","行为","例子","智能","：","之后"," ","关上门","设备","？","什么","一些","关上","想","试试","触发","其他","neverland","examples","上门"],"title":"你的创作","title_tokens":["创作","你","的"]},{"location":"Python_Projects/install_python/","text":"安装 Python3 ( Install Python3 ) ¶ 提醒开发者 本地即便没有安装 Python3，CodeLab Adapter 也能正常运行( extension )，如果你想使用 Adapter Node (诸如 node_vector ) ，则需要在本地有 Python3 环境。 安装了 Python3 之后， Adapter 将自动与其关联， 第三方公司/开发者能够使用 Python 生态中的所有资源，为用户去构建新的扩展( extension / node )，这样第三方公司能够将各类 AI /硬件/服务 接入进来 。这为 Adapter 带来了几乎无限的可扩展性。值得注意的事，这种方式的时间成本极低，你只需要构建插件业务逻辑，其他的一切都是免费得到的，从跨平台到强大的连接能力，参考 jupyterlab 在 CodeLab Adapter 中，通过点击查看环境，你可以看到本地Python环境是否存在。 你将看到: 如果你看到的信息和上图类似，则说明你本地已经安装了 Python3，请确保 Python3 版本 >= 3.6 。 如果你没有安装过Python3， 本文将引导你安装它。 Windows用户 ¶ !!! Windows10用户，需要到应用商店里安装Python(微软的强制要求)。或者参考 管理应用执行别名 如果之前没有安装过Python3， 推荐下载安装 Python3.7 。下载完成后，点击安装即可。 如果你之前安装过Python3，但版本低于 3.6 , 建议卸载后，再安装。 MacOS用户 ¶ MacOS自带了 Python3，如果你看到系统自带的 Python3 版本低于**3.6**， 推荐下载安装 Python3.7 ， 下载完成后，点击安装即可。 提醒 如果你是开发者，你的本地环境里可能有很多个版本的 Python3 环境，建议使用 pyenv 来管理它。你可以在配置文件里， 指定 Adapter 使用的 Python 版本 。 Linux用户 ¶ Linux 自带了 Python3，如果你看到系统自带的 Python3 版本低于**3.6**， 推荐使用 pyenv 安装新的 Python3 版本。 你可以在配置文件里， 指定 Adapter 使用的 Python3 版本 。 安装完成之后, 点击 刷新环境 再次点击 查看环境，你应该可以看到本地Python环境信息。","text_tokens":[",","的","这为","(","扩展","用户","安装","可以","应用","看到","上","你","开发","这种","如果","执行","类似","商店",">","说明","正常","微软","进来","引导","应该","pyenv","后","平台","需要","为","去","codelab","adapter","了","3.6","第三","得到","自动","新","所有","接入","点击","值得","已经","即可","关联","本地","生态","可能","跨平台",":","在","低于","ai","没有","install","与其","要求","下载","硬件","extension","之后","下载安装","参考","vector","带来","诸如","文件","和",")","三方","/","将","注意","存在","来","python","_","中","想","从","管理","通过","再次","windows10","别名","配置","linux","配置文件","只","公司","提醒","查看","几乎","强大","!","是否","*","能够","方式","可扩展性","逻辑","建议","。","一切都是","很多","也","一切","推荐","，","或者","指定","完成","刷新","构建","连接","确保","强制","展性","图","本文","运行","服务","jupyterlab","系统","python3","请","有","资源","即便","卸载","¶","值得注意","其他","则","免费","开发者","版本","里","成本","信息","之前","再","插件","使用","python3.7","业务","=","node"," ","事","时间","扩展性","极低","它","但","个","能","windows","自带","各类","到","是","环境","无限","过","能力","macos","第三方","这样"],"title":"安装Python.md","title_tokens":["安装",".","python","md"]},{"location":"Python_Projects/install_python/#python3-install-python3","text":"提醒开发者 本地即便没有安装 Python3，CodeLab Adapter 也能正常运行( extension )，如果你想使用 Adapter Node (诸如 node_vector ) ，则需要在本地有 Python3 环境。 安装了 Python3 之后， Adapter 将自动与其关联， 第三方公司/开发者能够使用 Python 生态中的所有资源，为用户去构建新的扩展( extension / node )，这样第三方公司能够将各类 AI /硬件/服务 接入进来 。这为 Adapter 带来了几乎无限的可扩展性。值得注意的事，这种方式的时间成本极低，你只需要构建插件业务逻辑，其他的一切都是免费得到的，从跨平台到强大的连接能力，参考 jupyterlab 在 CodeLab Adapter 中，通过点击查看环境，你可以看到本地Python环境是否存在。 你将看到: 如果你看到的信息和上图类似，则说明你本地已经安装了 Python3，请确保 Python3 版本 >= 3.6 。 如果你没有安装过Python3， 本文将引导你安装它。","text_tokens":["的","这为","(","扩展","用户","安装","可以","看到","上","你","开发","这种","如果","类似",">","说明","正常","进来","引导","平台","需要","为","去","codelab","adapter","了","3.6","第三","得到","自动","新","所有","接入","点击","值得","已经","关联","本地","生态","跨平台",":","在","ai","没有","与其","硬件","extension","之后","参考","vector","带来","诸如","和",")","三方","/","将","注意","存在","python","_","中","想","从","通过","只","公司","提醒","查看","几乎","强大","是否","能够","方式","可扩展性","逻辑","。","一切都是","也","一切","，","构建","连接","确保","展性","图","本文","运行","服务","jupyterlab","python3","请","有","资源","即便","值得注意","其他","则","免费","开发者","版本","成本","信息","插件","使用","业务","=","node"," ","事","时间","扩展性","极低","它","能","各类","到","环境","无限","过","能力","第三方","这样"],"title":"安装 Python3 ( Install Python3 )","title_tokens":["(","安装"," ","install",")","python3"]},{"location":"Python_Projects/install_python/#windows","text":"!!! Windows10用户，需要到应用商店里安装Python(微软的强制要求)。或者参考 管理应用执行别名 如果之前没有安装过Python3， 推荐下载安装 Python3.7 。下载完成后，点击安装即可。 如果你之前安装过Python3，但版本低于 3.6 , 建议卸载后，再安装。","text_tokens":["即可","!",",","的","(","版本","用户","应用","安装","里","低于","你","建议","没有","。","之前","再","执行","如果","要求","推荐","下载","，","商店","或者","python3.7","完成","下载安装","参考"," ",")","强制","但","微软","python","管理","后","到","需要","python3","windows10","过","别名","卸载","3.6","点击"],"title":"Windows用户","title_tokens":["用户","windows"]},{"location":"Python_Projects/install_python/#macos","text":"MacOS自带了 Python3，如果你看到系统自带的 Python3 版本低于**3.6**， 推荐下载安装 Python3.7 ， 下载完成后，点击安装即可。 提醒 如果你是开发者，你的本地环境里可能有很多个版本的 Python3 环境，建议使用 pyenv 来管理它。你可以在配置文件里， 指定 Adapter 使用的 Python 版本 。","text_tokens":["即可","的","*","版本","开发者","本地","安装","低于","里","可能","可以","看到","在","你","建议","开发","。","很多","如果","推荐","下载","，","python3.7","使用","指定","完成","下载安装"," ","文件","它","个","来","python","自带","pyenv","系统","后","管理","是","python3","环境","有","配置","了","adapter","配置文件","3.6","提醒","点击","macos"],"title":"MacOS用户","title_tokens":["用户","macos"]},{"location":"Python_Projects/install_python/#linux","text":"Linux 自带了 Python3，如果你看到系统自带的 Python3 版本低于**3.6**， 推荐使用 pyenv 安装新的 Python3 版本。 你可以在配置文件里， 指定 Adapter 使用的 Python3 版本 。 安装完成之后, 点击 刷新环境 再次点击 查看环境，你应该可以看到本地Python环境信息。","text_tokens":[",","的","*","版本","本地","安装","低于","可以","在","里","看到","你","信息","。","如果","推荐","使用","，","指定","之后","完成","刷新"," ","文件","python","自带","应该","pyenv","系统","python3","环境","再次","linux","了","配置","配置文件","3.6","adapter","查看","新","点击"],"title":"Linux用户","title_tokens":["linux","用户"]},{"location":"Python_Projects/introduction/","text":"介绍 ¶ A computer is an instrument whose music is ideas -- Alan Kay 之所以在面向对象中发明继承机制，是为了让入门者通过继承，在一开始就可以真正玩起来，而无需对细节有太多了解 -- Alan Kay 欢迎来到 Python 项目文档。 围绕《Mindstorms》的 microworld 概念 与《终生幼儿园》的 4P （Projects, Passion, Peers, Play） 理念构建 projects。","text_tokens":[",","让","幼儿园","的","-","可以","欢迎","所以","在","机制","为了","文档","入门","一","。","继承","an","就","太多","，","面向对象","玩起来","概念","4p","（","passion","玩起","无需"," ","细节","instrument","来到","《","peers","computer","真正","构建","projects","理念","开始","kay","起来","）","whose","alan","mindstorms","ideas","与","python","中","之所以","幼儿","play","是","有太多","music","对","通过","a","》","¶","介绍","发明","而","入门者","了解","对象","面向","is","项目","终生","围绕","microworld"],"title":"介绍(introduction)","title_tokens":["介绍",")","introduction","("]},{"location":"Python_Projects/introduction/#_1","text":"A computer is an instrument whose music is ideas -- Alan Kay 之所以在面向对象中发明继承机制，是为了让入门者通过继承，在一开始就可以真正玩起来，而无需对细节有太多了解 -- Alan Kay 欢迎来到 Python 项目文档。 围绕《Mindstorms》的 microworld 概念 与《终生幼儿园》的 4P （Projects, Passion, Peers, Play） 理念构建 projects。","text_tokens":[",","让","幼儿园","的","-","可以","欢迎","所以","在","机制","为了","文档","入门","一","。","继承","an","就","太多","，","面向对象","玩起来","概念","4p","（","passion","玩起","无需"," ","细节","instrument","来到","《","peers","computer","真正","构建","projects","理念","开始","kay","起来","）","whose","alan","mindstorms","ideas","与","python","中","之所以","幼儿","play","是","有太多","music","对","通过","a","》","发明","而","入门者","了解","对象","面向","is","项目","终生","围绕","microworld"],"title":"介绍","title_tokens":["介绍"]},{"location":"Python_Projects/project-list/","text":"项目列表 ¶ Python对象的连接器：EIM 插件 EasyOCR 聊天机器人 codelab_adapter_extensions : 目前所有内置的Adapter插件都是Python项目！","text_tokens":["的","所有","easyocr",":","机器人","列表","：","内置","插件","聊天"," ","连接","extensions","python","_","都","！","连接器","是","接器","codelab","¶","adapter","对象","eim","机器","目前","项目"],"title":"项目列表","title_tokens":["列表","项目"]},{"location":"Python_Projects/project-list/#_1","text":"Python对象的连接器：EIM 插件 EasyOCR 聊天机器人 codelab_adapter_extensions : 目前所有内置的Adapter插件都是Python项目！","text_tokens":["的","所有","easyocr",":","机器人","：","内置","插件","聊天"," ","连接","extensions","python","_","都","！","连接器","是","接器","codelab","adapter","对象","eim","机器","目前","项目"],"title":"项目列表","title_tokens":["列表","项目"]},{"location":"Python_Projects/python_scratch/","text":"Python 与 Scratch ¶ 你可以使用Python来增强Scratch，使用 Python 为 Scratch引入新的能力: python eval kernel python exec kernel 如果遇到问题，可以: 在此讨论","text_tokens":["的","遇到","可以",":","在","你","exec","如果","使用","，","kernel","讨论"," ","此","eval","引入","问题","增强","与","来","python","scratch","为","¶","能力","新"],"title":"Python 与 Scratch","title_tokens":["与"," ","scratch","python"]},{"location":"Python_Projects/python_scratch/#python-scratch","text":"你可以使用Python来增强Scratch，使用 Python 为 Scratch引入新的能力: python eval kernel python exec kernel 如果遇到问题，可以: 在此讨论","text_tokens":["的","遇到","可以",":","在","你","exec","如果","使用","，","kernel","讨论"," ","此","eval","引入","问题","增强","来","python","scratch","为","能力","新"],"title":"Python 与 Scratch","title_tokens":["与"," ","scratch","python"]},{"location":"Scratch_Projects/cube_symphony/","text":"魔方交响乐 ¶ 依赖 ¶ 依赖 需要身处CodeLab Neverland空间里 项目介绍 ¶ 使用 Aqara 魔方控制器进行交互音乐演奏。 思路 ¶ 在 Neverland 中使用 Longan 积木与空间中的智能家居交互：将魔方控制器用作传感器，进行交互式音乐创作。 涉及的知识 ¶ CodeLab Adapter Longan 插件 音乐 积木 乐器 节拍 音符 演奏速度 声音 积木 音量 音调 音效 左右平衡 事件 积木 控制 积木 变量 积木 运算 积木 想象空间 ¶ 与一群朋友一起交互创作 示例 ¶ 项目地址 ¶ 魔方交响乐 使用说明 ¶ 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 打开 extension_longan 插件. 步骤 2：打开项目 ¶ 魔方交响乐 开始使用 ¶ 根据项目注释里的 使用说明 操作。 你的创作 ¶ 一些建议： 挑选你喜欢的乐器组合 尝试不同节奏 试试魔方控制器的多种交互方式 摇晃 敲击两下 翻转 90 度 翻转 180 度 ... 试试 Longan 的其他传感器 将灯光效果也纳入进来！ 最近有朋友生日吗？为 Ta 创作一个生日 party 秀吧！","text_tokens":["的","步骤","一个","吗","音乐演奏","你","知识","音乐","1","音量","灯光","longan","aqara","音乐创作","想象","家居","用作","说明","一起","浏览器","180","交响","多种","进来","音符","需要","翻转","运算","启动",".","为","codelab","介绍","adapter","音效","组合","在","两下","根据","生日","之后","extension","敲击","效果","变量","平衡","将","控制器","ta","_","中","挑选","传感","吧","光效","传感器","示例","声音","双击","2","...","演奏","交互式","感器","方式","度","摇晃","浏览","依赖","90","尝试","思路","建议","。","：","打开","也","，","灯光效果","节奏","不同","魔方","注释","最近","开始","事件","交响乐","？","！","有","涉及","¶","身处","默认","neverland","交互","速度","其他","项目","进行","空间","乐器","里","party","节拍","智能","一群","操作","喜欢","插件","使用","积木","创作"," ","左右","与","一些","交互方式","纳入","试试","秀","朋友","智能家居","地址","音调","控制"],"title":"cube symphony","title_tokens":["symphony","cube"," "]},{"location":"Scratch_Projects/cube_symphony/#_1","text":"","text_tokens":[],"title":"魔方交响乐","title_tokens":["交响乐","交响","魔方"]},{"location":"Scratch_Projects/cube_symphony/#_2","text":"依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","里","依赖","身处","neverland"," ","需要","空间"],"title":"依赖","title_tokens":["依赖"]},{"location":"Scratch_Projects/cube_symphony/#_3","text":"使用 Aqara 魔方控制器进行交互音乐演奏。","text_tokens":["使用","控制器","aqara","交互","音乐演奏"," ","演奏","魔方","。","进行","控制","音乐"],"title":"项目介绍","title_tokens":["项目","介绍"]},{"location":"Scratch_Projects/cube_symphony/#_4","text":"在 Neverland 中使用 Longan 积木与空间中的智能家居交互：将魔方控制器用作传感器，进行交互式音乐创作。","text_tokens":["感器","的","在","智能","。","：","音乐","使用","，","积木","longan","音乐创作","创作"," ","家居","用作","魔方","将","与","控制器","中","传感","传感器","空间","neverland","交互","智能家居","交互式","进行","控制"],"title":"思路","title_tokens":["思路"]},{"location":"Scratch_Projects/cube_symphony/#_5","text":"CodeLab Adapter Longan 插件 音乐 积木 乐器 节拍 音符 演奏速度 声音 积木 音量 音调 音效 左右平衡 事件 积木 控制 积木 变量 积木 运算 积木","text_tokens":["乐器","节拍","音乐","插件","音量","积木","longan"," ","变量","平衡","事件","左右","音符","运算","codelab","声音","adapter","速度","音效","演奏","音调","控制"],"title":"涉及的知识","title_tokens":["涉及","的","知识"]},{"location":"Scratch_Projects/cube_symphony/#_6","text":"与一群朋友一起交互创作","text_tokens":["一起","与","交互","朋友","创作","一群"],"title":"想象空间","title_tokens":["空间","想象"]},{"location":"Scratch_Projects/cube_symphony/#_7","text":"","text_tokens":[],"title":"示例","title_tokens":["示例"]},{"location":"Scratch_Projects/cube_symphony/#_8","text":"魔方交响乐","text_tokens":["交响乐","交响","魔方"],"title":"项目地址","title_tokens":["项目","地址"]},{"location":"Scratch_Projects/cube_symphony/#_9","text":"","text_tokens":[],"title":"使用说明","title_tokens":["说明","使用"]},{"location":"Scratch_Projects/cube_symphony/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 打开 extension_longan 插件.","text_tokens":["浏览器","启动",".","插件","codelab","，","双击","adapter","将","之后","浏览","extension","默认","longan","_"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"Scratch_Projects/cube_symphony/#2","text":"魔方交响乐","text_tokens":["交响乐","交响","魔方"],"title":"步骤 2：打开项目","title_tokens":["步骤","2"," ","：","项目","打开"]},{"location":"Scratch_Projects/cube_symphony/#_10","text":"根据项目注释里的 使用说明 操作。","text_tokens":["操作","的","使用","里"," ","说明","。","项目","注释","根据"],"title":"开始使用","title_tokens":["开始","使用"]},{"location":"Scratch_Projects/cube_symphony/#_11","text":"一些建议： 挑选你喜欢的乐器组合 尝试不同节奏 试试魔方控制器的多种交互方式 摇晃 敲击两下 翻转 90 度 翻转 180 度 ... 试试 Longan 的其他传感器 将灯光效果也纳入进来！ 最近有朋友生日吗？为 Ta 创作一个生日 party 秀吧！","text_tokens":["感器","的","方式","度","摇晃","乐器","一个","吗","90","尝试","party","你","建议","两下","：","生日","喜欢","也","灯光","灯光效果","longan","敲击","创作"," ","节奏","不同","魔方","效果","最近","将","控制器","180","多种","进来","？","ta","一些","挑选","交互方式","传感","光效","纳入","传感器","！","翻转","吧","有","为","试试","秀","其他","交互","朋友","...","组合","控制"],"title":"你的创作","title_tokens":["创作","你","的"]},{"location":"Scratch_Projects/i_am_reading/","text":"I am reading ¶ 项目源码","text_tokens":["¶","reading"," ","am","项目","i","源码"],"title":"正在读书","title_tokens":["正在","读书"]},{"location":"Scratch_Projects/i_am_reading/#i-am-reading","text":"项目源码","text_tokens":["项目","源码"],"title":"I am reading","title_tokens":["reading","i"," ","am"]},{"location":"Scratch_Projects/introduction/","text":"介绍 ¶ real playing -- Alan Kay 欢迎来到 Scratch 项目文档。 围绕《Mindstorms》的 microworld 概念 与 《终生幼儿园》的 4P （Projects, Passion, Peers, Play）理念 构建 projects。","text_tokens":[",","幼儿园","的","-","欢迎","playing","。","文档","4p","（","概念","passion","peers"," ","来到","《","构建","projects","理念","kay","）","alan","mindstorms","与","幼儿","play","scratch","real","》","¶","介绍","项目","终生","围绕","microworld"],"title":"介绍(introduction)","title_tokens":["介绍",")","introduction","("]},{"location":"Scratch_Projects/introduction/#_1","text":"real playing -- Alan Kay 欢迎来到 Scratch 项目文档。 围绕《Mindstorms》的 microworld 概念 与 《终生幼儿园》的 4P （Projects, Passion, Peers, Play）理念 构建 projects。","text_tokens":[",","幼儿园","的","-","欢迎","playing","。","文档","4p","（","概念","passion","peers"," ","来到","《","构建","projects","理念","kay","）","alan","mindstorms","与","幼儿","play","scratch","real","》","项目","终生","围绕","microworld"],"title":"介绍","title_tokens":["介绍"]},{"location":"Scratch_Projects/scratch_ppt/","text":"Scratch PPT ¶ 项目介绍 ¶ 使用 Scratch 来制作 PPT，用于分享和演讲： 介绍自己 介绍自己最喜欢的玩具 介绍最喜欢的小动物 介绍团队成员 分享自己制作项目的经历 …… 思路 ¶ 将舞台背景用作 PPT 载体，绘制若干舞台背景，演讲时进行切换。 Tip 使用 角色 让演讲内容生动起来。 涉及的知识 ¶ 外观 积木 背景切换 制作舞台背景 事件 Scratch EIM 插件 CodeLab Adapter Python Kernel Extension 打开本地文件（目录/视频） 进阶 ¶ 使用 micro:bit 制作翻页笔 制作眼动仪翻页笔，帮助双手不便利的人 想象空间 ¶ 使用 Switch Joy-Con 作为翻页笔 示例 ¶ 项目源码 ¶ CodeLab PPT 使用说明 ¶ 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 打开 extension_python_kernel 插件。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：打开项目文件（.sb3文件） ¶ 将 项目源码 下载到本地。 开始使用 ¶ 根据项目注释里的 使用说明 操作。 你的创作 ¶ ... 参考 ¶ Scratch 入门项目|故事 raspberrypi Scratch Project","text_tokens":[",","的","步骤","成员","小","上","你","知识","生动","经历","绿色","1","眼动仪","（","kernel","想象","最","用作","说明","bit","浏览器","正常","这儿","制作","scratch","故事",".","启动","便利","codelab","作为","介绍","adapter","点击","|","让","小圆点","-","本地","内容",":","绘制","箭头","入门","根据","ui","下载","tip","extension","之后","…","翻页","参考","链接","文件","和","舞台","/","将","来","自己","python","目录","_","圆点","若干","示例","raspberrypi","双击","2","...","进阶","eim","外观","呈现","用于","浏览","思路","micro","。","：","人","ppt","打开","con","3","笔","，","或者","页面","web","scratch3","project","连接","注释","开始","起来","switch","事件","分享","切换","背景","玩具","如下","涉及","¶","默认","项目","进行","）","空间","载体","里","操作","喜欢","插件","使用","积木","创作"," ","演讲时","视频","joy","与","不","图中","源码","演讲","团队","到","角色","帮助","动物","scratch3.0","sb3","双手","所指"],"title":"Scratch PPT","title_tokens":[" ","scratch","ppt"]},{"location":"Scratch_Projects/scratch_ppt/#scratch-ppt","text":"","text_tokens":[],"title":"Scratch PPT","title_tokens":[" ","scratch","ppt"]},{"location":"Scratch_Projects/scratch_ppt/#_1","text":"使用 Scratch 来制作 PPT，用于分享和演讲： 介绍自己 介绍自己最喜欢的玩具 介绍最喜欢的小动物 介绍团队成员 分享自己制作项目的经历 ……","text_tokens":["的","成员","小","用于","：","ppt","经历","喜欢","使用","，","…","最"," ","和","分享","来","自己","玩具","制作","演讲","scratch","团队","介绍","动物","项目"],"title":"项目介绍","title_tokens":["项目","介绍"]},{"location":"Scratch_Projects/scratch_ppt/#_2","text":"将舞台背景用作 PPT 载体，绘制若干舞台背景，演讲时进行切换。 Tip 使用 角色 让演讲内容生动起来。","text_tokens":["让","载体","内容","绘制","。","ppt","生动","使用","，","tip","用作"," ","演讲时","舞台","起来","切换","将","背景","若干","演讲","角色","进行"],"title":"思路","title_tokens":["思路"]},{"location":"Scratch_Projects/scratch_ppt/#_3","text":"外观 积木 背景切换 制作舞台背景 事件 Scratch EIM 插件 CodeLab Adapter Python Kernel Extension 打开本地文件（目录/视频）","text_tokens":["本地","打开","插件","积木","extension","kernel","（"," ","文件","视频","舞台","事件","切换","/","背景","python","目录","制作","scratch","codelab","adapter","eim","）","外观"],"title":"涉及的知识","title_tokens":["涉及","的","知识"]},{"location":"Scratch_Projects/scratch_ppt/#_4","text":"使用 micro:bit 制作翻页笔 制作眼动仪翻页笔，帮助双手不便利的人","text_tokens":["的","笔","便利","使用","眼动仪","，","帮助",":","翻页"," ","不","双手","micro","制作","人","bit"],"title":"进阶","title_tokens":["进阶"]},{"location":"Scratch_Projects/scratch_ppt/#_5","text":"使用 Switch Joy-Con 作为翻页笔","text_tokens":["con","switch","-","笔","使用","joy","作为","翻页"," "],"title":"想象空间","title_tokens":["空间","想象"]},{"location":"Scratch_Projects/scratch_ppt/#_6","text":"","text_tokens":[],"title":"示例","title_tokens":["示例"]},{"location":"Scratch_Projects/scratch_ppt/#_7","text":"CodeLab PPT","text_tokens":[" ","codelab","ppt"],"title":"项目源码","title_tokens":["项目","源码"]},{"location":"Scratch_Projects/scratch_ppt/#_8","text":"","text_tokens":[],"title":"使用说明","title_tokens":["说明","使用"]},{"location":"Scratch_Projects/scratch_ppt/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 打开 extension_python_kernel 插件。","text_tokens":["浏览器","启动","插件","codelab","，","双击","adapter","将","之后","浏览","extension","默认","python","_","kernel"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"Scratch_Projects/scratch_ppt/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"Scratch_Projects/scratch_ppt/#3sb3","text":"将 项目源码 下载到本地。","text_tokens":["下载","本地","将"," ","到","。","项目","源码"],"title":"步骤 3：打开项目文件（.sb3文件）","title_tokens":["3",".","步骤","（"," ","sb3","文件","：","）","项目","打开"]},{"location":"Scratch_Projects/scratch_ppt/#_9","text":"根据项目注释里的 使用说明 操作。","text_tokens":["操作","的","使用","里"," ","说明","。","项目","注释","根据"],"title":"开始使用","title_tokens":["开始","使用"]},{"location":"Scratch_Projects/scratch_ppt/#_10","text":"...","text_tokens":["..."],"title":"你的创作","title_tokens":["创作","你","的"]},{"location":"Scratch_Projects/scratch_ppt/#_11","text":"Scratch 入门项目|故事 raspberrypi Scratch Project","text_tokens":["故事","raspberrypi","scratch","project"," ","入门","|","项目"],"title":"参考","title_tokens":["参考"]},{"location":"Scratch_Projects/击掌奏乐/","text":"击掌奏乐 ¶ 依赖 ¶ Makey Makey 项目介绍 ¶ 将同伴变为音符，将肢体的接触变为音乐。 思路 ¶ 音符扮演者手握 Makey Makey 导线，演奏者手握地线。当演奏者与音符扮演者肢体接触时，将触发信号，演奏音乐。 涉及的知识 ¶ 音乐 积木 音符 Makey Makey 积木","text_tokens":["的","时","依赖","扮演者","思路","知识","。","肢体","音乐","变为","，","积木","地","扮演"," ","导线","击掌","同伴","将","与","音符","演奏者","线","接触","涉及","奏乐","makey","¶","介绍","触发","信号","演奏","当","项目","手握"],"title":"击掌奏乐","title_tokens":["击掌","奏乐"]},{"location":"Scratch_Projects/击掌奏乐/#_1","text":"","text_tokens":[],"title":"击掌奏乐","title_tokens":["击掌","奏乐"]},{"location":"Scratch_Projects/击掌奏乐/#_2","text":"Makey Makey","text_tokens":["makey"," "],"title":"依赖","title_tokens":["依赖"]},{"location":"Scratch_Projects/击掌奏乐/#_3","text":"将同伴变为音符，将肢体的接触变为音乐。","text_tokens":["的","变为","，","将","。","音符","音乐","肢体","同伴","接触"],"title":"项目介绍","title_tokens":["项目","介绍"]},{"location":"Scratch_Projects/击掌奏乐/#_4","text":"音符扮演者手握 Makey Makey 导线，演奏者手握地线。当演奏者与音符扮演者肢体接触时，将触发信号，演奏音乐。","text_tokens":["时","扮演者","。","肢体","音乐","，","地","扮演"," ","导线","将","与","演奏者","音符","线","接触","信号","makey","触发","演奏","当","手握"],"title":"思路","title_tokens":["思路"]},{"location":"Scratch_Projects/击掌奏乐/#_5","text":"音乐 积木 音符 Makey Makey 积木","text_tokens":["积木","makey"," ","音符","音乐"],"title":"涉及的知识","title_tokens":["涉及","的","知识"]},{"location":"Scratch_Projects/击灭那盏灯/","text":"击灭那盏灯 ¶","text_tokens":["盏灯","¶","那"," ","击灭"],"title":"击灭那盏灯","title_tokens":["击灭","盏灯","那"]},{"location":"Scratch_Projects/击灭那盏灯/#_1","text":"","text_tokens":[],"title":"击灭那盏灯","title_tokens":["击灭","盏灯","那"]},{"location":"Scratch_Projects/彩虹的旋律/","text":"彩虹 🌈 的旋律 ¶ 项目介绍 ¶ 将彩虹糖用作音符来创作音乐。 思路 ¶ 彩虹糖在桌子上排成一列，使用摄像头对着它们, 彩虹糖被投影到 Scratch 舞台； 一个粉色箭头在屏幕中间，从左向右滑动； 当粉色箭头碰到不同颜色的彩虹糖时，演奏不同旋律的音符。 涉及的知识 ¶ 颜色编程 音乐 积木 音符 视频侦测 积木 动作 积木 控制 积木 运算 积木 侦测 积木 示例 ¶ 参考 彩虹 🌈 的旋律 。","text_tokens":[",","碰到","的","它们","动作","一个","在","上","思路","知识","🌈","着","。","投影","箭头","排成","糖","音乐","使用","，","积木","摄像头","创作","中间","参考"," ","用作","摄像","左向","不同","被","视频","舞台","编程","屏幕","像头","将","来","；","一列","彩虹","从","滑动","音符","到","scratch","对","示例","涉及","运算","左向右","粉色","¶","介绍","桌子","糖时","侦测","演奏","当","颜色","旋律","排成一列","项目","控制"],"title":"彩虹的旋律","title_tokens":["的","彩虹","旋律"]},{"location":"Scratch_Projects/彩虹的旋律/#_1","text":"","text_tokens":[],"title":"彩虹 🌈 的旋律","title_tokens":["的"," ","彩虹","🌈","旋律"]},{"location":"Scratch_Projects/彩虹的旋律/#_2","text":"将彩虹糖用作音符来创作音乐。","text_tokens":["将","来","创作","。","用作","彩虹","音符","糖","音乐"],"title":"项目介绍","title_tokens":["项目","介绍"]},{"location":"Scratch_Projects/彩虹的旋律/#_3","text":"彩虹糖在桌子上排成一列，使用摄像头对着它们, 彩虹糖被投影到 Scratch 舞台； 一个粉色箭头在屏幕中间，从左向右滑动； 当粉色箭头碰到不同颜色的彩虹糖时，演奏不同旋律的音符。","text_tokens":[",","碰到","的","它们","一个","在","上","着","投影","。","箭头","排成","糖","使用","，","摄像头","中间"," ","摄像","左向","不同","被","舞台","屏幕","像头","旋律","；","一列","彩虹","从","音符","到","scratch","对","左向右","粉色","桌子","糖时","演奏","当","颜色","滑动","排成一列"],"title":"思路","title_tokens":["思路"]},{"location":"Scratch_Projects/彩虹的旋律/#_4","text":"颜色编程 音乐 积木 音符 视频侦测 积木 动作 积木 控制 积木 运算 积木 侦测 积木","text_tokens":["运算","积木","编程","动作","侦测"," ","颜色","音符","视频","控制","音乐"],"title":"涉及的知识","title_tokens":["涉及","的","知识"]},{"location":"Scratch_Projects/彩虹的旋律/#_5","text":"参考 彩虹 🌈 的旋律 。","text_tokens":["的","参考"," ","彩虹","🌈","旋律","。"],"title":"示例","title_tokens":["示例"]},{"location":"Scratch_Projects/手势窗帘/","text":"手势窗帘 ¶ 依赖 ¶ 依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","¶","里","依赖","身处","窗帘","neverland"," ","需要","空间","手势"],"title":"手势窗帘","title_tokens":["手势","窗帘"]},{"location":"Scratch_Projects/手势窗帘/#_1","text":"","text_tokens":[],"title":"手势窗帘","title_tokens":["手势","窗帘"]},{"location":"Scratch_Projects/手势窗帘/#_2","text":"依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","里","依赖","身处","neverland"," ","需要","空间"],"title":"依赖","title_tokens":["依赖"]},{"location":"Scratch_Projects/搜索/","text":"搜索 ¶ 项目源码","text_tokens":["搜索","¶"," ","项目","源码"],"title":"搜索","title_tokens":["搜索"]},{"location":"Scratch_Projects/搜索/#_1","text":"项目源码","text_tokens":["项目","源码"],"title":"搜索","title_tokens":["搜索"]},{"location":"Scratch_Projects/灰袍巫师/","text":"灰袍巫师 ¶","text_tokens":["灰袍","¶","巫师"," "],"title":"灰袍巫师","title_tokens":["灰袍","巫师"]},{"location":"Scratch_Projects/灰袍巫师/#_1","text":"","text_tokens":[],"title":"灰袍巫师","title_tokens":["灰袍","巫师"]},{"location":"Scratch_Projects/目之所及/","text":"目之所及 ¶ 依赖 ¶ 依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","¶","里","目之所及","依赖","身处","neverland"," ","需要","空间","所及"],"title":"目之所及","title_tokens":["目之所及","所及"]},{"location":"Scratch_Projects/目之所及/#_1","text":"","text_tokens":[],"title":"目之所及","title_tokens":["目之所及","所及"]},{"location":"Scratch_Projects/目之所及/#_2","text":"依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","里","依赖","身处","neverland"," ","需要","空间"],"title":"依赖","title_tokens":["依赖"]},{"location":"Scratch_Projects/纸做的开关/","text":"纸做的开关 ¶ 依赖 ¶ 依赖 需要身处CodeLab Neverland空间里","text_tokens":["的","codelab","开关","¶","里","依赖","身处","neverland"," ","做","纸","需要","空间"],"title":"纸做的开关","title_tokens":["的","纸","做","开关"]},{"location":"Scratch_Projects/纸做的开关/#_1","text":"","text_tokens":[],"title":"纸做的开关","title_tokens":["的","纸","做","开关"]},{"location":"Scratch_Projects/纸做的开关/#_2","text":"依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","里","依赖","身处","neverland"," ","需要","空间"],"title":"依赖","title_tokens":["依赖"]},{"location":"Scratch_Projects/聊天机器人/","text":"聊天机器人 ¶ 将以下代码保存到 eim_monitor.py 文件里(在 Adapter 插件目录 中) # 将聊天服务从图灵机器人切换到腾讯闲聊 import requests import json import time import random import string import hashlib import urllib def monitor ( msg , logger ): ''' handle the message from the eim client(eg: scratch) ''' appId = \"2155753409\" apiKey = \"MyLQpyMr7K6S3kNI\" apiUrl = \"https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat\" content = { 'app_id' : appId , 'time_stamp' : str ( int ( time . time ())), 'nonce_str' : '' . join ( random . choice ( string . ascii_letters + string . digits ) for x in range ( 16 )), 'session' : '10000' . encode ( 'utf-8' ), 'question' : msg . encode ( 'utf-8' ) } sign_before = '' for key in sorted ( content ): # 键值拼接过程value部分需要URL编码，URL编码算法用大写字母，例如%E8。quote默认大写。 sign_before += '{}={}&' . format ( key , urllib . parse . quote ( content [ key ], safe = '' )) # 将应用密钥以app_key为键名，拼接到字符串sign_before末尾 sign_before += 'app_key={}' . format ( apiKey ) # 对字符串sign_before进行MD5运算，得到接口请求签名 sign = hashlib . md5 ( sign_before . encode ( 'UTF-8' )) . hexdigest () . upper () content [ 'sign' ] = sign stime = time . time () r = requests . post ( apiUrl , data = content ) . json () qtime = time . time () dt = qtime - stime print ( dt ) return r [ 'data' ][ 'answer' ] 之后可以在Scratch中使用它： 聊天机器人源码","text_tokens":[",","(","应用","可以","签名","data","部分","before","nonce","letters","算法","'","用","print","com","import","stime","]","scratch","需要","msg","fcgi",".","腾讯","为","运算","for","adapter","urllib","得到","+","e8","digits","机器","key","以","sign","大写","qtime","-","16","py",":","在","机器人","mylqpymr7k6s3kni","ai","接口","请求","https","post","\"","apikey","logger","之后","8","upper","文件",")","content","int","utf","ascii","/","session","join","将","eg","目录","图灵","_","from","中","从","过程","对","nlp","encode","id","format","eim","2155753409","例如","str","}","handle","保存","hashlib","textchat","answer","。","：","bin","x","大写字母","，","写字","stamp","#","拼接","requests","message","切换","编码","以下","服务","json","time","apiurl","range","monitor","quote","¶","默认","密钥","键名","string","字符","api","client","url","进行","{","value","dt","末尾","safe","里","闲聊","&","字符串","qq","[","字母","插件","使用","in","=","random","键值","%","hexdigest","聊天","appid","sorted"," ","它","return","def","代码","the","到","源码","10000","app","md5","choice","r","parse","question"],"title":"聊天机器人","title_tokens":["机器","机器人","聊天"]},{"location":"Scratch_Projects/聊天机器人/#_1","text":"将以下代码保存到 eim_monitor.py 文件里(在 Adapter 插件目录 中) # 将聊天服务从图灵机器人切换到腾讯闲聊 import requests import json import time import random import string import hashlib import urllib def monitor ( msg , logger ): ''' handle the message from the eim client(eg: scratch) ''' appId = \"2155753409\" apiKey = \"MyLQpyMr7K6S3kNI\" apiUrl = \"https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat\" content = { 'app_id' : appId , 'time_stamp' : str ( int ( time . time ())), 'nonce_str' : '' . join ( random . choice ( string . ascii_letters + string . digits ) for x in range ( 16 )), 'session' : '10000' . encode ( 'utf-8' ), 'question' : msg . encode ( 'utf-8' ) } sign_before = '' for key in sorted ( content ): # 键值拼接过程value部分需要URL编码，URL编码算法用大写字母，例如%E8。quote默认大写。 sign_before += '{}={}&' . format ( key , urllib . parse . quote ( content [ key ], safe = '' )) # 将应用密钥以app_key为键名，拼接到字符串sign_before末尾 sign_before += 'app_key={}' . format ( apiKey ) # 对字符串sign_before进行MD5运算，得到接口请求签名 sign = hashlib . md5 ( sign_before . encode ( 'UTF-8' )) . hexdigest () . upper () content [ 'sign' ] = sign stime = time . time () r = requests . post ( apiUrl , data = content ) . json () qtime = time . time () dt = qtime - stime print ( dt ) return r [ 'data' ][ 'answer' ] 之后可以在Scratch中使用它： 聊天机器人源码","text_tokens":[",","(","应用","可以","签名","data","部分","before","nonce","letters","算法","'","用","print","com","import","stime","]","scratch","需要","msg","fcgi",".","腾讯","为","运算","for","adapter","urllib","得到","+","e8","digits","机器","key","以","sign","大写","qtime","-","16","py",":","在","机器人","mylqpymr7k6s3kni","ai","接口","请求","https","post","\"","apikey","logger","之后","8","upper","文件",")","content","int","utf","ascii","/","session","join","将","eg","目录","图灵","_","from","中","从","过程","对","nlp","encode","id","format","eim","2155753409","例如","str","}","handle","保存","hashlib","textchat","answer","。","：","bin","x","大写字母","，","写字","stamp","#","拼接","requests","message","切换","编码","以下","服务","json","time","apiurl","range","monitor","quote","默认","密钥","键名","string","字符","api","client","url","进行","{","value","dt","末尾","safe","里","闲聊","&","字符串","qq","[","字母","插件","使用","in","=","random","键值","%","hexdigest","聊天","appid","sorted"," ","它","return","def","代码","the","到","源码","10000","app","md5","choice","r","parse","question"],"title":"聊天机器人","title_tokens":["机器","机器人","聊天"]},{"location":"Scratch_Projects/自制门禁系统/","text":"自制门禁系统 ¶ 依赖 ¶ 依赖 需要身处CodeLab Neverland空间里","text_tokens":["门禁系统","codelab","¶","里","自制","依赖","身处","neverland"," ","系统","门禁","需要","空间"],"title":"自制门禁系统","title_tokens":["门禁","门禁系统","自制","系统"]},{"location":"Scratch_Projects/自制门禁系统/#_1","text":"","text_tokens":[],"title":"自制门禁系统","title_tokens":["门禁","门禁系统","自制","系统"]},{"location":"Scratch_Projects/自制门禁系统/#_2","text":"依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","里","依赖","身处","neverland"," ","需要","空间"],"title":"依赖","title_tokens":["依赖"]},{"location":"Scratch_Projects/芝麻开门/","text":"芝麻开门 ¶ 依赖 ¶ 依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","¶","里","依赖","开门","身处","芝麻","neverland"," ","需要","空间","芝麻开门"],"title":"芝麻开门","title_tokens":["芝麻","开门","芝麻开门"]},{"location":"Scratch_Projects/芝麻开门/#_1","text":"","text_tokens":[],"title":"芝麻开门","title_tokens":["芝麻","开门","芝麻开门"]},{"location":"Scratch_Projects/芝麻开门/#_2","text":"依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","里","依赖","身处","neverland"," ","需要","空间"],"title":"依赖","title_tokens":["依赖"]},{"location":"Scratch_Projects/闭眼请熄灯/","text":"闭眼请熄灯 ¶ 依赖 ¶ 依赖 需要身处CodeLab Neverland空间里 项目介绍 ¶","text_tokens":["codelab","¶","介绍","里","依赖","身处","neverland","闭眼","空间"," ","项目","需要","请","熄灯"],"title":"闭眼请熄灯","title_tokens":["闭眼","请","熄灯"]},{"location":"Scratch_Projects/闭眼请熄灯/#_1","text":"","text_tokens":[],"title":"闭眼请熄灯","title_tokens":["闭眼","请","熄灯"]},{"location":"Scratch_Projects/闭眼请熄灯/#_2","text":"依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","里","依赖","身处","neverland"," ","需要","空间"],"title":"依赖","title_tokens":["依赖"]},{"location":"Scratch_Projects/闭眼请熄灯/#_3","text":"","text_tokens":[],"title":"项目介绍","title_tokens":["项目","介绍"]},{"location":"Scratch_Projects/霍格沃兹/","text":"霍格沃兹 ¶ 依赖 ¶ 依赖 需要身处CodeLab Neverland空间里 项目介绍 ¶ 使用魔杖操控空间里的设备。 思路 ¶ 使用 姿态神经网络 分析手部的运行，根据运动模式/位置，触发指令，控制设备。 涉及的知识 ¶ 声音 积木 控制 积木 姿态神经网络 坐标系统 CodeLab Adapter Longan 插件 示例 ¶ ……","text_tokens":["的","里","依赖","魔杖","控制","思路","指令","知识","坐标","。","运动","根据","分析","神经网络","插件","格沃兹","使用","，","积木","longan","…"," ","手部","位置","网络","/","设备","运行","霍","操控","系统","姿态","需要","模式","神经","神经网","涉及","示例","codelab","声音","¶","介绍","触发","adapter","身处","neverland","项目","空间"],"title":"霍格沃兹","title_tokens":["格沃兹","霍"]},{"location":"Scratch_Projects/霍格沃兹/#_1","text":"","text_tokens":[],"title":"霍格沃兹","title_tokens":["格沃兹","霍"]},{"location":"Scratch_Projects/霍格沃兹/#_2","text":"依赖 需要身处CodeLab Neverland空间里","text_tokens":["codelab","里","依赖","身处","neverland"," ","需要","空间"],"title":"依赖","title_tokens":["依赖"]},{"location":"Scratch_Projects/霍格沃兹/#_3","text":"使用魔杖操控空间里的设备。","text_tokens":["的","使用","设备","里","魔杖","操控","。","空间"],"title":"项目介绍","title_tokens":["项目","介绍"]},{"location":"Scratch_Projects/霍格沃兹/#_4","text":"使用 姿态神经网络 分析手部的运行，根据运动模式/位置，触发指令，控制设备。","text_tokens":["的","指令","。","运动","根据","分析","神经网络","使用","，"," ","手部","位置","网络","/","设备","运行","姿态","模式","神经","神经网","触发","控制"],"title":"思路","title_tokens":["思路"]},{"location":"Scratch_Projects/霍格沃兹/#_5","text":"声音 积木 控制 积木 姿态神经网络 坐标系统 CodeLab Adapter Longan 插件","text_tokens":["神经","神经网","神经网络","插件","声音","网络","codelab","积木","adapter","longan"," ","坐标","系统","姿态","控制"],"title":"涉及的知识","title_tokens":["涉及","的","知识"]},{"location":"Scratch_Projects/霍格沃兹/#_6","text":"……","text_tokens":["…"],"title":"示例","title_tokens":["示例"]},{"location":"Scratch_Projects/音乐主题活动/","text":"音乐主题活动 ¶ projects passion peers play programming 环境依赖 ¶ Chrome/Firefox： 打开 CodeLab Scratch CodeLab Adapter micro:bit 活动流程 ¶ 活动介绍 介绍 CodeLab 传递编程的乐趣，帮助孩子成为数字时代的创作者 展示视频案例（with CodeLab Adapter） 现场演示、体验（Projects） 即兴创作、协作（孩子＋父母＋志愿者） Scratch Card 开始编程 志愿者辅导 自由创作（体验区） 孩子＋父母＋志愿者 作品分享、分享感受 体验 ¶ 魔方交响乐 使用智能家居的魔方积木创建交响乐 使用 toio 自制乐器 使用 Scratch 和 toio 小方块构建自己的乐器，演奏者通过移动 toio 小方块，将空间位置信息映射为音符和节拍 demo2 乐高距离传感器演奏 使用乐高距离传感器将距离信息映射为音符，进而构建出交互式演奏乐器 micro:bit 运动音乐 利用 micro:bit 的陀螺仪演奏音乐，将运动转化为音乐 声控灯 制作日常生活中的声控灯 手掌演奏 使用 makey makey 将活动参与者的手掌变为钢琴按键，进行交互式演奏 入门 ¶ Scratch Cards（纸质卡片） 更多好玩项目（Microworld） ¶ DJ Scratch Cat Piano Remix this Dance Starfish Choir Sound Flower","text_tokens":["纸质","的","with","映射","piano","音乐","活动","距离","利用","passion","（","toio","家居","choir","bit","＋","projects","区","小方块","交响","协作","card","音符","制作","成为","scratch","为","codelab","陀螺","adapter","介绍","钢琴","peers","创作者",":","常生","乐趣","作品","入门","remix","programming","即兴","志愿","dj","变为","dance","灯","志愿者","和","时代","小方","/","将","作者","自己","中","陀螺仪","play","传感","传感器","通过","日常生活","演示","chrome","、","父母","案例","愿者","日常","演奏","交互式","出","展示","感器","转化","依赖","传递","starfish","micro","：","运动","打开","firefox","好玩","，","声控","魔方","构建","开始","位置","分享","自由","交响乐","感受","现场","多","参与","cat","演奏者","流程","辅导","体验","¶","卡片","交互","方块","项目","进行","）","空间","microworld","按键","主题","乐器","自制","节拍","智能","信息","乐高","使用","生活","积木","更","创作"," ","数字","flower","视频","编程","进而","this","手掌","环境","makey","帮助","sound","demo2","智能家居","cards","参与者","孩子","移动","创建"],"title":"音乐主题活动","title_tokens":["主题","活动","音乐"]},{"location":"Scratch_Projects/音乐主题活动/#_1","text":"projects passion peers play programming","text_tokens":["programming","passion"," ","play","peers","projects"],"title":"音乐主题活动","title_tokens":["主题","活动","音乐"]},{"location":"Scratch_Projects/音乐主题活动/#_2","text":"Chrome/Firefox： 打开 CodeLab Scratch CodeLab Adapter micro:bit","text_tokens":["chrome","firefox","codelab","/","adapter",":","bit"," ","micro","：","scratch","打开"],"title":"环境依赖","title_tokens":["依赖","环境"]},{"location":"Scratch_Projects/音乐主题活动/#_3","text":"活动介绍 介绍 CodeLab 传递编程的乐趣，帮助孩子成为数字时代的创作者 展示视频案例（with CodeLab Adapter） 现场演示、体验（Projects） 即兴创作、协作（孩子＋父母＋志愿者） Scratch Card 开始编程 志愿者辅导 自由创作（体验区） 孩子＋父母＋志愿者 作品分享、分享感受","text_tokens":["展示","的","传递","with","乐趣","作品","即兴","活动","志愿","，","（","创作"," ","数字","志愿者","视频","＋","时代","projects","编程","开始","区","分享","自由","作者","感受","现场","协作","card","成为","scratch","辅导","体验","演示","codelab","、","案例","父母","介绍","帮助","adapter","愿者","孩子","）","创作者"],"title":"活动流程","title_tokens":["活动","流程"]},{"location":"Scratch_Projects/音乐主题活动/#_4","text":"魔方交响乐 使用智能家居的魔方积木创建交响乐 使用 toio 自制乐器 使用 Scratch 和 toio 小方块构建自己的乐器，演奏者通过移动 toio 小方块，将空间位置信息映射为音符和节拍 demo2 乐高距离传感器演奏 使用乐高距离传感器将距离信息映射为音符，进而构建出交互式演奏乐器 micro:bit 运动音乐 利用 micro:bit 的陀螺仪演奏音乐，将运动转化为音乐 声控灯 制作日常生活中的声控灯 手掌演奏 使用 makey makey 将活动参与者的手掌变为钢琴按键，进行交互式演奏","text_tokens":["按键","感器","的","转化","乐器",":","自制","常生","映射","节拍","智能","信息","micro","运动","音乐","活动","距离","乐高","使用","，","积木","利用","生活","变为","toio","灯"," ","家居","声控","魔方","构建","和","bit","位置","小方","小方块","将","自己","交响乐","进而","交响","出","参与","中","陀螺仪","传感","演奏者","音符","制作","传感器","scratch","手掌","通过","日常生活","为","陀螺","makey","钢琴","交互","demo2","日常","智能家居","方块","演奏","交互式","参与者","进行","空间","移动","创建"],"title":"体验","title_tokens":["体验"]},{"location":"Scratch_Projects/音乐主题活动/#_5","text":"Scratch Cards（纸质卡片）","text_tokens":["纸质","（","卡片"," ","cards","）","scratch"],"title":"入门","title_tokens":["入门"]},{"location":"Scratch_Projects/音乐主题活动/#microworld","text":"DJ Scratch Cat Piano Remix this Dance Starfish Choir Sound Flower","text_tokens":["dj","dance","cat","sound","remix","starfish"," ","this","flower","piano","choir","scratch"],"title":"更多好玩项目（Microworld）","title_tokens":["好玩","更","（","多","项目","）","microworld"]},{"location":"Scratch_Projects/鼻梁上的老花镜/","text":"鼻梁上的老花镜（增强现实） ¶","text_tokens":["的","增强","现实","¶","（","上","鼻梁"," ","）","老花","花镜","老花镜"],"title":"鼻梁上的老花镜","title_tokens":["的","上","鼻梁","老花","花镜","老花镜"]},{"location":"Scratch_Projects/鼻梁上的老花镜/#_1","text":"","text_tokens":[],"title":"鼻梁上的老花镜（增强现实）","title_tokens":["的","增强","现实","（","上","鼻梁","）","老花","花镜","老花镜"]},{"location":"about/License/","text":"证书（License） ¶ 您可以免费将 CodeLab Adapter 用于研究与学习；如果您需要将其用于商业项目，请联系： wuwenjie@codelab.club ； You are free to use CodeLab Adapter for research and learning. If you are ready to use it for commercial purposes, please contact me: wuwenjie@codelab.club .","text_tokens":[",","commercial","免费","license","please","可以",":","用于","其","：","purposes","如果","it","您","商业","，","@","（","ready","to","are","club"," ","wuwenjie","me","contact","证书","将","与","use","learning","；","free","you","研究","需要","请","research","if",".","codelab","for","¶","adapter","and","联系","学习","项目","）"],"title":"证书(license)","title_tokens":["证书",")","(","license"]},{"location":"about/License/#license","text":"您可以免费将 CodeLab Adapter 用于研究与学习；如果您需要将其用于商业项目，请联系： wuwenjie@codelab.club ； You are free to use CodeLab Adapter for research and learning. If you are ready to use it for commercial purposes, please contact me: wuwenjie@codelab.club .","text_tokens":[",","commercial","免费","please","可以",":","用于","其","：","purposes","如果","it","您","商业","，","@","ready","to","are","club"," ","wuwenjie","me","contact","将","与","use","learning","；","free","you","研究","需要","请","research","if",".","codelab","for","adapter","and","联系","学习","项目"],"title":"证书（License）","title_tokens":["证书","（","）","license"]},{"location":"about/contact/","text":"联系我们（Contact us） ¶ 如果你： 希望建立合作 想吐槽 CodeLab Adapter，打击一下开发团队 在写 CodeLab Adapter 插件时遇到一些困难，影响到胃口 觉得人生苦短，想与我们一起折腾些有趣的事 我们热爱开源文化和社区，写代码之余也写写打油诗 简历最好附上 GitHub 和 Blog 想提点建议，教开发团队做人，当面提的话，最好能蹭个饭 有好玩的主意，想撩一撩开发团队 喜欢创作故事、剧本，有插画的技能，想把故事搬到 Scratch 3.0 上 我们将让你的虚拟人物与现实交融在一起，供你差遣各种好玩的物联网设备和 AI 喜欢柏拉图和罗素，想找个雨夜聊聊人生 欢迎来信啦： wuwenjie718@gmail.com 闲敲棋子落灯花","text_tokens":["的","时","上","你","开发","插画","如果","我们","（","来信","拉图","一起","社区","设备","com","scratch","故事","写写","能蹭个","柏拉图","找个",".","codelab","虚拟","adapter","罗素","打油","让","打油诗","热爱","在","ai","物","做人","各种","@","一下","灯花","打击","和","contact","合作","折腾","提","雨夜","提点","将","wuwenjie718","想","us","苦短","剧本","、","联系","胃口","主意","些","啦","建立","联网","觉得","遇到","建议","人生","：","简历","也","好玩","，","现实","希望","落","供","gmail","开源","技能","附上","把","想吐槽","人物","柏拉","有","github","差遣","¶","交融","写","）","文化","欢迎","棋子","一","教","喜欢","闲","插件","敲","聊聊","创作"," ","事","撩","搬","与","代码","一些","影响","到","团队","饭","有趣","最好","的话","之余","blog","3.0","困难","当面"],"title":"联系我们(contact us)","title_tokens":["我们","(","联系"," ",")","us","contact"]},{"location":"about/contact/#contact-us","text":"如果你： 希望建立合作 想吐槽 CodeLab Adapter，打击一下开发团队 在写 CodeLab Adapter 插件时遇到一些困难，影响到胃口 觉得人生苦短，想与我们一起折腾些有趣的事 我们热爱开源文化和社区，写代码之余也写写打油诗 简历最好附上 GitHub 和 Blog 想提点建议，教开发团队做人，当面提的话，最好能蹭个饭 有好玩的主意，想撩一撩开发团队 喜欢创作故事、剧本，有插画的技能，想把故事搬到 Scratch 3.0 上 我们将让你的虚拟人物与现实交融在一起，供你差遣各种好玩的物联网设备和 AI 喜欢柏拉图和罗素，想找个雨夜聊聊人生 欢迎来信啦： wuwenjie718@gmail.com 闲敲棋子落灯花","text_tokens":["的","时","上","你","开发","插画","如果","我们","来信","拉图","一起","社区","设备","com","scratch","写写","能蹭个","故事","柏拉图","找个",".","codelab","虚拟","adapter","罗素","打油","让","打油诗","热爱","在","ai","物","做人","各种","@","一下","灯花","打击","和","合作","折腾","提","雨夜","提点","将","wuwenjie718","想","苦短","剧本","、","胃口","主意","些","啦","建立","联网","觉得","遇到","建议","人生","：","简历","也","好玩","，","现实","希望","落","供","gmail","开源","技能","附上","把","想吐槽","人物","柏拉","有","github","差遣","交融","写","文化","欢迎","棋子","一","教","喜欢","闲","插件","敲","聊聊","创作"," ","事","撩","搬","与","代码","一些","影响","到","团队","饭","有趣","最好","的话","之余","blog","3.0","困难","当面"],"title":"联系我们（Contact us）","title_tokens":["我们","（","联系"," ","）","us","contact"]},{"location":"about/roadmap/","text":"路线图（Roadmap） ¶ 2.0 (end) ¶ 移动端支持 已完成： codelab-adapter 的移动端解决方案 允许在 GUI 面板上启停插件 已完成 本地 SSL 安全证书 已完成 引入 json-rpc 已完成 替代 Scratch Link，实现 Scratch Link 的蓝牙代理服务 分析 scratch 3.0 与 micro:bit 的通信 故事与课程 使用物联网和 AI 增强表现力 重构插件系统，使用协程 发布不同平台的安装包 接入 openBCI 接入眼动仪 已完成 接入 Parrot pyparrot 已完成 在前端启停软件 json-rpc 异步实现 提供更好用的通信机制（包装 zeromq 到 utils），作为最佳实践 3.0 ¶","text_tokens":["的","(","前端","安装","分析","表现力","parrot","眼动仪","课程","软件","（","bit","用","证书","端","end","蓝牙","平台","scratch","通信","故事","替代","codelab","移动","作为","adapter","启停","接入","线图","-","本地","utils",":","在","实现","ai","机制","物","和",")","增强","ssl","更好","路线图","link","安装包","解决","支持","联网","协程","方案","路线","gui","包装","micro","：","，","完成","表现","不同","引入","2.0","rpc","实践","服务","系统","json","允许","pyparrot","¶","已","异步","代理","）","面板","提供","上启停","openbci","zeromq","插件","使用","解决方案"," ","安全","与","到","roadmap","代理服务","3.0","重构","最佳","发布"],"title":"路线图(Roadmap)","title_tokens":["(","roadmap","路线图","路线","线图",")"]},{"location":"about/roadmap/#roadmap","text":"","text_tokens":[],"title":"路线图（Roadmap）","title_tokens":["）","roadmap","路线图","（","路线","线图"]},{"location":"about/roadmap/#20-end","text":"移动端支持 已完成： codelab-adapter 的移动端解决方案 允许在 GUI 面板上启停插件 已完成 本地 SSL 安全证书 已完成 引入 json-rpc 已完成 替代 Scratch Link，实现 Scratch Link 的蓝牙代理服务 分析 scratch 3.0 与 micro:bit 的通信 故事与课程 使用物联网和 AI 增强表现力 重构插件系统，使用协程 发布不同平台的安装包 接入 openBCI 接入眼动仪 已完成 接入 Parrot pyparrot 已完成 在前端启停软件 json-rpc 异步实现 提供更好用的通信机制（包装 zeromq 到 utils），作为最佳实践","text_tokens":["的","前端","安装","分析","表现力","parrot","眼动仪","课程","软件","（","bit","用","证书","端","蓝牙","平台","scratch","通信","故事","替代","codelab","移动","作为","adapter","启停","接入","-","本地","utils",":","在","实现","ai","机制","物","和","增强","ssl","更好","link","安装包","解决","支持","联网","协程","方案","gui","包装","micro","：","，","完成","表现","不同","引入","rpc","实践","服务","系统","json","允许","pyparrot","已","异步","代理","）","面板","提供","上启停","openbci","zeromq","插件","使用","解决方案"," ","安全","与","到","代理服务","3.0","重构","最佳","发布"],"title":"2.0 (end)","title_tokens":["2.0","("," ","end",")"]},{"location":"about/roadmap/#30","text":"","text_tokens":[],"title":"3.0","title_tokens":["3.0"]},{"location":"about/value/","text":"我们的价值观 ( English ) ¶ 如果你想走得快，一个人走; 如果你想走得远，一群人走 我们不想做一个封闭的系统，为某一款或几款硬件，做一个定制化的解决方案，然后去兜售它，并宣称我们是最好的解决方案。 我们相信创意来自广泛的连接和分享。如果某一天在这个领域出现了一些振奋人心的东西，我相信它会首先出现在社区。 我们喜欢Scratch积木化的界面，喜欢它的口号 Imagine, Program, Share 我们喜欢media lab提出的4P方法: 项目（Projects）、同伴（Peers）、热情（Passion）、玩耍（Play） 我们想让Scratch3.0能连接到更广阔的世界,以便让参与项目的你也能与这个现实世界建立广泛的连接，而不只是生活在虚拟的空间中。我们希望你将编程创造的东西，用到日常中，给大家带来欢乐和惊喜。我们想把任何有趣的东西接入进来，以便打造 更宽的围墙和更高的天花板 ，当然，也包括接入你童年的那辆玩具四驱车 我们想为你打造一个\"绿洲\"，我们想 创造出一个不可思议的、美丽的、夺人心魄的场所,在那里人们可以漫步,可以梦想,历经很多世纪生生不息 但遗憾的是我们没有这个能力，我们最终只是打造一个通用的插件系统，而把更多的可能性留给了你自己，我们希望你能参与进来一起来改进它。这意味着如果你想连接你喜欢的东西，你不能坐着等我们来帮你。不过我们将尽最大努力给你提供一个好用的工具 学习是必须亲力亲为的，教育则是外界加诸你身上的 你需要自己动起手来,去创造你所向往的东西。 这和生活不是很像么？ 世界如果存在什么边界的话，可能只有想象力 有趣的东西现在还不多，在这个领域，除了富有远见的Jean Piaget、Alan Curtis Kay、Seymour Papert和Mitchel Resnick曾做过令人振奋的探索。当前的很多项目，说实话，让人有点瞌睡 我们想与你，以及广阔的社区(我们正在构建它)，一起动起手来做些真正令人振奋的东西 Just for fun :) Our Values ¶ If you want to go quickly, go alone. If you want to go far, go together. We don't want to do something like this: build a closed system, make it customized for a couple of hardware, then peddle it and declare it as our best solution. We believe creativity comes from broad connections and sharing. If something truly exciting comes out, we believe it must appear in our community at first place. We are fond of Scratch's block-like interface and its idea: Imagine, Program, Share We also like the vision of Media Lab for learning: Projects, Passion, Peers, and Play. We are trying to make Scratch 3.0 connect to a bigger world, which would make it easier for the creators(that's you!) to connect with our real world, not just within the virtual space. We hope the things you create will bring a ton of surprise and joy to your family and friends. To build a broader wall and a higher ceiling, we want to bring in every interesting things we found, which includes your Mini-4WD from childhood for sure. We want to create a oasis for you, That one day, somewhere, somehow, we shall build one building which is wonderful, beautiful, breathtaking, a place where people can walk and dream for centuries. Unfortunately, we don't have that power yet. We will eventually build a general plug-in system, and leave more space and possibility for you. We hope you to join us and improve it. This means, if you want the system connect to something you like, you cannot just sit around wait for us to help build it. Instead, we will try out best to provide you some great tools and utilities. Education is what people do to you. Learning is what you do to yourself. To create something promising, you have to get your hands dirty. Isn't it just like our life? The only boundary that our world might have, is our imagination. Except those exceptional work from visionary Jean Piaget, Alan Curtis Kay, Seymour Papert and Mitchel Resnick, there're not many interesting things in this area yet. To be honest, a lot of current projects are kind of boring. That's why we want you, along with the promising community that we are building, to do some great things together. Just for fun!","text_tokens":[",","的","eventually","那里","一个","interesting","shall","除了","believe","help","dream","做","有点","projects","工具","learning","进来","什么","加诸","童年","scratch","遗憾","需要","best","can","为","along","don","want","历经","让","梦想","-","手来","在","人心","曾","media","exciting","走得快","改进","创意","fun","来自","of","世界","围墙","瞌睡","those","任何","play","real","many","最终","以便","great","!","peddle","并","beautiful","走","boundary","绿洲","work","构建","方法","分享","这","玩具","等","把","jean","then","¶","而","欢乐","a","community","at","一","truly","出现","插件","re","生活","解决方案","do","day","power","四驱车","are","promising"," ","但","价值观","just","you","this","except","customized","到","场所","that","if","which","includes","的话","visionary","scratch3.0","closed","something","breathtaking","所","curtis","不息","天花板","ceiling","探索","几款","化","想象","solution","sure","imagine","天花","惊喜","意味着","as","boring","wonderful","t",".","first","where","说实话","for","and","令人振奋","peers","we","provide","领域","hardware","可能","every","努力","lab","it","try","4wd","硬件","create","sharing",")","富有","instead","来","resnick","想","us","坐","解决","area","、","plug","那辆","日常","fond","leave","一天","sit","出","comes","方案","着","。","很多","东西","place","生生不息","向往","creators","定制","用到","某","share","参与","只有","only","价值","振奋","夺人","unfortunately","kind","项目","）","提供","yourself","utilities","current","帮","also","bigger","与","广阔","一些","oasis","远","包括","尽","能力","hands","would","(","mitchel","go","可以","connections","childhood","wait","玩耍","如果","我","现在","declare","心魄","hope","honest","一起","kay","一款","higher","广泛","our","build","虚拟","令人","接入",":","papert","动起","没有","还","不是","大家","your","和","生生","可能性","将","存在","dirty","from","cannot","中","首先","?","program","建立","have","人们","远见","isn","values","得","给","to","宽","做些","means","同伴","不能","漫步","？","美丽","振奋人心","系统","friends","building","很","不过","like","out","正在","意味","身上","边界","bring","界面","热情","connect","积木","in","更","will","education","what","alone","提出","编程","wall","能","joy","must","there","这个","walk","improve","possibility","block","学习","思议","within","么","its","with","你","around","通用","封闭","实话","some","我们","打造","passion","（","system","'","社区","broad","imagination","lot","不可","make","去","只是","了","它会","piaget","centuries","外界","留给","seymour","people","why","\"","more","或","s","broader","不想","带来","真正","get","far","alan","world","join","自己","必须","宣称","yet","当前","exceptional","mini","相信","trying","be","当然","might","然后","quickly","tools","不可思议","interface","亲力亲为","found","人","教育",";","也","，","现实","希望","连接","创造","not","起来","together","多","space","somewhere","english","family","easier","以及","ton","things","则","appear","口号","空间","好用","想象力","兜售","idea","vision","像","one","一群","世纪","喜欢","4p","最大","life","virtual","高","它","the","不","creativity","general","是","couple","最好","有趣","过","somehow","3.0","surprise","is","驱车"],"title":"价值观(value)","title_tokens":["价值观","(","价值",")","value"]},{"location":"about/value/#english","text":"如果你想走得快，一个人走; 如果你想走得远，一群人走 我们不想做一个封闭的系统，为某一款或几款硬件，做一个定制化的解决方案，然后去兜售它，并宣称我们是最好的解决方案。 我们相信创意来自广泛的连接和分享。如果某一天在这个领域出现了一些振奋人心的东西，我相信它会首先出现在社区。 我们喜欢Scratch积木化的界面，喜欢它的口号 Imagine, Program, Share 我们喜欢media lab提出的4P方法: 项目（Projects）、同伴（Peers）、热情（Passion）、玩耍（Play） 我们想让Scratch3.0能连接到更广阔的世界,以便让参与项目的你也能与这个现实世界建立广泛的连接，而不只是生活在虚拟的空间中。我们希望你将编程创造的东西，用到日常中，给大家带来欢乐和惊喜。我们想把任何有趣的东西接入进来，以便打造 更宽的围墙和更高的天花板 ，当然，也包括接入你童年的那辆玩具四驱车 我们想为你打造一个\"绿洲\"，我们想 创造出一个不可思议的、美丽的、夺人心魄的场所,在那里人们可以漫步,可以梦想,历经很多世纪生生不息 但遗憾的是我们没有这个能力，我们最终只是打造一个通用的插件系统，而把更多的可能性留给了你自己，我们希望你能参与进来一起来改进它。这意味着如果你想连接你喜欢的东西，你不能坐着等我们来帮你。不过我们将尽最大努力给你提供一个好用的工具 学习是必须亲力亲为的，教育则是外界加诸你身上的 你需要自己动起手来,去创造你所向往的东西。 这和生活不是很像么？ 世界如果存在什么边界的话，可能只有想象力 有趣的东西现在还不多，在这个领域，除了富有远见的Jean Piaget、Alan Curtis Kay、Seymour Papert和Mitchel Resnick曾做过令人振奋的探索。当前的很多项目，说实话，让人有点瞌睡 我们想与你，以及广阔的社区(我们正在构建它)，一起动起手来做些真正令人振奋的东西 Just for fun :)","text_tokens":[",","的","(","mitchel","所","那里","一个","可以","curtis","你","玩耍","封闭","不息","天花板","通用","实话","除了","如果","我","探索","现在","我们","打造","几款","心魄","passion","化","（","想象","做","有点","projects","imagine","天花","惊喜","意味着","kay","社区","一起","工具","进来","一款","什么","加诸","童年","scratch","不可","广泛","遗憾","需要","为","去","只是","虚拟","说实话","了","for","令人","它会","令人振奋","piaget","历经","peers","接入","领域","让","梦想","外界","留给","可能","seymour",":","在","人心","手来","papert","曾","动起","\"","没有","努力","或","media","lab","还","走得快","改进","创意","不是","大家","fun","来自","不想","硬件","带来","世界","和","真正",")","围墙","瞌睡","生生","可能性","alan","任何","富有","将","自己","来","宣称","必须","存在","resnick","当前","中","想","play","相信","坐","解决","、","首先","当然","然后","那辆","日常","一天","不可思议","最终","以便","program","建立","出","亲力亲为","方案","人们","并","远见","走","着","。","很多","人","东西","教育",";","生生不息","也","得","给","，","现实","向往","希望","绿洲","定制","用到","某","连接","宽","创造","构建","做些","share","同伴","不能","起来","方法","分享","漫步","这","美丽","多","参与","玩具","等","振奋人心","？","把","系统","振奋","只有","夺人","jean","很","以及","而","不过","则","欢乐","项目","口号","）","空间","好用","正在","意味","想象力","提供","身上","边界","界面","兜售","热情","像","一","一群","世纪","出现","喜欢","插件","生活","积木","解决方案","4p","更","帮","最大","四驱车"," ","高","它","但","提出","编程","能","与","这个","广阔","just","不","一些","是","到","场所","最好","远","有趣","的话","过","包括","尽","scratch3.0","学习","思议","能力","驱车","么"],"title":"我们的价值观 (English)","title_tokens":["价值观","的","我们","("," ","价值",")","english"]},{"location":"about/value/#our-values","text":"If you want to go quickly, go alone. If you want to go far, go together. We don't want to do something like this: build a closed system, make it customized for a couple of hardware, then peddle it and declare it as our best solution. We believe creativity comes from broad connections and sharing. If something truly exciting comes out, we believe it must appear in our community at first place. We are fond of Scratch's block-like interface and its idea: Imagine, Program, Share We also like the vision of Media Lab for learning: Projects, Passion, Peers, and Play. We are trying to make Scratch 3.0 connect to a bigger world, which would make it easier for the creators(that's you!) to connect with our real world, not just within the virtual space. We hope the things you create will bring a ton of surprise and joy to your family and friends. To build a broader wall and a higher ceiling, we want to bring in every interesting things we found, which includes your Mini-4WD from childhood for sure. We want to create a oasis for you, That one day, somewhere, somehow, we shall build one building which is wonderful, beautiful, breathtaking, a place where people can walk and dream for centuries. Unfortunately, we don't have that power yet. We will eventually build a general plug-in system, and leave more space and possibility for you. We hope you to join us and improve it. This means, if you want the system connect to something you like, you cannot just sit around wait for us to help build it. Instead, we will try out best to provide you some great tools and utilities. Education is what people do to you. Learning is what you do to yourself. To create something promising, you have to get your hands dirty. Isn't it just like our life? The only boundary that our world might have, is our imagination. Except those exceptional work from visionary Jean Piaget, Alan Curtis Kay, Seymour Papert and Mitchel Resnick, there're not many interesting things in this area yet. To be honest, a lot of current projects are kind of boring. That's why we want you, along with the promising community that we are building, to do some great things together. Just for fun!","text_tokens":[",","something","would","breathtaking","connections","(","go","eventually","mitchel","childhood","curtis","with","interesting","around","wait","shall","ceiling","some","declare","passion","hope","system","believe","help","solution","dream","honest","'","sure","projects","imagine","kay","as","broad","learning","imagination","higher","lot","boring","scratch","best","make","t",".","our","build","first","wonderful","where","can","don","for","and","along","want","piaget","we","peers","centuries","provide","-","hardware","every","seymour",":","papert","people","why","more","media","s","lab","it","exciting","broader","try","4wd","fun","create","your","of","sharing",")","get","far","those","alan","world","join","instead","yet","dirty","exceptional","resnick","from","mini","cannot","play","real","us","trying","area","be","might","plug","?","quickly","fond","leave","sit","tools","interface","many","program","great","found","!","comes","have","peddle","beautiful","isn","place","boundary","except","creators","to","work","not","means","share","together","friends","only","space","somewhere","building","jean","then","family","unfortunately","easier","ton","things","kind","appear","a","out","like","community","bring","yourself","utilities","at","idea","vision","connect","one","current","truly","re","in","do","will","day","education","power","what","are","also"," ","promising","life","virtual","alone","wall","bigger","joy","must","there","walk","just","you","this","creativity","the","general","improve","customized","possibility","that","oasis","if","block","which","couple","includes","somehow","visionary","3.0","closed","surprise","is","within","its","hands"],"title":"Our Values","title_tokens":["values","our"," "]},{"location":"about/why/","text":"Why ¶ Just for fun :) 以及： 如果我们不去做，这些值得去做的事情，短期内似乎不会发生。 如果没有你的加入，我们成功的机会便很渺茫。","text_tokens":["的","加入","便",":","短期内","事情","你","why","机会","没有","。","：","如果","不去","我们","，","fun","不会"," ","成功","做",")","发生","just","期内","这些","短期","很","渺茫","去","for","¶","以及","似乎","值得"],"title":"why","title_tokens":["why"]},{"location":"about/why/#why","text":"Just for fun :) 以及： 如果我们不去做，这些值得去做的事情，短期内似乎不会发生。 如果没有你的加入，我们成功的机会便很渺茫。","text_tokens":["的","加入","便",":","短期内","事情","你","机会","没有","。","：","如果","不去","我们","，","fun","不会"," ","成功","做",")","发生","just","期内","这些","短期","很","渺茫","去","for","以及","似乎","值得"],"title":"Why","title_tokens":["why"]},{"location":"dev_guide/Adapter-Node/","text":"Adapter Node ¶ 在上一节： hello world(Adapter Extension) 中我们学会了如何自定义一个 extension。 extension 有如下的限制： 必须放置在插件目录中（ ~/codelab_adapter/extensions ）。 只能使用 CodeLab Adapter 已打包的第三方库 。 如果你想使用 Python 社区海量的第三方库：诸如 Pygame 、 PyQt 、 PyTorch 、 flask ... extension 就办不到了，但 Adapter Node 可以！ ps: 如果你只是想把外部系统接入Adapter，也可以参考更为简单的: 与外部系统通信 提醒 实际上 Adapter Extension 是 AdapterNode 的子类. 我们希望 CodeLab Adapter 专注于连接万物，所以构建了 Adapter Node，允许你在任何地方创建 CodeLab Adapter 的扩展，允许你使用任何 Python 库，无论你准备构建游戏、构建网站、构建深度学习应用还是构建一个机器人！ Adapter Node 是什么 ¶ Adapter Node 只是普通的 Python 程序，继承自 AdapterNode 。 第一个 Adapter Node ¶ 我们开始写第一个 Adapter Node。 你需要完成这些前置工作： 安装了 Python3( >=3.6 ) pip3 install codelab_adapter_client --upgrade 接着可以随便在什么地方创建一个 Python 文件，随便给它起个名字，诸如 my_first_adapter_node.py ： 我们让这个 Node 的功能与 hello world 里我们自定义的插件功能相同：反转字符串 import time from loguru import logger from codelab_adapter_client import AdapterNode class EIMNode ( AdapterNode ): NODE_ID = \"eim\" DESCRIPTION = \"Everything Is a Message\" HELP_URL = \"https://adapter.codelab.club/extension_guide/eim/\" def __init__ ( self ): super () . __init__ () def send_message_to_scratch ( self , content ): message = self . message_template () message [ \"payload\" ][ \"content\" ] = content self . publish ( message ) def extension_message_handle ( self , topic , payload ): self . logger . info ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转字符串 self . send_message_to_scratch ( content_send_to_scratch ) def run ( self ): while self . _running : time . sleep ( 1 ) if __name__ == \"__main__\" : try : node = EIMNode () node . receive_loop_as_thread () node . run () except KeyboardInterrupt : node . terminate () # Clean up before exiting. 运行 ¶ 打开 CodeLab Adapter（不需要选择插件），将 CodeLab Adapter 作为消息中心。 运行 my_first_adapter_node.py： python3 my_first_adapter_node.py 让我们在 CodeLab Scratch3 中尝试一下反转字符串： 成功！ 它只是普通的 Python 程序，使用你本地的 Python 环境，所以你现在可以任何你偏爱的Python库来增强 Scratch3 啦！ GUI ¶ 有开发者在邮件中提到： tkinter、PyQt 都有一个主循环，Adapter Node 也有一个主循环，怎么才能共存呢？ Adapter Node 可以与任何 GUI 框架共存 if __name__ == \"__main__\": try: node = EIMNode() node.receive_loop_as_thread() node.run() except KeyboardInterrupt: node.terminate() # Clean up before exiting. 其中 node.run() 不是必要的，只是为了阻塞程序，使其不立刻结束，如果 GUI 框架本身已经有主循环，则可以移除 node.run() ， node.receive_loop_as_thread() 是非阻塞的。 以下是示范例子： from tkinter import * # AdapterNode from loguru import logger from codelab_adapter_client import AdapterNode class EIMNode ( AdapterNode ): NODE_ID = \"eim\" def __init__ ( self ): super () . __init__ () def send_message_to_scratch ( self , content ): message = self . message_template () message [ \"payload\" ][ \"content\" ] = content self . publish ( message ) def extension_message_handle ( self , topic , payload ): self . logger . info ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转字符串 self . send_message_to_scratch ( content_send_to_scratch ) node = EIMNode () node . receive_loop_as_thread () # tkinter window = Tk () window . title ( \"Adapter Node & tkinter\" ) window . geometry ( '300x100' ) lbl = Label ( window , text = \"click to send message\" ) lbl . grid ( column = 0 , row = 0 ) i = 1 def clicked (): global i message = node . message_template () message [ \"payload\" ][ \"content\" ] = \"click_{}\" . format ( i ) node . publish ( message ) i += 1 btn = Button ( window , text = \"emit\" , command = clicked ) btn . grid ( column = 1 , row = 0 ) window . mainloop () 该 node 接收来自 Scratch EIM 的消息，并逆转字符串；当用户点击按钮时，给 Scratch 发送消息： click_<NUMBER> 想象空间 ¶ 如果你希望构建分布式的应用，诸如构建密室逃脱中的各种机关。只需要 做一下配置就行 ，让 CodeLab Adapter 接受分布式的请求。 你可以将 Adapter Node 跑在任何地方，来增强 CodeLab Adapter 的能力，无论是本地、云端还是分布式节点。 我们也正在构建其他语言的 client，你不会被限制在 Python 中，而是可以在任何编程语言任何平台上构建 Adapter Node。 参考： 编程语言支持 更多例子 ¶ blender ：这是个实际的案例，演示如何使用 AdapterNode 基础类粘合不同软件，将其变为 Adapter Node。 examples node_v3","text_tokens":[",","的","一个","上","为了","布式","开发","1","help","做","terminate","pytorch","click","什么","command","需要","通信","scratch","随便","作为","限制","3.6","接着","pyqt","已经","让","-","在","机器人","请求","geometry","来自","extension","第一","被","有主","任何","目录","机关","游戏","thread","起个","当","eim","发送","工作","flask","并","handle","<","深度","description","不同","构建","这","基础","！","把","如下","接受","¶","而是","已","super","examples","主","a","自","插件","running","="," ","循环","但","实际上","adapternode","loguru","except","节点","if","tkinter","clicked","第三方","template","扩展","接收","其","跑","f","简单","软件","提到","想象","club","as","办不到","import","逆转","]",".","first","publish","怎么","第三","+","机器","本身","点击","exiting","偏爱","try","global","number","i",")","content","普通","增强","up","来","按钮","想","guide","btn","lbl","演示","、","案例","配置","format","密室","支持","提醒","其中","str","}","tk","。","框架","init","打开","库","不会","万物","hello","分布式","scratch3","示范","无论","第一个","开始","message","extensions","以下","该","python3","有","还是","打包","client","）","{","text","库来","开发者","一节","程序","反转","字符串","loop","class","eimnode","[","info","只能","相同","个","与","type","everything","消息","能力","选择","创建","(","用户","可以","应用","呢","title","如果","现在","mainloop","功能","blender","无论是","这些","接入","py",":","https","不到","column","install","就行","run","不是","各种","语言","参考","成功","文件","诸如","pip3","__","/","自定","三方","将","python","_","from","中","名字","id","只","逃脱","topic","例子","：","0","前置","给","button","grid","v3","to","分布","粘合","label","？","运行","row","系统","time","子类","允许","才能","使","main","字符","while","url","upgrade","正在","学会","里","receive","是非","node","更","共存","编程","结束","这个","环境","ps","云端","阻塞","name","学习","payload","时","安装","clean","所以","你","继承","before","我们","就","自定义",">","（","send","'","于","社区","；","keyboardinterrupt","平台","放置","codelab","只是","emit","adapter","了","网站","移除","本地","~","\"","self","必要","变为","编程语言","logger","一下","类","地方","world","必须","专注","立刻","...","window","啦","*","外部","如何","尝试","gui","也","，","希望","完成","#","300x100","连接","定义","多","其他","邮件","则","写","空间","sleep","&","海量","使用","实际","pygame","准备","它","def","中心","都","the","不","更为","是","my","is"],"title":"Adapter Node","title_tokens":["adapter"," ","node"]},{"location":"dev_guide/Adapter-Node/#adapter-node","text":"在上一节： hello world(Adapter Extension) 中我们学会了如何自定义一个 extension。 extension 有如下的限制： 必须放置在插件目录中（ ~/codelab_adapter/extensions ）。 只能使用 CodeLab Adapter 已打包的第三方库 。 如果你想使用 Python 社区海量的第三方库：诸如 Pygame 、 PyQt 、 PyTorch 、 flask ... extension 就办不到了，但 Adapter Node 可以！ ps: 如果你只是想把外部系统接入Adapter，也可以参考更为简单的: 与外部系统通信 提醒 实际上 Adapter Extension 是 AdapterNode 的子类. 我们希望 CodeLab Adapter 专注于连接万物，所以构建了 Adapter Node，允许你在任何地方创建 CodeLab Adapter 的扩展，允许你使用任何 Python 库，无论你准备构建游戏、构建网站、构建深度学习应用还是构建一个机器人！","text_tokens":["的","(","扩展","可以","一个","所以","应用","上","你","如果","我们","简单","自定义","就","（","pytorch","于","社区","办不到","通信","放置",".","codelab","只是","adapter","了","限制","网站","第三","机器","接入","pyqt",":","在","机器人","~","不到","extension","参考","诸如",")","地方","/","world","自定","三方","任何","必须","目录","python","_","中","想","专注","、","游戏","...","提醒","flask","外部","如何","。","：","深度","库","也","，","希望","hello","万物","连接","构建","无论","定义","extensions","！","把","如下","系统","子类","有","允许","还是","已","打包","）","学会","一节","插件","海量","使用","实际","pygame","node","只能","准备"," ","但","实际上","adapternode","与","更为","是","ps","学习","第三方","创建"],"title":"Adapter Node","title_tokens":["adapter"," ","node"]},{"location":"dev_guide/Adapter-Node/#adapter-node_1","text":"Adapter Node 只是普通的 Python 程序，继承自 AdapterNode 。","text_tokens":["普通","的","只是","，","adapternode","adapter","node","程序","python"," ","。","自","继承"],"title":"Adapter Node 是什么","title_tokens":["adapter","node"," ","什么","是"]},{"location":"dev_guide/Adapter-Node/#adapter-node_2","text":"我们开始写第一个 Adapter Node。 你需要完成这些前置工作： 安装了 Python3( >=3.6 ) pip3 install codelab_adapter_client --upgrade 接着可以随便在什么地方创建一个 Python 文件，随便给它起个名字，诸如 my_first_adapter_node.py ： 我们让这个 Node 的功能与 hello world 里我们自定义的插件功能相同：反转字符串 import time from loguru import logger from codelab_adapter_client import AdapterNode class EIMNode ( AdapterNode ): NODE_ID = \"eim\" DESCRIPTION = \"Everything Is a Message\" HELP_URL = \"https://adapter.codelab.club/extension_guide/eim/\" def __init__ ( self ): super () . __init__ () def send_message_to_scratch ( self , content ): message = self . message_template () message [ \"payload\" ][ \"content\" ] = content self . publish ( message ) def extension_message_handle ( self , topic , payload ): self . logger . info ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转字符串 self . send_message_to_scratch ( content_send_to_scratch ) def run ( self ): while self . _running : time . sleep ( 1 ) if __name__ == \"__main__\" : try : node = EIMNode () node . receive_loop_as_thread () node . run () except KeyboardInterrupt : node . terminate () # Clean up before exiting.","text_tokens":[",","的","template","(","安装","一个","可以","clean","你","before","f","1","我们","自定义",">","send","help","club","'","terminate","as","功能","import","keyboardinterrupt","什么","]","这些","需要","scratch",".","first","publish","随便","codelab","adapter","了","3.6","接着","让","-","py",":","在","https","exiting","\"","install","run","try","self","logger","extension","第一","文件","诸如",")","content","pip3","地方","__","/","world","自定","up","python","_","from","guide","名字","id","thread","起个","eim","工作","str","}","handle","topic","。","：","init","前置","给","，","完成","hello","to","#","description","第一个","开始","定义","message","time","python3","字符","super","while","写","client","a","url","main","upgrade","{","里","反转","sleep","receive","字符串","loop","class","eimnode","[","插件","info","running","=","node"," ","相同","它","def","loguru","adapternode","与","type","这个","the","except","everything","my","if","name","payload","is","创建"],"title":"第一个 Adapter Node","title_tokens":["adapter","一个","node","第一"," ","第一个"]},{"location":"dev_guide/Adapter-Node/#_1","text":"打开 CodeLab Adapter（不需要选择插件），将 CodeLab Adapter 作为消息中心。 运行 my_first_adapter_node.py： python3 my_first_adapter_node.py 让我们在 CodeLab Scratch3 中尝试一下反转字符串： 成功！ 它只是普通的 Python 程序，使用你本地的 Python 环境，所以你现在可以任何你偏爱的Python库来增强 Scratch3 啦！","text_tokens":["库来","让","的","本地","py","可以","所以","在","程序","反转","尝试","你","字符串","。","：","偏爱","打开","现在","插件","我们","使用","，","（","node","一下","scratch3"," ","成功","它","普通","增强","任何","将","运行","python","中心","_","不","中","！","需要","python3","环境","my",".","first","codelab","只是","作为","adapter","消息","字符","选择","啦","）"],"title":"运行","title_tokens":["运行"]},{"location":"dev_guide/Adapter-Node/#gui","text":"有开发者在邮件中提到： tkinter、PyQt 都有一个主循环，Adapter Node 也有一个主循环，怎么才能共存呢？ Adapter Node 可以与任何 GUI 框架共存 if __name__ == \"__main__\": try: node = EIMNode() node.receive_loop_as_thread() node.run() except KeyboardInterrupt: node.terminate() # Clean up before exiting. 其中 node.run() 不是必要的，只是为了阻塞程序，使其不立刻结束，如果 GUI 框架本身已经有主循环，则可以移除 node.run() ， node.receive_loop_as_thread() 是非阻塞的。 以下是示范例子： from tkinter import * # AdapterNode from loguru import logger from codelab_adapter_client import AdapterNode class EIMNode ( AdapterNode ): NODE_ID = \"eim\" def __init__ ( self ): super () . __init__ () def send_message_to_scratch ( self , content ): message = self . message_template () message [ \"payload\" ][ \"content\" ] = content self . publish ( message ) def extension_message_handle ( self , topic , payload ): self . logger . info ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转字符串 self . send_message_to_scratch ( content_send_to_scratch ) node = EIMNode () node . receive_loop_as_thread () # tkinter window = Tk () window . title ( \"Adapter Node & tkinter\" ) window . geometry ( '300x100' ) lbl = Label ( window , text = \"click to send message\" ) lbl . grid ( column = 0 , row = 0 ) i = 1 def clicked (): global i message = node . message_template () message [ \"payload\" ][ \"content\" ] = \"click_{}\" . format ( i ) node . publish ( message ) i += 1 btn = Button ( window , text = \"emit\" , command = clicked ) btn . grid ( column = 1 , row = 0 ) window . mainloop () 该 node 接收来自 Scratch EIM 的消息，并逆转字符串；当用户点击按钮时，给 Scratch 发送消息： click_<NUMBER>","text_tokens":[",","的","template","(","接收","用户","可以","一个","clean","时","为了","呢","开发","其","title","如果","before","f","1",">","send","提到","mainloop","'","terminate","as","；","import","逆转","keyboardinterrupt","click","]","command","scratch",".","publish","codelab","只是","emit","怎么","adapter","+","本身","移除","点击","pyqt","已经","-",":","在","geometry","exiting","column","\"","run","try","不是","必要","self","global","来自","logger","extension","number","有主",")","content","i","__","任何","up","_","from","按钮","中","立刻","btn","lbl","、","id","thread","format","当","eim","window","发送","其中","str","*","}","tk","并","handle","topic","<","gui","例子","框架","：","。","0","init","也","给","，","button","grid","#","to","300x100","示范","label","message","？","row","以下","该","有","才能","使","邮件","main","则","主","super","client","字符","{","text","开发者","程序","receive","反转","&","字符串","loop","class","eimnode","[","info","=","node","是非"," ","循环","共存","def","结束","adapternode","loguru","与","type","都","except","不","the","是","if","tkinter","阻塞","name","消息","payload","clicked"],"title":"GUI","title_tokens":["gui"]},{"location":"dev_guide/Adapter-Node/#_2","text":"如果你希望构建分布式的应用，诸如构建密室逃脱中的各种机关。只需要 做一下配置就行 ，让 CodeLab Adapter 接受分布式的请求。 你可以将 Adapter Node 跑在任何地方，来增强 CodeLab Adapter 的能力，无论是本地、云端还是分布式节点。 我们也正在构建其他语言的 client，你不会被限制在 Python 中，而是可以在任何编程语言任何平台上构建 Adapter Node。 参考： 编程语言支持","text_tokens":["让","正在","的","本地","应用","可以","在","上","请求","你","布式","。","：","就行","如果","跑","我们","各种","也","，","语言","不会","编程语言","node","希望","一下","分布式","分布","参考"," ","做","诸如","构建","被","无论","编程","地方","增强","任何","将","来","机关","python","节点","中","无论是","平台","需要","接受","codelab","、","云端","配置","adapter","还是","限制","其他","而是","密室","只","支持","能力","client","逃脱"],"title":"想象空间","title_tokens":["空间","想象"]},{"location":"dev_guide/Adapter-Node/#_3","text":"blender ：这是个实际的案例，演示如何使用 AdapterNode 基础类粘合不同软件，将其变为 Adapter Node。 examples node_v3","text_tokens":["的","如何","。","：","其","变为","使用","，","软件","实际","node","v3"," ","粘合","类","不同","个","adapternode","将","这","_","blender","基础","是","演示","案例","adapter","examples"],"title":"更多例子","title_tokens":["更","例子","多"]},{"location":"dev_guide/Architecture/","text":"Architecture ¶ 更多架构细节参考： 为 Scratch 3.0 设计的插件系统（下篇）","text_tokens":["架构","的","：","插件","下篇","更","（","参考","细节"," ","多","系统","设计","scratch","为","¶","3.0","）","architecture"],"title":"架构(Architecture)","title_tokens":["架构",")","architecture","("]},{"location":"dev_guide/Architecture/#architecture","text":"更多架构细节参考： 为 Scratch 3.0 设计的插件系统（下篇）","text_tokens":["架构","为","的","插件","下篇","更","（","多","3.0","参考","细节"," ","设计","系统","：","）","scratch"],"title":"Architecture","title_tokens":["architecture"]},{"location":"dev_guide/FAQ/","text":"FAQ for Developer ¶ 编辑文档 ¶ 欢迎大家来协同编辑文档： codelab-adapter-docs 。 讨论组 ¶ 陆续有开发者建议我构建论坛（discourse）和微信群方便大家讨论技术问题。 微信群无法沉淀有价值的内容，搜索功能太烂了，对富文本/markdown 的支持几近于无，微信不是好的办公工具。 与 CodeLab Adapter 相关技术问题，大家可以在 issue 里讨论。 也可以在 CodeLab Adapter 讨论组 里讨论。 插件启停 ¶ 目前，插件启动为线程。Python 线程需要 手动管理 ，这部分的代码目前还比较粗糙。为了允许用户在 UI 中通过勾选来启停插件。建议插件作者使用 while self._running: ，参考 extension_eim 。 在 1.0 版本发布之前，插件部分我们将迁往协程，如此一来我们就能轻易管理插件的启停。目前 Python 社区很多库还不支持协程，所以我们不打算立刻迁移。 引入第三方 Python 库 ¶ 内置的第三方库参考： wiki 。 如果你需要引入新的第三方库（如OpenCV），需要在本地安装有 Python3，可以参考： servers_v2 。 关于这个话题，我们日后会给出教程。 Python 与 Scratch 的双向通信 ¶ 参考 json message Python 与 Scratch 的双向通信 大多数情况下，你只需要发送和接受字符串就够了，这种风格与 Scratch 内置的广播极为相近。是典型的事件驱动风格。 这篇教程主要针对那些希望去拓展 Scratch 的人。当你需要将一些复杂的程序接入 Scratch（例如接入 AI 或者接入微信，如我们制作的例子），它会对你有帮助。 如何接入 Arduino ¶ 陆续有开发者问到，如何使用 CodeLab Adapter 将 Arduino 接入到 Scratch 3.0 中。 有许多种方法，但我比较偏好在 Arduino 中烧入 Firmata 固件。之后以固件交互，我在 两种硬件编程风格的比较 论述了这样做的好处。 之后使用 Firmata python client 与 Arduino 交互。 细节可以参考 Arduino 与 Scratch 3.0 。 支持哪些平台 ¶ 首先区分 CodeLab Adapter 和 CodeLab Adapter Node。 CodeLab Adapter 既是消息中心，又是UI程序，CodeLab Adapter 可以运行在： Windows（win7/win8/win10） Mac linux Ubuntu Raspbian Android CodeLab Adapter Node 可以运行在任何平台上，包括单片机。 覆盖配置文件 ¶ 为了方便开发者将 CodeLab Adapter 整合到其他软件中，作为服务使用，诸如整合到 Scratch Desktop ，或者整合到 docker 容器内，作为局域网消息服务…… CodeLab Adapter 允许以 命令行方式启动（没有GUI） 。 为了方便软件的二次分发和自定义，CodeLab Adapter 允许开发者覆盖用户配置文件( user_settings.py )，进而对 CodeLab Adapter 做初始化配置。 只需要将自定义的 user_settings.py 放在 CodeLab Adapter 同级目录中即可。 如何集成到 Electron ¶ 只需要集成 scratch3_eim 即可。 如果你想使用 socketio client 连接与 Adapter 沟通，参考 此处源码 。 Scratch里的小绿点是怎么实现的？ ¶ Scratch里的小绿点用于反应网页与Adapter的连通性, 小绿点的状态由 AdapterBaseClient connected 属性 决定。它属于 scratch-gui，而不属于scratch extension，这部分你需要自己实现。","text_tokens":[",","的","为了","又","上","开发","典型","分发","内置","事件驱动","做","settings","工具","固件","相关","制作","需要","scratch","通信","编辑","为","作为","新","哪些","ubuntu","即可","-","在","打算","区分","微信","extension","…","就够","搜索","任何","作者","目录","轻易","对","粗糙","复杂","发送","eim","当","二次","陆续","arduino","如","属于","方式","win10","faq","或者","近于","构建","单片机","方法","初始","接受","命令","¶","而","相近","无","connected","插件","running"," ","情况","但","连通性","进而","好处","到","此处","帮助","话题","mac","偏好","desktop","双向","第三方","内","部分","软件","问题","关于","问","通性",".","启动","android","for","怎么","第三","论述","迁往","如此","硬件",")","来","想","单片","配置","raspbian","支持","markdown","多数","协程","建议","好","。","很多","库","opencv","论坛","scratch3","细节","状态","文本","win8","message","servers","价值","json","python3","有","比较","1.0","client","）","docker","开发者","程序","字符串","方便","决定","几近于","docs","讨论","对富","手动","与","代码","一些","给出","v2","消息","win7","包括","目前","容器","(","用户","可以","大多","我","如果","微信群","多种","连通","迁移","功能","反应","下","接入","这部","办公","py",":","局域","双向通信","没有","如此一来","还","不是","大家","之后","firmata","参考","文件","诸如","和","/","三方","自定","将","python","_","几近","中","其他软件","通过","首先","linux","只","整合","网页","socketio","用于","electron","集成","例子","文档","：","由","放在","事件","developer","教程","属性","？","运行","技术","服务","这部分","允许","交互","覆盖","while","字符","中烧入","欢迎","里","针对","之前","node","编程","能","命令行","windows","这个","编辑文档","源码","拓展","沟通","这样","安装","所以","你","线程","这种","我们","就","自定义","（","风格","._","社区","wiki","大多数","平台","去","codelab","adapter","了","启停","勾选来","它会","以","会","本地","内容","那些","实现","ai","主要","两种","一来","ui","self","极为","既","讨论组","自己","太烂","局域网","管理","立刻","配置文件","adapterbaseclient","例如","issue","许多","如何","gui","人","初始化","无法","也","日后","，","希望","连接","引入","定义","广播","驱动","协同","其他","版本","许多种","discourse","使用","同级","它","中心","不","user","是","这篇","小绿点","3.0","沉淀","发布"],"title":"FAQ","title_tokens":["faq"]},{"location":"dev_guide/FAQ/#faq-for-developer","text":"","text_tokens":[],"title":"FAQ for Developer","title_tokens":["for"," ","developer","faq"]},{"location":"dev_guide/FAQ/#_1","text":"欢迎大家来协同编辑文档： codelab-adapter-docs 。","text_tokens":["协同","-","codelab","大家","欢迎","adapter","来","docs","。"," ","编辑文档","文档","：","编辑"],"title":"编辑文档","title_tokens":["文档","编辑文档","编辑"]},{"location":"dev_guide/FAQ/#_2","text":"陆续有开发者建议我构建论坛（discourse）和微信群方便大家讨论技术问题。 微信群无法沉淀有价值的内容，搜索功能太烂了，对富文本/markdown 的支持几近于无，微信不是好的办公工具。 与 CodeLab Adapter 相关技术问题，大家可以在 issue 里讨论。 也可以在 CodeLab Adapter 讨论组 里讨论。","text_tokens":["的","开发者","内容","办公","可以","里","在","建议","方便","好","开发","。","无","几近于","discourse","我","无法","不是","也","大家","，","微信","（","论坛","讨论"," ","近于","构建","和","文本","问题","讨论组","微信群","搜索","对富","/","工具","与","技术","功能","太烂","几近","价值","相关","有","issue","codelab","了","adapter","沉淀","支持","markdown","）","陆续"],"title":"讨论组","title_tokens":["讨论","讨论组"]},{"location":"dev_guide/FAQ/#_3","text":"目前，插件启动为线程。Python 线程需要 手动管理 ，这部分的代码目前还比较粗糙。为了允许用户在 UI 中通过勾选来启停插件。建议插件作者使用 while self._running: ，参考 extension_eim 。 在 1.0 版本发布之前，插件部分我们将迁往协程，如此一来我们就能轻易管理插件的启停。目前 Python 社区很多库还不支持协程，所以我们不打算立刻迁移。","text_tokens":["这部","的","版本","协程","用户",":","在","所以","为了","迁往","建议","如此","。","部分","一来","线程","之前","如此一来","很多","还","打算","ui","插件","self","使用","，","我们","running","就","extension","库","参考"," ","._","能","社区","手动","将","作者","代码","python","_","迁移","不","中","管理","轻易","立刻","需要","这部分","通过","允许","启动","为","粗糙","比较","启停","勾选来","while","支持","1.0","eim","目前","发布"],"title":"插件启停","title_tokens":["插件","启停"]},{"location":"dev_guide/FAQ/#python","text":"内置的第三方库参考： wiki 。 如果你需要引入新的第三方库（如OpenCV），需要在本地安装有 Python3，可以参考： servers_v2 。 关于这个话题，我们日后会给出教程。","text_tokens":["的","本地","安装","可以","在","你","。","：","内置","如果","库","我们","日后","opencv","，","（","参考"," ","引入","关于","教程","三方","wiki","这个","servers","_","给出","需要","python3","有","v2","话题","第三","新","会","）","第三方","如"],"title":"引入第三方 Python 库","title_tokens":["库","三方","第三","python"," ","引入","第三方"]},{"location":"dev_guide/FAQ/#python-scratch","text":"参考 json message Python 与 Scratch 的双向通信 大多数情况下，你只需要发送和接受字符串就够了，这种风格与 Scratch 内置的广播极为相近。是典型的事件驱动风格。 这篇教程主要针对那些希望去拓展 Scratch 的人。当你需要将一些复杂的程序接入 Scratch（例如接入 AI 或者接入微信，如我们制作的例子），它会对你有帮助。","text_tokens":["的","相近","那些","程序","ai","主要","你","字符串","双向通信","针对","典型","。","例子","内置","大多","人","这种","事件驱动","我们","，","或者","微信","风格","极为","希望","（","就够","参考"," ","情况","和","message","事件","制作","教程","将","与","python","一些","例如","大多数","json","是","scratch","通信","需要","接受","广播","驱动","去","拓展","对","有","这篇","了","帮助","它会","复杂","只","字符","发送","当","下","多数","接入","）","双向","如"],"title":"Python 与 Scratch 的双向通信","title_tokens":["的","与","python","双向"," ","双向通信","scratch","通信"]},{"location":"dev_guide/FAQ/#arduino","text":"陆续有开发者问到，如何使用 CodeLab Adapter 将 Arduino 接入到 Scratch 3.0 中。 有许多种方法，但我比较偏好在 Arduino 中烧入 Firmata 固件。之后以固件交互，我在 两种硬件编程风格的比较 论述了这样做的好处。 之后使用 Firmata python client 与 Arduino 交互。 细节可以参考 Arduino 与 Scratch 3.0 。","text_tokens":["中烧入","论述","的","开发者","可以","在","如何","许多种","两种","开发","。","我","许多","使用","，","硬件","之后","风格","firmata","参考","细节"," ","做","但","编程","方法","问","将","与","固件","多种","好处","python","中","到","scratch","有","codelab","adapter","了","比较","偏好","交互","3.0","陆续","以","client","接入","arduino","这样"],"title":"如何接入 Arduino","title_tokens":["如何","接入"," ","arduino"]},{"location":"dev_guide/FAQ/#_4","text":"首先区分 CodeLab Adapter 和 CodeLab Adapter Node。 CodeLab Adapter 既是消息中心，又是UI程序，CodeLab Adapter 可以运行在： Windows（win7/win8/win10） Mac linux Ubuntu Raspbian Android CodeLab Adapter Node 可以运行在任何平台上，包括单片机。","text_tokens":["可以","在","程序","又","上","。","：","win10","ui","区分","，","node","（"," ","和","既","单片机","win8","/","任何","windows","运行","中心","是","平台","单片","codelab","android","首先","adapter","消息","win7","mac","linux","包括","raspbian","ubuntu","）"],"title":"支持哪些平台","title_tokens":["哪些","平台","支持"]},{"location":"dev_guide/FAQ/#_5","text":"为了方便开发者将 CodeLab Adapter 整合到其他软件中，作为服务使用，诸如整合到 Scratch Desktop ，或者整合到 docker 容器内，作为局域网消息服务…… CodeLab Adapter 允许以 命令行方式启动（没有GUI） 。 为了方便软件的二次分发和自定义，CodeLab Adapter 允许开发者覆盖用户配置文件( user_settings.py )，进而对 CodeLab Adapter 做初始化配置。 只需要将自定义的 user_settings.py 放在 CodeLab Adapter 同级目录中即可。","text_tokens":["即可","的","容器","开发者","方式","用户","(","py","为了","内","gui","局域","方便","开发","没有","。","分发","初始化","使用","软件","，","或者","自定义","（","…","同级"," ","文件","诸如","做","和",")","放在","）","定义","命令行","settings","自定","进而","将","初始","目录","_","服务","中","局域网","其他软件","user","到","scratch","命令","对","需要","允许","启动",".","codelab","作为","adapter","消息","desktop","配置","其他","配置文件","二次","覆盖","整合","只","以","docker"],"title":"覆盖配置文件","title_tokens":["覆盖","配置文件","文件","配置"]},{"location":"dev_guide/FAQ/#electron","text":"只需要集成 scratch3_eim 即可。 如果你想使用 socketio client 连接与 Adapter 沟通，参考 此处源码 。","text_tokens":["即可","你","集成","。","如果","使用","，","client","scratch3","参考"," ","连接","与","_","想","源码","需要","adapter","此处","只","socketio","eim","沟通"],"title":"如何集成到 Electron","title_tokens":["electron","如何","集成"," ","到"]},{"location":"dev_guide/FAQ/#scratch","text":"Scratch里的小绿点用于反应网页与Adapter的连通性, 小绿点的状态由 AdapterBaseClient connected 属性 决定。它属于 scratch-gui，而不属于scratch extension，这部分你需要自己实现。","text_tokens":[",","的","属于","-","这部","里","用于","实现","gui","你","决定","connected","。","部分","，","extension","由"," ","状态","它","连通性","与","属性","自己","连通","反应","不","scratch","这部分","通性","需要","adapter","小绿点","adapterbaseclient","而","网页"],"title":"Scratch里的小绿点是怎么实现的？","title_tokens":["的","怎么","小绿点","里","实现","？","是","scratch"]},{"location":"dev_guide/REST-API/","text":"REST API ¶ CodeLab Adapter 内置 REST API。 出于安全考虑，该服务默认是关闭的。 你可以在 用户配置文件（ ~/codelab_adapter/user_settings.py ） 中将其开启 OPEN_REST_API = True 。 出于安全考虑，你需要使用 token 与 REST API 通信（你可以从 WebUI 中复制 token ），具体使用方式参考下边例子。 测试工具 ¶ 你可以使用 curl 、 httpie 、 postman 、AJAX 等与它交互。 我最喜欢 httpie ，安装 httpie 很简单： pip install httpie 设计思路 ¶ 在设计上，CodeLab Adapter REST API 受到 Home Assistant REST API 影响，它被设计为消息入口，从 REST API 进入的消息，将全部转化为 ZeroMQ 消息，REST API 就像一个透明的消息通道。 在 CodeLab Adapter 中消息有很多入口，gateway 负责将来自不同入口的消息，转化为统一的 ZeroMQ 消息，这种设计风格在 CodeLab Adapter 中很常见。 无论是 MQTT、HTTP、websocket……都被统一转化为 ZeroMQ 消息。 准备工作 ¶ 开始与 REST API 交互之前，确保已经打开了 CodeLab Adapter，确保用户配置文件中 OPEN_REST_API = True 。 发送消息到 Scratch3 ¶ 使用 httpie 给 Scratch3 发送 hello 消息，对应的命令为： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"adapter/nodes/data\" payload: = '{\"node_id\":\"eim\", \"content\":\"hello\"}' 记得将其中的 token 替换你自己的。 值得注意的是 payload 是 json 数据，发送 json 数据语法为 := ，详情参考 httpie 文档。 CodeLab Scratch3 将成功接受消息： 上述任务，对应的 curl 命令为： curl -X POST -H \"Content-Type: application/json\" \\ -d '{\"topic\": \"adapter/nodes/data\",\"payload\":{\"node_id\":\"eim\", \"content\":\"hello\"}}' \\ https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae 可以看出 httpie 更加清晰简易。接下来的内容，我们都使用 httpie ，你可以使用 curl2httpie 将其转化为 curl 命令。 发送消息到 CodeLab Adapter Extension ¶ 运行命令之前，先运行 extension_eim 插件。 extension_eim 插件的 这行代码 将打印出它收到的消息。 使用 httpie 给 CodeLab Adapter Extension 发送 hello 消息，对应的命令为： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"scratch/extensions/command\" payload: = '{\"node_id\":\"eim\", \"content\":\"hello\"}' 启停插件 ¶ 由于我们已经将 CodeLab Adapter 内部 API 服务化了，所以使用 REST API 可以对 CodeLab Adapter 做任何粒度的控制（依然是受到 Home Assistant 的启发）。 提醒 启停extension 开启 extension_eim 插件： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"core/exts/operate\" payload: = '{ \"content\": \"start\", \"node_name\": \"extension_eim\"}' 在命令运行的瞬间，Web UI 会同步更新。 关闭插件 ¶ 关闭 extension_eim 插件： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"core/exts/operate\" payload: = '{ \"content\": \"stop\", \"node_name\": \"extension_eim\" }' 提醒 如果你要启停 node ，topic 为 core/nodes/operate 恶作剧 ¶ 如果你愿意，你可以搞个恶作剧，欺骗 Web UI 说 extension_eim 插件已经开启，但实际上并未开启，恶作剧的命令为： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"core/node/statu/change\" payload: = '{ \"content\": \"start\", \"node_name\": \"extension_eim\"}' 可以看到 Web UI 成功被你骗过去了:) 更多例子 ¶ 开灯/关灯 ¶ 如果你在 CodeLab Neverland 空间里，你可以使用 REST API 与空间里的所有事物互动。 开灯： http POST https://rpi.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"to_HA\" payload: = '{ \"content\":{\"type\":\"call_service\",\"domain\":\"light\",\"service\":\"turn_on\",\"service_data\":{\"entity_id\":\"light.yeelight1\"}},\"node_id\": \"eim\"}' 关灯： http POST https://rpi.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"to_HA\" payload: = '{ \"content\":{\"type\":\"call_service\",\"domain\":\"light\",\"service\":\"turn_off\",\"service_data\":{\"entity_id\":\"light.yeelight1\"}},\"node_id\": \"eim\"}' 升降窗帘 ¶ 降下窗帘： http POST https://rpi.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"to_HA\" payload: = '{ \"content\":{\"type\":\"call_service\",\"domain\":\"cover\",\"service\":\"close_cover\",\"service_data\":{\"entity_id\":\"cover.0x00158d00034f6a69_cover\"}},\"node_id\": \"eim\"}' 升起窗帘： http POST https://rpi.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"to_HA\" payload: = '{ \"content\":{\"type\":\"call_service\",\"domain\":\"cover\",\"service\":\"open_cover\",\"service_data\":{\"entity_id\":\"cover.0x00158d00034f6a69_cover\"}},\"node_id\": \"eim\"}' 想象空间 ¶ 你可以在浏览器中为 CodeLab Adapter 构建新的图形界面。 或者使用不同语言中写自动化脚本。 它也很适合用来教学 http 相关的内容。 黑客精神 ¶ CodeLab Adapter 的所有功能都已经被服务化，所以你可以使用 REST API 来做 CodeLab Adapter 所能做到的任何事情，无论是控制内部功能，还是发送消息（everything is a message）。唯一需要的知识是有关消息的结构，你可以使用 codelab-message-monitor 来观察消息结构。","text_tokens":[",","domain","的","事情","用户","可以","安装","一个","所以","替换","上","搞个","看到","你","窗帘","并未","core","教学","data","知识","其","h","内置","接下来","这种","我","pip","如果","\\","我们","简单","就","rpi","观察","（","风格","想象","数据","最","club","事物","入口","做","yeelight1","精神","'","浏览器","settings","websocket","负责","说","工具","出于","结构","欺骗","内部","中为","功能","command","无论是","通道","下来","设计","相关","需要","通信","scratch","application","对应",".","测试","为","上述","codelab","statu","降下","adapter","了","有关","启停","自动","要","所有","会","新","值得","已经","-","内容","py",":","在","post","~","自动化","mqtt","https","\"","gateway","install","nodes","复制","ui","语言","token","来自","extension","…","curl2httpie","参考","成功","turn","文件","被","off",")","content","x00158d00034f6a69","更新","图形界面","home","/","任何","将","自己","注意","来","唯一","_","curl","close","从","中","对","考虑","、","webui","assistant","配置","d","恶作剧","配置文件","下边","id","?","call","entity","记得","提醒","发送","eim","其中","出","工作","方式","转化","ajax","}","浏览","topic","思路","例子","postman","全部","。","：","很多","文档","行","打印","中写","打开","收到","x","也","给","受到","，","或者","web","更加","hello","scratch3","to","operate","用来","开灯","不同","确保","接下","构建","脚本","stop","所","无论","开始","message","试工","extensions","关灯","适合","中将","任务","这","运行","进入","粒度","多","服务","等","该","json","瞬间","命令","接受","启发","有","很","monitor","true","统一","常见","还是","¶","依然","值得注意","start","语法","默认","交互","change","neverland","升起","api","骗","a","）","{","空间","86d6d93124c341ae","透明","愿意","里","on","cover.0","界面","像","关闭","同步","互动","is","测试工具","之前","详情","服务化","exts","zeromq","喜欢","插件","使用","12358","=","node","准备","清晰","实际","更","service"," ","看出","cover","由于","httpie","它","open","但","http","先","安全","light","实际上","黑客","能","与","type","代码","做到","都","ha","影响","升降","user","图形","是","rest","到","everything","过去","开启","消息","name","payload","具体","简易","控制"],"title":"REST API","title_tokens":["rest"," ","api"]},{"location":"dev_guide/REST-API/#rest-api","text":"CodeLab Adapter 内置 REST API。 出于安全考虑，该服务默认是关闭的。 你可以在 用户配置文件（ ~/codelab_adapter/user_settings.py ） 中将其开启 OPEN_REST_API = True 。 出于安全考虑，你需要使用 token 与 REST API 通信（你可以从 WebUI 中复制 token ），具体使用方式参考下边例子。","text_tokens":["的","方式","用户","可以","py","在","~","你","例子","关闭","。","其","内置","复制","使用","，","token","=","（","参考"," ","文件","open","settings","安全","/","中将","与","_","具体","服务","从","中","该","user","是","rest","需要","通信","考虑",".","codelab","开启","true","配置","adapter","webui","配置文件","下边","默认","api","出于","）"],"title":"REST API","title_tokens":["rest"," ","api"]},{"location":"dev_guide/REST-API/#_1","text":"你可以使用 curl 、 httpie 、 postman 、AJAX 等与它交互。 我最喜欢 httpie ，安装 httpie 很简单： pip install httpie","text_tokens":["ajax","可以","安装","你","postman","。","：","install","我","pip","喜欢","简单","使用","，","最"," ","httpie","它","与","等","curl","很","、","交互"],"title":"测试工具","title_tokens":["工具","测试","测试工具","试工"]},{"location":"dev_guide/REST-API/#_2","text":"在设计上，CodeLab Adapter REST API 受到 Home Assistant REST API 影响，它被设计为消息入口，从 REST API 进入的消息，将全部转化为 ZeroMQ 消息，REST API 就像一个透明的消息通道。 在 CodeLab Adapter 中消息有很多入口，gateway 负责将来自不同入口的消息，转化为统一的 ZeroMQ 消息，这种设计风格在 CodeLab Adapter 中很常见。 无论是 MQTT、HTTP、websocket……都被统一转化为 ZeroMQ 消息。","text_tokens":["的","透明","转化","一个","在","上","mqtt","全部","像","。","gateway","很多","这种","zeromq","就","受到","，","来自","风格","…"," ","入口","不同","被","它","无论","http","websocket","home","负责","将","进入","都","从","影响","通道","中","设计","无论是","rest","有","很","为","codelab","统一","assistant","常见","adapter","消息","、","api"],"title":"设计思路","title_tokens":["设计","思路"]},{"location":"dev_guide/REST-API/#_3","text":"开始与 REST API 交互之前，确保已经打开了 CodeLab Adapter，确保用户配置文件中 OPEN_REST_API = True 。","text_tokens":["用户","。","之前","打开","，","="," ","文件","确保","open","开始","与","_","中","rest","codelab","true","配置","了","adapter","配置文件","交互","api","已经"],"title":"准备工作","title_tokens":["准备","工作"]},{"location":"dev_guide/REST-API/#scratch3","text":"使用 httpie 给 Scratch3 发送 hello 消息，对应的命令为： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"adapter/nodes/data\" payload: = '{\"node_id\":\"eim\", \"content\":\"hello\"}' 记得将其中的 token 替换你自己的。 值得注意的是 payload 是 json 数据，发送 json 数据语法为 := ，详情参考 httpie 文档。 CodeLab Scratch3 将成功接受消息： 上述任务，对应的 curl 命令为： curl -X POST -H \"Content-Type: application/json\" \\ -d '{\"topic\": \"adapter/nodes/data\",\"payload\":{\"node_id\":\"eim\", \"content\":\"hello\"}}' \\ https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae 可以看出 httpie 更加清晰简易。接下来的内容，我们都使用 httpie ，你可以使用 curl2httpie 将其转化为 curl 命令。","text_tokens":[",","的","可以","替换","你","data","接下来","h","其","\\","我们","数据","club","'","下来","application","对应",".","为","上述","codelab","adapter","值得","-","内容",":","post","https","\"","nodes","token","curl2httpie","参考","成功","content","/","将","自己","注意","_","curl","d","id","?","记得","发送","eim","其中","}","转化","topic","。","：","文档","x","给","，","更加","hello","scratch3","接下","message","任务","json","命令","接受","值得注意","语法","api","{","86d6d93124c341ae","详情","使用","12358","=","node","清晰"," ","看出","httpie","http","type","都","是","消息","payload","简易"],"title":"发送消息到 Scratch3","title_tokens":["消息","scratch3"," ","发送","到"]},{"location":"dev_guide/REST-API/#codelab-adapter-extension","text":"运行命令之前，先运行 extension_eim 插件。 extension_eim 插件的 这行代码 将打印出它收到的消息。 使用 httpie 给 CodeLab Adapter Extension 发送 hello 消息，对应的命令为： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"scratch/extensions/command\" payload: = '{\"node_id\":\"eim\", \"content\":\"hello\"}'","text_tokens":[",","86d6d93124c341ae","的","-","}",":","post","topic","https","\"","行","。","打印","：","之前","收到","插件","给","使用","，","12358","token","extension","=","node","hello","club"," ","httpie","它","'","content","先","http","message","extensions","/","将","代码","这","运行","_","command","命令","scratch","对应",".","为","codelab","adapter","消息","id","?","payload","发送","eim","api","{","出"],"title":"发送消息到 CodeLab Adapter Extension","title_tokens":["codelab","adapter","消息","extension"," ","发送","到"]},{"location":"dev_guide/REST-API/#_4","text":"由于我们已经将 CodeLab Adapter 内部 API 服务化了，所以使用 REST API 可以对 CodeLab Adapter 做任何粒度的控制（依然是受到 Home Assistant 的启发）。 提醒 启停extension 开启 extension_eim 插件： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"core/exts/operate\" payload: = '{ \"content\": \"start\", \"node_name\": \"extension_eim\"}' 在命令运行的瞬间，Web UI 会同步更新。","text_tokens":[",","的","可以","所以","core","我们","（","club","做","'","内部",".","codelab","adapter","了","启停","会","已经","-",":","在","post","https","\"","ui","token","extension","content","更新","home","/","任何","将","_","对","assistant","?","提醒","eim","}","topic","。","：","受到","，","web","operate","message","运行","粒度","服务","瞬间","命令","启发","依然","start","api","{","）","86d6d93124c341ae","同步","exts","服务化","插件","使用","12358","=","node"," ","由于","http","rest","是","开启","name","payload","控制"],"title":"启停插件","title_tokens":["插件","启停"]},{"location":"dev_guide/REST-API/#_5","text":"关闭 extension_eim 插件： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"core/exts/operate\" payload: = '{ \"content\": \"stop\", \"node_name\": \"extension_eim\" }' 提醒 如果你要启停 node ，topic 为 core/nodes/operate","text_tokens":[",","86d6d93124c341ae","-","}",":","post","topic","你","https","core","\"","关闭","：","nodes","exts","如果","插件","，","12358","token","extension","=","node","club"," ","operate","'","content","stop","http","message","/","_",".","为","codelab","adapter","name","启停","?","payload","提醒","要","eim","api","{"],"title":"关闭插件","title_tokens":["关闭","插件"]},{"location":"dev_guide/REST-API/#_6","text":"如果你愿意，你可以搞个恶作剧，欺骗 Web UI 说 extension_eim 插件已经开启，但实际上并未开启，恶作剧的命令为： http POST https://codelab-adapter.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"core/node/statu/change\" payload: = '{ \"content\": \"start\", \"node_name\": \"extension_eim\"}' 可以看到 Web UI 成功被你骗过去了:)","text_tokens":[",","86d6d93124c341ae","的","-","}","可以","愿意",":","post","搞个","topic","看到","你","https","并未","core","\"","：","如果","ui","插件","，","实际","web","extension","12358","token","=","node","club"," ","成功","被","'","content","但",")","http","说","message","实际上","/","欺骗","_","命令",".","为","statu","过去","开启","codelab","adapter","恶作剧","start","name","change","?","了","payload","eim","api","骗","{","已经"],"title":"恶作剧","title_tokens":["恶作剧"]},{"location":"dev_guide/REST-API/#_7","text":"","text_tokens":[],"title":"更多例子","title_tokens":["更","例子","多"]},{"location":"dev_guide/REST-API/#_8","text":"如果你在 CodeLab Neverland 空间里，你可以使用 REST API 与空间里的所有事物互动。 开灯： http POST https://rpi.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"to_HA\" payload: = '{ \"content\":{\"type\":\"call_service\",\"domain\":\"light\",\"service\":\"turn_on\",\"service_data\":{\"entity_id\":\"light.yeelight1\"}},\"node_id\": \"eim\"}' 关灯： http POST https://rpi.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"to_HA\" payload: = '{ \"content\":{\"type\":\"call_service\",\"domain\":\"light\",\"service\":\"turn_off\",\"service_data\":{\"entity_id\":\"light.yeelight1\"}},\"node_id\": \"eim\"}'","text_tokens":[",","86d6d93124c341ae","domain","的","}","可以","里","在","post",":","topic","on","你","https","data","\"","。","互动","：","如果","rpi","使用","，","12358","token","=","service","node","to","club"," ","事物","开灯","turn","yeelight1","off","'","content","http","message","light","关灯","/","与","type","_","ha","rest",".","codelab","entity","id","?","neverland","call","payload","api","所有","eim","{","空间"],"title":"开灯/关灯","title_tokens":["开灯","关灯","/"]},{"location":"dev_guide/REST-API/#_9","text":"降下窗帘： http POST https://rpi.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"to_HA\" payload: = '{ \"content\":{\"type\":\"call_service\",\"domain\":\"cover\",\"service\":\"close_cover\",\"service_data\":{\"entity_id\":\"cover.0x00158d00034f6a69_cover\"}},\"node_id\": \"eim\"}' 升起窗帘： http POST https://rpi.codelab.club:12358/api/message?token = 86d6d93124c341ae topic = \"to_HA\" payload: = '{ \"content\":{\"type\":\"call_service\",\"domain\":\"cover\",\"service\":\"open_cover\",\"service_data\":{\"entity_id\":\"cover.0x00158d00034f6a69_cover\"}},\"node_id\": \"eim\"}'","text_tokens":[",","86d6d93124c341ae","domain","}",":","cover.0","post","topic","窗帘","https","data","\"","：","rpi","12358","token","=","service","node","to","club"," ","cover","'","content","x00158d00034f6a69","open","http","message","/","type","_","ha","close",".","codelab","降下","entity","id","升起","?","call","payload","api","eim","{"],"title":"升降窗帘","title_tokens":["窗帘","升降"]},{"location":"dev_guide/REST-API/#_10","text":"你可以在浏览器中为 CodeLab Adapter 构建新的图形界面。 或者使用不同语言中写自动化脚本。 它也很适合用来教学 http 相关的内容。","text_tokens":["的","内容","可以","界面","在","浏览","自动化","教学","你","。","中写","也","使用","或者","语言","用来"," ","不同","构建","脚本","它","浏览器","图形界面","http","适合","中为","图形","相关","很","codelab","adapter","自动","新"],"title":"想象空间","title_tokens":["空间","想象"]},{"location":"dev_guide/REST-API/#_11","text":"CodeLab Adapter 的所有功能都已经被服务化，所以你可以使用 REST API 来做 CodeLab Adapter 所能做到的任何事情，无论是控制内部功能，还是发送消息（everything is a message）。唯一需要的知识是有关消息的结构，你可以使用 codelab-message-monitor 来观察消息结构。","text_tokens":["的","-","所","可以","所以","事情","你","知识","。","服务化","使用","，","观察","（"," ","做","被","无论","message","能","任何","来","结构","做到","内部","唯一","功能","都","服务","无论是","everything","rest","需要","是","monitor","a","codelab","还是","adapter","消息","有关","发送","api","所有","is","）","控制","已经"],"title":"黑客精神","title_tokens":["精神","黑客"]},{"location":"dev_guide/debug/","text":"Debug ¶ 3 种 debug 方式 ¶ Adapter 本质是个消息系统，调试的关键是观察往来的消息。 目前有 3 种 debug 方式： 基于命令行的调试（只能看到消息） 基于日志的调试 (可以看到 log 信息) 我自己最偏好第一种： 基于命令行的调试 。如果你希望看到logger信息，则使用第2种方式(基于日志的调试)。 下边逐一陈述。 基于命令行的调试 ¶ 需要本地有 Python 环境（ Python >= 3.6 ） 安装 pip install codelab_adapter_client --upgrade codelab_adapter_client 会为你装上 2 个命令行调试工具： codelab-message-monitor codelab-message-trigger codelab-message-pub 运行 codelab-message-monitor ，你将看到在 CodeLab Adapter 中所有往来的消息。这是我目前最依赖的工具。 你也可以自行构建更适合自己的调试脚手架，推荐使用 sh ，这样你可以方便把 linux 工具箱里的工具都用上，同时又可以在 Python 语言中工作。 # pip install sh codelab_adapter_client # http://amoffat.github.io/sh/sections/asynchronous_execution.html#incremental-iteration import sh for line in sh . codelab_message_monitor ( _iter = True ): try : print ( sh . ack ( \"10\" , _in = line )) except : pass 基于日志的调试 ¶ 我们在 hello world #调试技巧 中提到了基于日志的调试。 在插件中打上日志： self.logger.info ，之后使用 tail -f ~/codelab_adapter/debug.log tail -f ~/codelab_adapter/info.log tail -f ~/codelab_adapter/error.log 便可实时查看日志。 Tip Windows 用户 ¶ Windows 缺少调试 unix/linux 工具集，调试起来可能有诸多不便，推荐使用 cmder ，如此一来你就能得到一大包好用的命令行工具。 log 过滤 ¶ 如果你觉得 log 输出的信息太多，可以使用 grep 观察你关注的信息，诸如我只关心 extension_hello_world.py 插件输出的信息： tail -f ~/codelab_adapter/info.log | grep extension_hello_world","text_tokens":[",","iteration","的","便","(","用户","可以","安装","debug","看到","上","又","你","incremental","sh","我","如果","pip","装上","f","我们","就","观察","打",">","（","提到","最","trigger","用","诸多","print","工具","ack","import","需要","诸多不便",".","codelab","关键","unix","for","adapter","了","3.6","得到","所有","|","-","本地","error","基于","工具集","可能",":","在","会为","~","py","asynchronous","如此","\"","如此一来","install","一来","try","实时","self","语言","tip","不便","logger","之后","extension","一种","第一","pub","诸如","大包","过滤",")","陈述","往来","/","world","将","自己","python","_","太","中","输出","第一种","linux","2","下边","只","查看","工作","觉得","方式","html","依赖","amoffat","。","：","关注","3","也","推荐","，","希望","hello","#","第","构建","技巧","调试","可","起来","message","适合","这","运行","多","把","系统","iter","命令","monitor","有","工具箱","github","关心","true","line","¶","自行","脚手架","cmder","则","client","）","upgrade","本质","日志","好用","io","里","种","10","方便","信息","一","插件","使用","log","info","in","=","更","缺少","只能","sections"," ","逐一","grep","个","pass","http","能","命令行","windows","都","except","tail","脚手","是","环境","消息","偏好","同时","目前","execution","这样"],"title":"debug","title_tokens":["debug"]},{"location":"dev_guide/debug/#debug","text":"","text_tokens":[],"title":"Debug","title_tokens":["debug"]},{"location":"dev_guide/debug/#3-debug","text":"Adapter 本质是个消息系统，调试的关键是观察往来的消息。 目前有 3 种 debug 方式： 基于命令行的调试（只能看到消息） 基于日志的调试 (可以看到 log 信息) 我自己最偏好第一种： 基于命令行的调试 。如果你希望看到logger信息，则使用第2种方式(基于日志的调试)。 下边逐一陈述。","text_tokens":["的","方式","(","基于","可以","debug","看到","种","你","信息","。","：","我","如果","3","使用","，","观察","log","（","logger","只能","希望","一种","第","最"," ","第一","调试","逐一",")","陈述","个","往来","）","命令行","自己","系统","是","命令","有","第一种","关键","adapter","消息","2","下边","偏好","则","目前","本质","日志"],"title":"3 种 debug 方式","title_tokens":["3","方式","debug","种"," "]},{"location":"dev_guide/debug/#_1","text":"需要本地有 Python 环境（ Python >= 3.6 ） 安装 pip install codelab_adapter_client --upgrade codelab_adapter_client 会为你装上 2 个命令行调试工具： codelab-message-monitor codelab-message-trigger codelab-message-pub 运行 codelab-message-monitor ，你将看到在 CodeLab Adapter 中所有往来的消息。这是我目前最依赖的工具。 你也可以自行构建更适合自己的调试脚手架，推荐使用 sh ，这样你可以方便把 linux 工具箱里的工具都用上，同时又可以在 Python 语言中工作。 # pip install sh codelab_adapter_client # http://amoffat.github.io/sh/sections/asynchronous_execution.html#incremental-iteration import sh for line in sh . codelab_message_monitor ( _iter = True ): try : print ( sh . ack ( \"10\" , _in = line )) except : pass","text_tokens":[",","iteration","的","(","安装","可以","看到","上","又","你","incremental","sh","我","pip","装上",">","（","最","trigger","用","print","工具","ack","import","需要",".","codelab","for","adapter","3.6","所有","-","本地",":","在","会为","asynchronous","\"","install","try","语言","pub",")","往来","/","将","自己","python","_","中","linux","2","工作","html","依赖","amoffat","。","：","也","推荐","，","#","构建","调试","message","适合","这","运行","把","iter","命令","monitor","有","工具箱","github","true","line","自行","脚手架","client","upgrade","）","io","里","10","方便","使用","in","=","更","sections"," ","个","pass","http","命令行","都","except","脚手","是","环境","消息","同时","目前","execution","这样"],"title":"基于命令行的调试","title_tokens":["的","命令行","基于","调试","命令"]},{"location":"dev_guide/debug/#_2","text":"我们在 hello world #调试技巧 中提到了基于日志的调试。 在插件中打上日志： self.logger.info ，之后使用 tail -f ~/codelab_adapter/debug.log tail -f ~/codelab_adapter/info.log tail -f ~/codelab_adapter/error.log 便可实时查看日志。 Tip","text_tokens":["的","-","便","error","基于","在","debug","上","~","。","：","f","实时","我们","插件","self","，","打","info","使用","logger","之后","log","hello","提到","#","tip"," ","技巧","调试","可","/","world","_","tail","中",".","codelab","了","adapter","查看","日志"],"title":"基于日志的调试","title_tokens":["基于","调试","的","日志"]},{"location":"dev_guide/debug/#windows","text":"Windows 缺少调试 unix/linux 工具集，调试起来可能有诸多不便，推荐使用 cmder ，如此一来你就能得到一大包好用的命令行工具。","text_tokens":["好用","的","工具集","可能","你","如此","如此一来","。","一来","一","推荐","使用","，","就","缺少","不便"," ","调试","大包","起来","诸多","能","命令行","/","工具","windows","命令","诸多不便","有","unix","linux","得到","cmder"],"title":"Windows 用户","title_tokens":["用户","windows"," "]},{"location":"dev_guide/debug/#log","text":"如果你觉得 log 输出的信息太多，可以使用 grep 观察你关注的信息，诸如我只关心 extension_hello_world.py 插件输出的信息： tail -f ~/codelab_adapter/info.log | grep extension_hello_world","text_tokens":["觉得","的","-","可以","py","~","你","信息","：","我","关注","如果","f","插件","使用","log","，","观察","info","extension","hello"," ","诸如","grep","/","world","多","_","太","tail","输出",".","关心","codelab","adapter","只","|"],"title":"log 过滤","title_tokens":["过滤"," ","log"]},{"location":"dev_guide/dev_articles/","text":"开发文章列表 ¶ 开发 ¶ 创建你的第一个 Scratch 3.0 Extension 如何开发一个 CodeLab Adapter 插件 构建并发布一个 CodeLab Adapter 插件(旧版本，不推荐) 将CodeLab Adapter用作Python解释器 Python 与 Scratch 的双向通信 使用 Python 拓展 Scratch 的能力 scratch3-adapter 支持第三方平台 CodeLab Adapter 增加REST API CodeLab Adapter支持在web页面启停插件 Arduino 与 Scratch 3.0 codelab.club ❤️ Vector 使用 Scratch 3.0 制作幻灯片 积木化编程与智能家居 CodeLab ❤️ Blender CodeLab Adapter 接入blender 架构设计 ¶ 为 Scratch 3.0 设计的插件系统（上篇） 为 Scratch 3.0 设计的插件系统（下篇）","text_tokens":["的","(","一个","解释","上","你","开发","化","（","club","用作","家居","blender","设计","制作","平台","scratch","通信",".","为","codelab","adapter","启停","第三","旧版本","接入","双向","-","在","双向通信","下篇","extension","释器","篇","第一","vector",")","幻灯片","三方","将","python","增加","架构设计","支持","arduino","架构","并","列表","如何","幻灯","推荐","，","页面","web","文章","scratch3","构建","第一个","系统","¶","解释器","api","）","版本","️","智能","插件","构设","使用","积木"," ","旧版","编程","❤","与","不","rest","拓展","3.0","智能家居","能力","第三方","发布","创建"],"title":"dev articles","title_tokens":["dev"," ","articles"]},{"location":"dev_guide/dev_articles/#_1","text":"","text_tokens":[],"title":"开发文章列表","title_tokens":["列表","文章","开发"]},{"location":"dev_guide/dev_articles/#_2","text":"创建你的第一个 Scratch 3.0 Extension 如何开发一个 CodeLab Adapter 插件 构建并发布一个 CodeLab Adapter 插件(旧版本，不推荐) 将CodeLab Adapter用作Python解释器 Python 与 Scratch 的双向通信 使用 Python 拓展 Scratch 的能力 scratch3-adapter 支持第三方平台 CodeLab Adapter 增加REST API CodeLab Adapter支持在web页面启停插件 Arduino 与 Scratch 3.0 codelab.club ❤️ Vector 使用 Scratch 3.0 制作幻灯片 积木化编程与智能家居 CodeLab ❤️ Blender CodeLab Adapter 接入blender","text_tokens":["的","-","(","版本","一个","并","解释","在","️","如何","你","双向通信","智能","开发","幻灯","插件","推荐","使用","，","页面","积木","web","extension","释器","化","scratch3","第一"," ","旧版","用作","club","构建","vector","家居",")","第一个","❤","幻灯片","编程","三方","将","与","python","blender","不","增加","第三方","制作","平台","scratch","通信","拓展","rest",".","codelab","adapter","解释器","第三","启停","3.0","智能家居","支持","arduino","能力","api","旧版本","接入","双向","发布","创建"],"title":"开发","title_tokens":["开发"]},{"location":"dev_guide/dev_articles/#_3","text":"为 Scratch 3.0 设计的插件系统（上篇） 为 Scratch 3.0 设计的插件系统（下篇）","text_tokens":["为","的","插件","下篇","（","上","篇","3.0"," ","系统","设计","）","scratch"],"title":"架构设计","title_tokens":["设计","架构","架构设计","构设"]},{"location":"dev_guide/helloworld/","text":"hello world(Adapter Extension) ¶ 我们来写一个自定义插件（extension），实现 hello world 。 一些唠叨 ¶ 如果你不爱听唠叨，这部分可以跳过：） 在 架构图 中，可以看到一个完整的插件包含两个部分： Scratch 3.0 网页中的插件（内应） 在 CodeLab Adapter 中写一个插件，代理硬件设备、AI 或其他程序 关于第一部分，尽管 Scratch3 官方的 extensions 机制已经可用了，我们也在 Scratch 3.0 中写了很多插件，但社区里文档不多，不大建议大家来踩坑，如果愿意折腾，可以参考 创建你的第一个 Scratch 3.0 Extension 。 我们在 CodeLab Scratch3 中构建了一些通用的消息积木（EIM），我们尽量将它做的通用，让开发者只需在 CodeLab Adapter 自定义插件，即可在 Scratch3 中使用。 这块的核心概念很简单，如 EIM 所代表的含义： Everything Is a Message ，消息是一种极其强大的概念，如 Alan Kay 说的： The big idea is messaging. 如果你用过 Smalltalk / ZeroMQ / Erlang 大概深有体会。 自定义插件 ¶ 我们来实现一个自定义插件： helloworld extension 我们构建这样一个自定义插件，它的功能为： 将 Scratch 发过来的字符串逆转，如果 Scratch 发过来的字符串为 hello world ，我们则向Scratch发送： dlrow olleh 该插件的源码为： import time from codelab_adapter.core_extension import Extension class HelloWorldExtension ( Extension ): NODE_ID = \"eim\" def __init__ ( self ): super () . __init__ () def send_message_to_scratch ( self , content ): message = self . message_template () message [ \"payload\" ][ \"content\" ] = content self . publish ( message ) def extension_message_handle ( self , topic , payload ): self . logger . info ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转字符串 self . send_message_to_scratch ( content_send_to_scratch ) def run ( self ): while self . _running : time . sleep ( 1 ) export = HelloWorldExtension 代码很简单，而且大部分是样板代码，有几点值得注意： NODE_ID 默认为 eim ，可以不写。 extension_message_handle 是个回调函数，处理从 Scratch 过来的消息（一般由积木触发） run 是插件的主体代码，当你在 Web UI 中选择插件时，发生的事情是： 首先实例化插件类（在此是 export = EIMExtension ） 之后将 run 运行为线程。run 方法一般使用 while self._running 来阻塞， run 方法一旦结束，该插件的生命周期就结束了。 至于你要在 extension_message_handle 和 run 中写什么 Python 代码则是完全自由的。 将插件命名为 extension_hello_world.py ，将其放到插件目录里，Mac/Linux 用户的插件目录在： ~/codelab_adapter/extensions ，如果找不到插件目录（如 Windows 用户），可以通过 CodeLab Adapter 菜单栏上的 插件->查看目录 打开它。 刷新 Web UI，点击运行 extension_hello_world.py ，接着你就可以在 Scratch 中与你的插件交互了。 恭喜你，已经能够让 Scratch 与 Python 对话了，你现在可以用你的 Python 技能来为 Scratch 写拓展啦！ 提醒 你可以将自定义插件发布到 插件市场 , 用户点击即可下载使用。 调试技巧 ¶ 建议你在写 Python 插件的时候，先做好单元测试，然后再作为插件放到插件目录里运行。 如果你喜欢在真实环境里开发，可以使用 self.logger.info 来打日志（就像前头的代码里做的），你可以实时查看日志： tail -f ~/codelab_adapter/info.log ，日志目录可以通过菜单里的 日志->目录 打开。 更多 ¶ 你可以在插件中引用哪些 Python 库呢？ 所有的 Python 内置库（json/re/math/……）以及这些第三方库： 第三方模块 。 如果你对 EIM 在 Scratch3 一侧的源码感兴趣，我们也开源出来了，可以自行阅读： scratch3_eim 。 提醒 第三方模块 中有几个采用异步模式(async): aiohttp、hbmqtt、pymata-express。 自定义插件默认以线程运行 run 方法, 配合异步库使用的时候需要注意. 参考 extension_mqtt_broker.py 和 extension_arduino_uno.py 小结 ¶ 从这个例子中，可以看出写一个自定义的插件是很简单的。而 CodeLab Adapter 对插件要做的事几乎没有任何限制，只要 Python 能做的事，插件系统都能做！就是说你可以自己写一个插件，让 Scratch3 来控制你的蓝牙设备、你的 ROS 机器人、你那跑着 OpenCV 的树莓派或者你童年那辆心爱的玩具四驱车。 enjoy it～","text_tokens":[",","的","一个","事情","看到","上","开发","引用","内置","1","单元","big","enjoy","做","大部","说","什么","童年","scratch","需要","模式","为","感兴","作为","限制","那","接着","哪些","已经","即可","让","体会","-","在","机制","机器人","踩","市场","大部分","extension","…","一种","第一","折腾","任何","包含","目录","做好","对","构图","主体","心爱","深有体会","eim","发送","当","express","helloworld","arduino","如","erlang","函数","handle","或者","web","可用","阅读","构建","内应","方法","单元测试","放到","玩具","！","不写","¶","触发","而","super","a","代理","export","愿意","这块","插件","re","running","=","只要","四驱车"," ","看出","但","完整","到","if","mac","出来","第三方","template","所","～","部分","其","跑","f","简单","而且","打","化","关于","设备","逆转","import","蓝牙","]",".","publish","第三","发过","生命","要","机器","点击","对话","it","dlrow","下载","硬件","eimextension","派",")","content","核心","来","过来","、","那辆","提醒","几乎","str","}","建议","着","。","很多","init","打开","库","opencv","hello","scratch3","感兴趣","刷新","此","第一个","message","extensions","开源","技能","该","json","有","向","自行","异步","）","尽量","{","开发者","发过来","程序","反转","字符串","class","再","[","log","info","个","与","type","代码","找","一些","everything","架构图","完全","消息","选择","控制","创建","(","用户","可以","呢","core","如果","现在","概念","听","uno","周期","用","kay","发生","跳过","前头","功能","ros","这些","测试","中有","这部","一侧","py",":","含义","处理","不到","没有","两个","hbmqtt","run","小结","大家","之后","参考","和","菜单栏","__","/","自定","命名","将","注意","三方","python","from","_","中","官方","helloworldextension","从","通过","首先","linux","id","只","网页","强大","math","aiohttp","能够","topic","极其","例子","文档","：","由","就是","to","技巧","坑","恭喜","自由","？","运行","系统","time","这部分","很","值得注意","默认","交互","字符","while","日志","里","几个","zeromq","smalltalk","积木","更","node","事","能","结束","windows","这个","tail","源码","环境","拓展","大概","阻塞","生命周期","payload","菜单","这样","olleh","时","兴趣","你","通用","线程","尽管","大","我们","就","自定义",">","（","send","就是说","async","'","._","社区","codelab","adapter","了","几点","以","所有","值得","一旦","实现","ai","~","mqtt","时候","\"","或","实时","ui","self","logger","样板","类","真实","实例","回调","唠叨","alan","world","messaging","自己","然后","查看","啦","爱","架构","中写","pymata","也","树莓","，","#","调试","定义","模块","多","以及","其他","则","写","代表","配合","一般","sleep","idea","像","喜欢","至于","使用","采用","需","它","def","先","都","the","不","是","过","3.0","broker","is","驱车","发布"],"title":"hello world(Adapter Extension)","title_tokens":["(","world","adapter","extension","hello"," ",")"]},{"location":"dev_guide/helloworld/#hello-worldadapter-extension","text":"我们来写一个自定义插件（extension），实现 hello world 。","text_tokens":["定义","我们","插件","自定义","，","自定","world","一个","来","（","extension","实现","hello"," ","写","。","）"],"title":"hello world(Adapter Extension)","title_tokens":["(","world","adapter","extension","hello"," ",")"]},{"location":"dev_guide/helloworld/#_1","text":"如果你不爱听唠叨，这部分可以跳过：） 在 架构图 中，可以看到一个完整的插件包含两个部分： Scratch 3.0 网页中的插件（内应） 在 CodeLab Adapter 中写一个插件，代理硬件设备、AI 或其他程序 关于第一部分，尽管 Scratch3 官方的 extensions 机制已经可用了，我们也在 Scratch 3.0 中写了很多插件，但社区里文档不多，不大建议大家来踩坑，如果愿意折腾，可以参考 创建你的第一个 Scratch 3.0 Extension 。 我们在 CodeLab Scratch3 中构建了一些通用的消息积木（EIM），我们尽量将它做的通用，让开发者只需在 CodeLab Adapter 自定义插件，即可在 Scratch3 中使用。 这块的核心概念很简单，如 EIM 所代表的含义： Everything Is a Message ，消息是一种极其强大的概念，如 Alan Kay 说的： The big idea is messaging. 如果你用过 Smalltalk / ZeroMQ / Erlang 大概深有体会。","text_tokens":["的","所","可以","一个","看到","你","通用","开发","部分","尽管","如果","大","我们","简单","自定义","（","概念","big","听","做","用","kay","关于","跳过","说","社区","设备","scratch",".","codelab","adapter","了","已经","即可","让","体会","这部","在","机制","ai","含义","踩","两个","或","大家","硬件","extension","一种","参考","第一","折腾","唠叨","核心","alan","/","自定","messaging","将","来","包含","中","官方","构图","、","只","网页","深有体会","eim","爱","如","强大","架构","erlang","建议","极其","。","中写","：","很多","文档","也","，","可用","scratch3","构建","坑","内应","第一个","定义","message","extensions","多","这部分","很","其他","a","代理","）","尽量","代表","开发者","愿意","里","程序","idea","这块","zeromq","插件","使用","smalltalk","积木","需"," ","它","但","完整","不","一些","the","everything","是","架构图","大概","过","消息","3.0","is","创建"],"title":"一些唠叨","title_tokens":["唠叨","一些"]},{"location":"dev_guide/helloworld/#_2","text":"我们来实现一个自定义插件： helloworld extension 我们构建这样一个自定义插件，它的功能为： 将 Scratch 发过来的字符串逆转，如果 Scratch 发过来的字符串为 hello world ，我们则向Scratch发送： dlrow olleh 该插件的源码为： import time from codelab_adapter.core_extension import Extension class HelloWorldExtension ( Extension ): NODE_ID = \"eim\" def __init__ ( self ): super () . __init__ () def send_message_to_scratch ( self , content ): message = self . message_template () message [ \"payload\" ][ \"content\" ] = content self . publish ( message ) def extension_message_handle ( self , topic , payload ): self . logger . info ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转字符串 self . send_message_to_scratch ( content_send_to_scratch ) def run ( self ): while self . _running : time . sleep ( 1 ) export = HelloWorldExtension 代码很简单，而且大部分是样板代码，有几点值得注意： NODE_ID 默认为 eim ，可以不写。 extension_message_handle 是个回调函数，处理从 Scratch 过来的消息（一般由积木触发） run 是插件的主体代码，当你在 Web UI 中选择插件时，发生的事情是： 首先实例化插件类（在此是 export = EIMExtension ） 之后将 run 运行为线程。run 方法一般使用 while self._running 来阻塞， run 方法一旦结束，该插件的生命周期就结束了。 至于你要在 extension_message_handle 和 run 中写什么 Python 代码则是完全自由的。 将插件命名为 extension_hello_world.py ，将其放到插件目录里，Mac/Linux 用户的插件目录在： ~/codelab_adapter/extensions ，如果找不到插件目录（如 Windows 用户），可以通过 CodeLab Adapter 菜单栏上的 插件->查看目录 打开它。 刷新 Web UI，点击运行 extension_hello_world.py ，接着你就可以在 Scratch 中与你的插件交互了。 恭喜你，已经能够让 Scratch 与 Python 对话了，你现在可以用你的 Python 技能来为 Scratch 写拓展啦！ 提醒 你可以将自定义插件发布到 插件市场 , 用户点击即可下载使用。","text_tokens":["olleh",",","的","template","(","时","用户","可以","一个","事情","上","你","core","部分","其","线程","如果","f","1","我们","简单","自定义","而且","就",">","现在","send","（","化","周期","'","大部","用","发生","._","功能","逆转","import","什么","]","scratch",".","为","publish","codelab","adapter","了","发过","几点","生命","要","接着","点击","值得","已经","即可","让","-","一旦","对话","py",":","实现","在","~","市场","处理","不到","\"","大部分","run","ui","dlrow","self","下载","extension","logger","之后","样板","eimextension","类","和","菜单栏",")","content","回调","__","实例","命名","自定","world","将","来","注意","/","python","目录","from","过来","_","从","helloworldextension","中","通过","主体","首先","linux","id","查看","提醒","发送","eim","当","啦","helloworld","如","str","}","能够","函数","handle","topic","。","：","中写","init","打开","，","web","hello","由","to","#","刷新","构建","此","恭喜","定义","message","方法","自由","extensions","放到","技能","运行","！","该","time","不写","有","很","向","触发","值得注意","默认","交互","字符","则","super","while","写","{","）","export","发过来","一般","里","反转","sleep","字符串","class","[","至于","插件","使用","info","running","=","node","积木"," ","它","个","def","结束","windows","与","type","代码","找","the","源码","是","到","拓展","if","完全","阻塞","生命周期","消息","mac","payload","菜单","选择","这样","发布"],"title":"自定义插件","title_tokens":["自定","定义","插件","自定义"]},{"location":"dev_guide/helloworld/#_3","text":"建议你在写 Python 插件的时候，先做好单元测试，然后再作为插件放到插件目录里运行。 如果你喜欢在真实环境里开发，可以使用 self.logger.info 来打日志（就像前头的代码里做的），你可以实时查看日志： tail -f ~/codelab_adapter/info.log ，日志目录可以通过菜单里的 日志->目录 打开。","text_tokens":["的","-","可以","里","在","~","你","时候","建议","开发","。","像","：","再","如果","打开","喜欢","实时","插件","self","使用","，","单元","info","打","logger","（","就","log",">"," ","做","真实","先","单元测试","前头","/","放到","来","代码","python","目录","运行","_","tail","做好","环境","通过","测试",".","codelab","作为","adapter","然后","f","查看","菜单","写","）","日志"],"title":"调试技巧","title_tokens":["调试","技巧"]},{"location":"dev_guide/helloworld/#_4","text":"你可以在插件中引用哪些 Python 库呢？ 所有的 Python 内置库（json/re/math/……）以及这些第三方库： 第三方模块 。 如果你对 EIM 在 Scratch3 一侧的源码感兴趣，我们也开源出来了，可以自行阅读： scratch3_eim 。 提醒 第三方模块 中有几个采用异步模式(async): aiohttp、hbmqtt、pymata-express。 自定义插件默认以线程运行 run 方法, 配合异步库使用的时候需要注意. 参考 extension_mqtt_broker.py 和 extension_arduino_uno.py","text_tokens":[",","的","(","可以","兴趣","你","呢","引用","内置","线程","如果","我们","自定义","（","async","uno","这些","需要","模式",".","中有","感兴","了","第三","以","所有","哪些","-","一侧","py",":","在","mqtt","时候","hbmqtt","run","extension","…","参考","和",")","/","三方","自定","注意","python","_","中","对","、","提醒","eim","express","arduino","math","aiohttp","。","：","pymata","库","也","，","scratch3","感兴趣","阅读","定义","方法","开源","模块","？","运行","json","以及","自行","默认","异步","）","配合","几个","插件","re","使用","采用"," ","源码","出来","broker","第三方"],"title":"更多","title_tokens":["更","多"]},{"location":"dev_guide/helloworld/#_5","text":"从这个例子中，可以看出写一个自定义的插件是很简单的。而 CodeLab Adapter 对插件要做的事几乎没有任何限制，只要 Python 能做的事，插件系统都能做！就是说你可以自己写一个插件，让 Scratch3 来控制你的蓝牙设备、你的 ROS 机器人、你那跑着 OpenCV 的树莓派或者你童年那辆心爱的玩具四驱车。 enjoy it～","text_tokens":["让","的","可以","一个","机器人","～","你","例子","着","没有","。","跑","it","插件","简单","自定义","，","opencv","树莓","或者","只要","就是","scratch3","派","四驱车","看出"," ","做","事","就是说","enjoy","定义","能","自定","任何","设备","自己","来","python","这个","玩具","都","蓝牙","中","从","系统","！","ros","童年","是","对","很","codelab","、","adapter","限制","那","而","那辆","心爱","要","写","机器","驱车","几乎","控制"],"title":"小结","title_tokens":["小结"]},{"location":"dev_guide/introduction/","text":"介绍 ¶ 欢迎来到开发者文档。 如果你对 CodeLab Adapter 的整体概念，并不熟悉，推荐从 如何开发一个 CodeLab Adapter 插件 入手。","text_tokens":["熟悉","的","开发者","欢迎","并","一个","如何","你","开发","。","文档","如果","整体","插件","推荐","，","概念"," ","来到","不","从","对","codelab","入手","¶","介绍","adapter"],"title":"介绍(introduction)","title_tokens":["介绍",")","introduction","("]},{"location":"dev_guide/introduction/#_1","text":"欢迎来到开发者文档。 如果你对 CodeLab Adapter 的整体概念，并不熟悉，推荐从 如何开发一个 CodeLab Adapter 插件 入手。","text_tokens":["熟悉","的","开发者","欢迎","并","一个","如何","你","开发","。","文档","如果","整体","插件","推荐","，","概念","来到"," ","不","从","对","codelab","入手","adapter"],"title":"介绍","title_tokens":["介绍"]},{"location":"dev_guide/json-message/","text":"json message ¶ 在 hello world 案例中，我们构建了这样一个程序：接收一个来自 Scratch3 的字符串（ hello world ），将其反转后（ dlrow olleh ）返回。 有时候字符串是不够用的，如果我们从 Scratch3 往 CodeLab Adapter extension 传递更复杂的数据结构怎么办呢？ 有两种办法： 自定义 Scratch3 extension，拓展 payload 结构： payload 使用 Scratch3 EIM extension，传递 json 消息。 第二种方式非常简单，不必去碰 Scratch 的东西，只要使用 Python 写 extension 就行，我们在此讨论这种方式。 传递 x、y 坐标 ¶ 设想这样一种应用场景：我们希望使用 Scratch 控制机器人（如 Cozmo）移动到特定的坐标位置 (x,y) 。 我们可以通过以下两个步骤完成： 在 Scratch3 中自定义新的积木 使用 Scratch3 json extension 构建 json 数据 使用 Scratch3 EIM extension 传递消息到 CodeLab Adapter 构建 CodeLab Adapter 插件： extension_robot_xy.py ，在插件中处理传递过来的 (x,y) 在 Scratch3 中自定义新的积木 ¶ 构建 CodeLab Adapter 插件 ¶ import time from codelab_adapter.core_extension import Extension class RobotXYExtension ( Extension ): NODE_ID = \"eim/robot\" s def __init__ ( self ): super () . __init__ () def extension_message_handle ( self , topic , payload ): self . logger . debug ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == dict : x = content [ \"x\" ] y = content [ \"y\" ] self . logger . info ( f 'x:{x}; y:{y}' ) def run ( self ): while self . _running : time . sleep ( 1 ) export = RobotXYExtension 在此，值得注意的是 self.NODE_ID = \"eim/robot\" ，观察前头的截图，可以看出 \"eim/robot\" 与 Scratch3 eim 的积木块的对应关系。 开始测试 ¶ 如果你对如何运行 CodeLab Adapter extension 不熟悉，请参考 hello world 。 json message from CodeLab Adapter to Scratch3 ¶ 前头我们学会了如何将 json 消息从 Scratch3 发往 CodeLab Adapter，接下来我们学习如何将 json 消息从 CodeLab Adapter 发往 Scratch3。 我们来设计这样一个 CodeLab Adapter extension：每秒钟将一个随机的 (x,y) 发往 Scratch3，使用 (x,y) 来控制小猫的位置。 我们来修改 extension_robot_xy.py import time import random from codelab_adapter.core_extension import Extension class RobotXYExtension ( Extension ): NODE_ID = \"eim/robot\" def __init__ ( self ): super () . __init__ () def extension_message_handle ( self , topic , payload ): self . logger . debug ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == dict : x = content [ \"x\" ] y = content [ \"y\" ] self . logger . info ( f 'x:{x}; y:{y}' ) def run ( self ): while self . _running : message = self . message_template () random_x = random . randint ( - 240 , 240 ) random_y = random . randint ( - 180 , 180 ) message [ \"payload\" ][ \"content\" ] = { \"x\" : random_x , \"y\" : random_y } self . publish ( message ) time . sleep ( 1 ) export = RobotXYExtension 重新勾选 extension_robot_xy 插件，现在你可以在 Scratch 中收到 CodeLab Adapte 传过来的 json 数据了！ 在 Scratch 一侧，使用 json 拓展来解析传递过来的消息。 提醒 ¶ 如果不是必要，尽量使用字符串消息。 Scratch 内部的消息就只支持字符串，这是一种很好的设计，因为它简单易理解。","text_tokens":["olleh",",","的","接收","(","步骤","template","应用","一个","可以","debug","第二","你","呢","core","其","接下来","设想","这种","如果","f","1","我们","简单","自定义","观察","现在","就","不够","（","数据","传过来","'","往","用","前头","结构","180","内部","import","]","下来","后","发","设计","scratch","对应",".","去","测试","publish","codelab","怎么","了","adapter","机器","新","关系","因为","特定","值得","勾选","二种","-","一侧","这是","py","第二种","在","机器人",":","时候","两种","处理","\"","cozmo","就行","两个","s","run","每秒","非常","不是","dlrow","self","必要","来自","非常简单","extension","logger","一种","参考",")","content","__","/","world","自定","将","注意","来","python","_","过来","from","中","从","对","碰","通过","、","秒钟","案例","dict","传过","id","复杂","只","robotxyextension","提醒","支持","eim","场景","块","如","熟悉","易","方式","}","handle","传递","topic","如何","控制","有时候","好","。","：","东西","init","收到","数据结构","x",";","，","希望","hello","完成","scratch3","to","randint","构建","此","接下","开始","位置","message","定义","？","运行","以下","！","json","time","y","请","有","很","返回","¶","值得注意","字符","super","while","写","）","{","尽量","截图","export","学会","程序","反转","sleep","字符串","坐标","xy","不必","class","[","插件","随机","使用","理解","积木","info","更","node","=","running","只要","random","讨论"," ","看出","240","每秒钟","它","def","怎么办","与","type","the","不","修改","adapte","是","到","拓展","if","robot","小猫","解析","消息","重新","学习","payload","有时","这样","移动","办法"],"title":"json message","title_tokens":["json"," ","message"]},{"location":"dev_guide/json-message/#json-message","text":"在 hello world 案例中，我们构建了这样一个程序：接收一个来自 Scratch3 的字符串（ hello world ），将其反转后（ dlrow olleh ）返回。 有时候字符串是不够用的，如果我们从 Scratch3 往 CodeLab Adapter extension 传递更复杂的数据结构怎么办呢？ 有两种办法： 自定义 Scratch3 extension，拓展 payload 结构： payload 使用 Scratch3 EIM extension，传递 json 消息。 第二种方式非常简单，不必去碰 Scratch 的东西，只要使用 Python 写 extension 就行，我们在此讨论这种方式。","text_tokens":["olleh","的","接收","一个","第二","呢","其","这种","如果","我们","简单","自定义","不够","（","数据","往","用","结构","后","scratch","去","codelab","怎么","了","adapter","二种","第二种","在","时候","两种","就行","非常","dlrow","来自","非常简单","extension","world","自定","将","python","中","从","碰","案例","复杂","eim","方式","传递","有时候","。","：","东西","数据结构","，","hello","scratch3","构建","此","定义","？","json","有","返回","字符","写","）","程序","反转","字符串","不必","使用","更","只要","讨论"," ","怎么办","是","拓展","消息","payload","有时","这样","办法"],"title":"json message","title_tokens":["json"," ","message"]},{"location":"dev_guide/json-message/#xy","text":"设想这样一种应用场景：我们希望使用 Scratch 控制机器人（如 Cozmo）移动到特定的坐标位置 (x,y) 。 我们可以通过以下两个步骤完成： 在 Scratch3 中自定义新的积木 使用 Scratch3 json extension 构建 json 数据 使用 Scratch3 EIM extension 传递消息到 CodeLab Adapter 构建 CodeLab Adapter 插件： extension_robot_xy.py ，在插件中处理传递过来的 (x,y)","text_tokens":[",","的","步骤","(","应用","可以","py","在","机器人","传递","坐标","xy","处理","。","cozmo","：","两个","设想","x","我们","插件","使用","自定义","积木","，","（","extension","希望","完成","一种","scratch3","数据"," ","构建",")","位置","定义","自定","_","过来","以下","中","新","json","场景","scratch","到","y","通过","这样","robot",".","codelab","adapter","消息","eim","机器","）","特定","控制","移动","如"],"title":"传递 x、y 坐标","title_tokens":["x","、","传递"," ","坐标","y"]},{"location":"dev_guide/json-message/#scratch3","text":"","text_tokens":[],"title":"在 Scratch3 中自定义新的积木","title_tokens":["定义","的","自定义","自定","积木","在","scratch3"," ","中","新"]},{"location":"dev_guide/json-message/#codelab-adapter","text":"import time from codelab_adapter.core_extension import Extension class RobotXYExtension ( Extension ): NODE_ID = \"eim/robot\" s def __init__ ( self ): super () . __init__ () def extension_message_handle ( self , topic , payload ): self . logger . debug ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == dict : x = content [ \"x\" ] y = content [ \"y\" ] self . logger . info ( f 'x:{x}; y:{y}' ) def run ( self ): while self . _running : time . sleep ( 1 ) export = RobotXYExtension 在此，值得注意的是 self.NODE_ID = \"eim/robot\" ，观察前头的截图，可以看出 \"eim/robot\" 与 Scratch3 eim 的积木块的对应关系。","text_tokens":[",","的","(","可以","debug","core","f","1","观察","'","前头","import","]","scratch","对应",".","codelab","adapter","关系","值得",":","在","\"","s","run","self","extension","logger",")","content","__","/","注意","from","_","dict","id","robotxyextension","eim","块","}","handle","topic","。","init","x",";","，","scratch3","此","message","time","y","值得注意","super","while","{","截图","export","sleep","class","[","info","running","=","node","积木"," ","看出","def","与","type","the","是","if","robot","payload"],"title":"构建 CodeLab Adapter 插件","title_tokens":["插件","codelab","adapter"," ","构建"]},{"location":"dev_guide/json-message/#_1","text":"如果你对如何运行 CodeLab Adapter extension 不熟悉，请参考 hello world 。","text_tokens":["熟悉","codelab","，","world","adapter","extension","运行","hello","如何","你","参考"," ","不","。","请","对","如果"],"title":"开始测试","title_tokens":["开始","测试"]},{"location":"dev_guide/json-message/#json-message-from-codelab-adapter-to-scratch3","text":"前头我们学会了如何将 json 消息从 Scratch3 发往 CodeLab Adapter，接下来我们学习如何将 json 消息从 CodeLab Adapter 发往 Scratch3。 我们来设计这样一个 CodeLab Adapter extension：每秒钟将一个随机的 (x,y) 发往 Scratch3，使用 (x,y) 来控制小猫的位置。 我们来修改 extension_robot_xy.py import time import random from codelab_adapter.core_extension import Extension class RobotXYExtension ( Extension ): NODE_ID = \"eim/robot\" def __init__ ( self ): super () . __init__ () def extension_message_handle ( self , topic , payload ): self . logger . debug ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == dict : x = content [ \"x\" ] y = content [ \"y\" ] self . logger . info ( f 'x:{x}; y:{y}' ) def run ( self ): while self . _running : message = self . message_template () random_x = random . randint ( - 240 , 240 ) random_y = random . randint ( - 180 , 180 ) message [ \"payload\" ][ \"content\" ] = { \"x\" : random_x , \"y\" : random_y } self . publish ( message ) time . sleep ( 1 ) export = RobotXYExtension 重新勾选 extension_robot_xy 插件，现在你可以在 Scratch 中收到 CodeLab Adapte 传过来的 json 数据了！ 在 Scratch 一侧，使用 json 拓展来解析传递过来的消息。","text_tokens":[",","的","template","(","可以","一个","debug","你","core","接下来","f","1","我们","现在","数据","传过来","'","往","前头","180","import","]","下来","设计","发","scratch",".","这样","publish","codelab","了","adapter","勾选","-","一侧","py",":","在","\"","每秒","run","self","extension","logger",")","content","__","/","将","来","_","from","过来","从","中","秒钟","dict","传过","id","robotxyextension","eim","}","handle","topic","传递","如何","。","：","init","收到","x",";","，","randint","scratch3","接下","位置","message","！","json","time","y","super","while","{","export","学会","sleep","xy","class","[","随机","插件","使用","info","running","=","random","node"," ","240","每秒钟","def","type","the","修改","adapte","拓展","if","robot","小猫","解析","消息","重新","学习","payload","控制"],"title":"json message from CodeLab Adapter to Scratch3","title_tokens":["message","codelab","adapter","from","to","scratch3"," ","json"]},{"location":"dev_guide/json-message/#_2","text":"如果不是必要，尽量使用字符串消息。 Scratch 内部的消息就只支持字符串，这是一种很好的设计，因为它简单易理解。","text_tokens":["的","这是","易","字符串","好","。","如果","不是","必要","使用","，","就","简单","理解","一种"," ","它","内部","设计","scratch","很","消息","只","字符","支持","因为","尽量"],"title":"提醒","title_tokens":["提醒"]},{"location":"dev_guide/mqtt-Adapter-Node/","text":"MQTT Adapter Node ¶ 提醒 还未迁移到 Adapter 3.0, 推荐先使用 MQTT_adapter 提醒：需要使用 CodeLab Adapter 最新版本 。 通过继承 AdapterMQTTNode ，我们可以利用 MQTT 通道构建 Adapter Node，一旦你理解 MQTT message 的消息细节，就可以在任何平台任何设备上构建 Adapter Node，从超级计算机到单片机。 如果你对 Adapter Node 概念不熟悉，可以参考 这里 。 依赖 ¶ pip install codelab_adapter_mqtt_client Demo ¶ 依然以反转字符串为例： 参考 helloworld_mqtt_node.py import json import time from codelab_adapter_mqtt_client import AdapterMQTTNode from codelab_adapter_mqtt_client.topic import * from loguru import logger class HelloWorldMQTTNode ( AdapterMQTTNode ): def __init__ ( self , * args , ** kwargs ): kwargs [ \"logger\" ] = logger kwargs [ \"external_message_processor\" ] = self . external_message_processor super () . __init__ ( * args , ** kwargs ) self . NODE_ID = \"eim\" def external_message_processor ( self , topic , payload ): self . logger . debug ( payload ) content = payload [ \"zmq_payload\" ][ \"content\" ] NODE_ID = payload [ \"zmq_payload\" ][ \"NODE_ID\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转 payload [ \"zmq_payload\" ][ \"content\" ] = content_send_to_scratch self . publish ( payload ) if __name__ == \"__main__\" : node = HelloWorldMQTTNode () try : node . client . on_message = node . mqtt_on_message node . run () except KeyboardInterrupt : print ( 'Control-C detected. See you soon.' ) node . clean_up () 运行 ¶ 打开 CodeLab Adapter，运行 extension_mqtt_gateway 插件，该插件在 zeromq 与 mqtt 直接进行转换。 运行 helloworld_mqtt_node： python helloworld_mqtt_node.py 让我们在 CodeLab Scratch3 中尝试一下反转字符串： 成功！ AdapterMQTTNode 已经开源在 GitHub 上，如果你对任何细节感到好奇，就把盒子拆开来看吧。 Debug ¶ 新开一个窗口，运行 codelab-mqtt-monitor （随 codelab_adapter_mqtt_client 一起安装），你将能够看到往来的 MQTT message 的内部细节。 想象空间 ¶ 当你通过 codelab-mqtt-monitor 了解了 MQTT message 的内部细节，你就可以使用任何语言的 MQTT client 来构建 Adapter Node！你甚至可以在一个单片机中构建 Adapter Node！ 更多 MQTT tools ¶ 参考 codelab_adapter_mqtt_client#tools for debugging 。","text_tokens":[",","的","算机","(","可以","clean","一个","debug","最新","上","安装","看到","你","demo","继承","如果","pip","1","我们","利用","就","send","概念","（","zmq","想象","control","'","一起","print","设备","拆开","内部","external","迁移","import","keyboardinterrupt","]","通道","平台","需要","scratch","甚至",".","publish","盒子","新开","codelab","for","adapter","了","以","已经","让","-","一旦","py",":","在","好奇","mqtt","\"","gateway","install","run","还","try","self","kwargs","语言","随","logger","extension","一下","参考","成功",")","content","往来","__","任何","将","up","来","python","_","from","从","中","c","吧","计算机","对","通过","来看","单片","这里","id","tools","提醒","当","eim","helloworld","熟悉","未","str","*","能够","超级计算机","依赖","topic","尝试","。","：","see","debugging","init","打开","推荐","，","超级","soon","to","#","细节","scratch3","构建","单片机","直接","为例","message","开源","运行","多","！","把","该","json","time","monitor","github","helloworldmqttnode","¶","依然","processor","字符","super","main","client","进行","）","空间","版本","on","反转","字符串","args","感到","class","[","zeromq","插件","理解","使用","转换","=","node","更"," ","def","先","窗口","loguru","与","type","except","不","adaptermqttnode","you","detected","到","if","计算","消息","name","3.0","了解","payload"],"title":"MQTT Adapter Node(正在迁移中)","title_tokens":["正在","(","adapter","node","迁移","mqtt"," ","中",")"]},{"location":"dev_guide/mqtt-Adapter-Node/#mqtt-adapter-node","text":"提醒 还未迁移到 Adapter 3.0, 推荐先使用 MQTT_adapter 提醒：需要使用 CodeLab Adapter 最新版本 。 通过继承 AdapterMQTTNode ，我们可以利用 MQTT 通道构建 Adapter Node，一旦你理解 MQTT message 的消息细节，就可以在任何平台任何设备上构建 Adapter Node，从超级计算机到单片机。 如果你对 Adapter Node 概念不熟悉，可以参考 这里 。","text_tokens":[",","未","熟悉","的","算机","版本","一旦","超级计算机","可以","在","最新","上","mqtt","你","。","：","继承","如果","还","我们","推荐","使用","，","利用","理解","就","node","超级","概念","参考","细节"," ","构建","单片机","先","message","任何","设备","迁移","_","不","adaptermqttnode","通道","从","计算机","到","需要","平台","对","通过","单片","这里","codelab","计算","adapter","消息","3.0","提醒"],"title":"MQTT Adapter Node","title_tokens":["mqtt","node"," ","adapter"]},{"location":"dev_guide/mqtt-Adapter-Node/#_1","text":"pip install codelab_adapter_mqtt_client","text_tokens":["pip","codelab","adapter","_","mqtt"," ","client","install"],"title":"依赖","title_tokens":["依赖"]},{"location":"dev_guide/mqtt-Adapter-Node/#demo","text":"依然以反转字符串为例： 参考 helloworld_mqtt_node.py import json import time from codelab_adapter_mqtt_client import AdapterMQTTNode from codelab_adapter_mqtt_client.topic import * from loguru import logger class HelloWorldMQTTNode ( AdapterMQTTNode ): def __init__ ( self , * args , ** kwargs ): kwargs [ \"logger\" ] = logger kwargs [ \"external_message_processor\" ] = self . external_message_processor super () . __init__ ( * args , ** kwargs ) self . NODE_ID = \"eim\" def external_message_processor ( self , topic , payload ): self . logger . debug ( payload ) content = payload [ \"zmq_payload\" ][ \"content\" ] NODE_ID = payload [ \"zmq_payload\" ][ \"NODE_ID\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转 payload [ \"zmq_payload\" ][ \"content\" ] = content_send_to_scratch self . publish ( payload ) if __name__ == \"__main__\" : node = HelloWorldMQTTNode () try : node . client . on_message = node . mqtt_on_message node . run () except KeyboardInterrupt : print ( 'Control-C detected. See you soon.' ) node . clean_up ()","text_tokens":[",","(","clean","debug","1","send","zmq","control","'","print","external","import","keyboardinterrupt","]","scratch",".","publish","codelab","adapter","以","-","py",":","mqtt","\"","run","try","self","kwargs","logger","参考",")","content","__","up","_","from","c","id","eim","helloworld","str","*","topic","：","see","init","soon","to","#","为例","message","time","json","helloworldmqttnode","依然","processor","字符","super","main","client","on","反转","字符串","args","class","[","=","node"," ","def","loguru","type","except","you","adaptermqttnode","detected","if","name","payload"],"title":"Demo","title_tokens":["demo"]},{"location":"dev_guide/mqtt-Adapter-Node/#_2","text":"打开 CodeLab Adapter，运行 extension_mqtt_gateway 插件，该插件在 zeromq 与 mqtt 直接进行转换。 运行 helloworld_mqtt_node： python helloworld_mqtt_node.py 让我们在 CodeLab Scratch3 中尝试一下反转字符串： 成功！ AdapterMQTTNode 已经开源在 GitHub 上，如果你对任何细节感到好奇，就把盒子拆开来看吧。","text_tokens":["让","py","在","反转","尝试","上","mqtt","字符串","你","感到","好奇","。","gateway","：","打开","如果","zeromq","插件","我们","就","，","转换","extension","node","一下","scratch3","细节"," ","成功","直接","开源","任何","拆开","与","运行","python","_","中","！","adaptermqttnode","该","把","吧","对","来看","github",".","盒子","codelab","adapter","字符","进行","helloworld","已经"],"title":"运行","title_tokens":["运行"]},{"location":"dev_guide/mqtt-Adapter-Node/#debug","text":"新开一个窗口，运行 codelab-mqtt-monitor （随 codelab_adapter_mqtt_client 一起安装），你将能够看到往来的 MQTT message 的内部细节。","text_tokens":["的","-","能够","安装","一个","看到","mqtt","你","。","，","随","（","细节"," ","一起","往来","窗口","message","将","内部","运行","_","monitor","新开","codelab","adapter","client","）"],"title":"Debug","title_tokens":["debug"]},{"location":"dev_guide/mqtt-Adapter-Node/#_3","text":"当你通过 codelab-mqtt-monitor 了解了 MQTT message 的内部细节，你就可以使用任何语言的 MQTT client 来构建 Adapter Node！你甚至可以在一个单片机中构建 Adapter Node！","text_tokens":["的","-","可以","一个","在","你","mqtt","就","使用","，","语言","node","细节"," ","构建","单片机","message","任何","来","内部","！","中","甚至","monitor","通过","单片","codelab","了","adapter","了解","当","client"],"title":"想象空间","title_tokens":["空间","想象"]},{"location":"dev_guide/mqtt-Adapter-Node/#mqtt-tools","text":"参考 codelab_adapter_mqtt_client#tools for debugging 。","text_tokens":["codelab","for","adapter","_","参考","mqtt"," ","#","tools","client","。","debugging"],"title":"更多 MQTT tools","title_tokens":["更","多","mqtt","tools"," "]},{"location":"dev_guide/multi-language-support/","text":"编程语言支持 ¶ CodeLab Adapter的核心是一个消息系统，它是平台和编程语言无关的，理论上你可以使用任何编程语言来扩展CodeLab Adapter。 我们正在陆续构建多种语言的CodeLab Adapter client。 如果你只需要简单集成，参考 与其他编程语言集成 ,目前已经给出30+种编程语言的例子。 当前文档展示的是深度集成(ZeroMQ client)。 nodejs ¶ 以下展示如何在nodejs中构建 Adapter Node 。依然是以反转字符串为例。 首先安装依赖: npm i codelab_adapter_client_nodejs , 接着随便找个地方, 创建脚本文件: hello_world.js : const AdapterNode = require ( 'codelab_adapter_client_nodejs' ); const ADAPTER_TOPIC = \"adapter/nodes/data\" ; class HelloWorldNode extends AdapterNode { constructor () { super ({ name : \"EIMNode\" }); this . num = 0 ; this . receive_loop (); } message_handle ( topic , payload ) { console . log ( `from scratch: topic: ${ topic } , payload: ${ JSON . stringify ( payload ) } ` ); const content = payload . content ; const reverse_content = content . split ( \"\" ) . reverse () . join ( \"\" ); const message = { topic : ADAPTER_TOPIC , payload : { content : reverse_content , node_id : 'eim' } }; this . publish_payload ( message . payload , message . topic ); } pub_message () { this . num += 1 ; const message = { topic : ADAPTER_TOPIC , payload : { content : this . num } }; this . publish_payload ( message . payload , message . topic ); } run () { this . pub_message (); } } try { m = new HelloWorldNode (); m . run (); } catch ( err ) { console . log ( err ); process . exit (); } 运行CodeLab Adapter（作为消息中心）, 运行我们的拓展: node hello_world.js 让我们在 CodeLab Scratch3 中尝试一下反转字符串: 成功！ LISP ¶ 依赖: pip install hy hy 是一门LISP方言，构建在Python之上，可以使用Python生态里的所有库。于是我们可以很方便地构建Adapter Node: hello_world.hy ( import codelab_adapter_client ) ( import time ) ( defclass HelloWorldNode [codelab_adapter_client.AdapterNode] \"LISP hello world node\" ( defn --init-- [self] ( . --init-- ( super )) ( setv self.NODE_ID \"eim\" )) ( defn extension-message-handle [self topic payload] ( print f \"the message payload from scratch: {payload}\" ) ( setv content ( list ( get payload \"content\" ))) ( . reverse content ) ( payload.__setitem__ \"content\" ( . join \"\" content )) ( print payload ) ( self.publish { \"payload\" payload} ) ) ( defn run [self] ( while self._running ( time.sleep 1 ))) ) ( setv node ( HelloWorldNode )) ( . receive-loop-as-thread node ) ( . run node ) 运行CodeLab Adapter（作为消息中心）, 运行我们的拓展: hy hello_world.hy 很多Python内置函数没有写成LISP风格，所以看起来没什么LISP风味，更多Python风味。 SmallTalk ¶ Ruby ¶","text_tokens":[",","的","扩展","(","可以","一个","安装","const","process","上","exit","所以","你","data","内置","如果","pip","1","f","我们","多种语言","简单","constructor","（","require","地","风格","setv","err","'","._","as","print","多种","import","什么","]","看起来","平台","需要","scratch","找个","js","extends",".","publish","随便","codelab","list","作为","adapter","helloworldnode","reverse","理论","+","以","console","接着","所有","已经","无关","让","-","生态",":","在","\"","没有","install","nodes","run","defn","风味","try","self","语言","编程语言","extension","一下","参考","pub","成功","文件","30","和","i",")","content","get","地方","__","核心","m","/","任何","world","join","来","python","当前","_","from","setitem","中","首先","stringify","lisp","id","thread","只","支持","eim","split","陆续","展示","于是","}","函数","依赖","topic","handle","如何","尝试","集成",".__","例子","看起","。","文档","很多","0","init",";","深度","库","，","hello","scratch3","hy","之上","构建","脚本","为例","起来","message","写成","运行","多","以下","`","！","系统","方言","json","time","很","¶","依然","catch","其他","字符","super","while","client","ruby","{","）","正在","里","反转","receive","种","sleep","字符串","方便","loop","class","eimnode","[","zeromq","使用","log","smalltalk","running","=","node","$","更","new"," ","num","它","编程","adapternode","与","中心","this","the","defclass","给出","是","拓展","npm","一门","消息","name","nodejs","没什么","payload","目前","创建"],"title":"编程语言深度支持(multi language support)","title_tokens":["深度","(","语言","multi","编程语言","支持"," ","language","support",")","编程"]},{"location":"dev_guide/multi-language-support/#_1","text":"CodeLab Adapter的核心是一个消息系统，它是平台和编程语言无关的，理论上你可以使用任何编程语言来扩展CodeLab Adapter。 我们正在陆续构建多种语言的CodeLab Adapter client。 如果你只需要简单集成，参考 与其他编程语言集成 ,目前已经给出30+种编程语言的例子。 当前文档展示的是深度集成(ZeroMQ client)。","text_tokens":[",","展示","正在","的","扩展","(","可以","一个","上","种","你","集成","例子","。","文档","如果","zeromq","深度","我们","多种语言","使用","，","语言","简单","编程语言","已经","参考"," ","30","构建","和","它",")","编程","核心","任何","来","与","多种","当前","系统","给出","平台","是","需要","codelab","adapter","消息","其他","只","理论","+","client","目前","陆续","无关"],"title":"编程语言支持","title_tokens":["语言","编程语言","支持","编程"]},{"location":"dev_guide/multi-language-support/#nodejs","text":"以下展示如何在nodejs中构建 Adapter Node 。依然是以反转字符串为例。 首先安装依赖: npm i codelab_adapter_client_nodejs , 接着随便找个地方, 创建脚本文件: hello_world.js : const AdapterNode = require ( 'codelab_adapter_client_nodejs' ); const ADAPTER_TOPIC = \"adapter/nodes/data\" ; class HelloWorldNode extends AdapterNode { constructor () { super ({ name : \"EIMNode\" }); this . num = 0 ; this . receive_loop (); } message_handle ( topic , payload ) { console . log ( `from scratch: topic: ${ topic } , payload: ${ JSON . stringify ( payload ) } ` ); const content = payload . content ; const reverse_content = content . split ( \"\" ) . reverse () . join ( \"\" ); const message = { topic : ADAPTER_TOPIC , payload : { content : reverse_content , node_id : 'eim' } }; this . publish_payload ( message . payload , message . topic ); } pub_message () { this . num += 1 ; const message = { topic : ADAPTER_TOPIC , payload : { content : this . num } }; this . publish_payload ( message . payload , message . topic ); } run () { this . pub_message (); } } try { m = new HelloWorldNode (); m . run (); } catch ( err ) { console . log ( err ); process . exit (); } 运行CodeLab Adapter（作为消息中心）, 运行我们的拓展: node hello_world.js 让我们在 CodeLab Scratch3 中尝试一下反转字符串: 成功！","text_tokens":[",","的","(","安装","process","const","exit","data","1","constructor","我们","（","require","err","'","scratch","找个","js","extends",".","publish","随便","codelab","作为","adapter","helloworldnode","reverse","+","以","console","接着","让",":","在","\"","nodes","run","try","一下","pub","成功","文件","i",")","content","地方","m","/","world","join","_","from","中","首先","id","eim","split","展示","}","依赖","topic","handle","如何","尝试","。","0",";","hello","scratch3","构建","脚本","为例","message","运行","以下","`","！","json","依然","catch","字符","super","client","{","）","反转","receive","字符串","loop","class","eimnode","log","=","node","$","new"," ","num","adapternode","中心","this","是","拓展","npm","name","消息","nodejs","payload","stringify","创建"],"title":"nodejs","title_tokens":["nodejs"]},{"location":"dev_guide/multi-language-support/#lisp","text":"依赖: pip install hy hy 是一门LISP方言，构建在Python之上，可以使用Python生态里的所有库。于是我们可以很方便地构建Adapter Node: hello_world.hy ( import codelab_adapter_client ) ( import time ) ( defclass HelloWorldNode [codelab_adapter_client.AdapterNode] \"LISP hello world node\" ( defn --init-- [self] ( . --init-- ( super )) ( setv self.NODE_ID \"eim\" )) ( defn extension-message-handle [self topic payload] ( print f \"the message payload from scratch: {payload}\" ) ( setv content ( list ( get payload \"content\" ))) ( . reverse content ) ( payload.__setitem__ \"content\" ( . join \"\" content )) ( print payload ) ( self.publish { \"payload\" payload} ) ) ( defn run [self] ( while self._running ( time.sleep 1 ))) ) ( setv node ( HelloWorldNode )) ( . receive-loop-as-thread node ) ( . run node ) 运行CodeLab Adapter（作为消息中心）, 运行我们的拓展: hy hello_world.hy 很多Python内置函数没有写成LISP风格，所以看起来没什么LISP风味，更多Python风味。","text_tokens":[",","的","(","可以","所以","内置","pip","f","1","我们","（","地","风格","setv","._","as","print","import","什么","]","看起来","scratch",".","publish","codelab","list","作为","adapter","helloworldnode","reverse","所有","-","生态",":","在","\"","没有","install","run","defn","风味","self","extension",")","content","get","__","world","join","python","setitem","_","from","lisp","id","thread","eim","于是","}","函数","依赖","handle","topic",".__","看起","。","很多","init","库","，","hello","hy","之上","构建","起来","message","写成","运行","多","方言","time","很","super","while","client","{","）","里","receive","sleep","方便","loop","[","使用","running","更","node"," ","adapternode","中心","the","defclass","是","拓展","一门","消息","没什么","payload"],"title":"LISP","title_tokens":["lisp"]},{"location":"dev_guide/multi-language-support/#smalltalk","text":"","text_tokens":[],"title":"SmallTalk","title_tokens":["smalltalk"]},{"location":"dev_guide/multi-language-support/#ruby","text":"","text_tokens":[],"title":"Ruby","title_tokens":["ruby"]},{"location":"dev_guide/security/","text":"安全性 ¶ 2.5.x 版本主要围绕安全性在做一些工作。 REST API ¶ 2.5.0 之后， REST API 默认禁用，你需要通过 用户配置文件 启用它。 WEBSOCKET API ¶ 如果你只是将 CodeLab Adapter 当作 message hub（空间编程），你也通过设置 OPEN_WEBSOCKET_API = False ，WEBSOCKET API 将被禁用，那样 Web UI 将无法起作用。 ZeroMQ ¶ 默认只接受本地（127.0.0.1）创建的 Adapter Node 的 ZeroMQ 消息， 如果你希望构建分布式应用，请设置 OPEN_MESSAGE_HUB=True ，那样 CodeLab Adapter 将接受来自其他机器的 ZeroMQ 连接请求。 当 MESSAGE_HUB 处于 open 状态时，如何保证安全呢？答案是：使用 token。 MQTT ¶ 如果你要使用 MQTT gateway，出于安全性考虑，请替换为自己的 mqtt uri，默认的插件使用开放的账号。 Python Kernel ¶ 考虑到运行真实 Python 代码的风险，2.5.0 之后，我们 使用 eval 替代 exec ，并且对其做了限制，尽管如此，黑客社区依然有针对 eval 的精妙攻击方式。 所以我们使用 verify_token 验证请求的消息是否携带 token，考虑到兼容性，目前来自 WEBSOCKET API 的消息，默认被加上 token，所以我们在未来版本中将考虑对请求域名做检验。 如果你构建了安全攸关的应用，请考虑使用 verify_token 校验 token。 Tip 如果你希望像原先那样，真实地运行完整的 Python 代码，原先的插件在这儿: extension_python_kernel_exec.py(v2) 。 Tip 如果你只是希望在浏览器中教学 Python 语法，在浏览器中运行的 Brython 可能是更好的的选择。","text_tokens":["的","(","时","用户","应用","所以","攸关","替换","教学","你","布式","呢","其","尽管","如果","容性","我们","（","kernel","地","保证","做","目前","浏览器","这儿","websocket","社区","携带","出于","检验","需要",".","为","替代","兼容","codelab","只是","adapter","了","限制","账号","设置","要","机器","验证","本地","py","可能",":","在","主要","请求","mqtt","exec","未来","如此","gateway","开放","hub","ui","处于","来自","token","之后","tip","extension","文件","当作","0.1","被","真实",")","更好","将","自己","python","启用","_","中","对","通过","考虑","false","配置","配置文件","那样","只","当","并且","工作","是否","校验","方式","浏览","兼容性","如何","。","：","0","尽管如此","x","无法","也","加上","，","web","希望","分布式","分布","状态","构建","连接","message","安全性","中将","？","运行","接受","分布式应用","请","有","true","¶","依然","其他","默认","语法","127.0","api","）","空间","围绕","精妙","攻击","版本","禁用","风险","针对","作用","攻击方式","像","zeromq","起","插件","使用","=","node"," ","eval","它","open","编程","安全","黑客","代码","uri","完整","一些","rest","是","到","verify","域名","v2","brython","原先","2.5","消息","选择","答案","创建"],"title":"安全性(security)","title_tokens":["安全","security","(","安全性",")"]},{"location":"dev_guide/security/#_1","text":"2.5.x 版本主要围绕安全性在做一些工作。","text_tokens":[".","x","安全","版本","2.5","安全性","在","主要"," ","做","一些","。","围绕","工作"],"title":"安全性","title_tokens":["安全性","安全"]},{"location":"dev_guide/security/#rest-api","text":"2.5.0 之后， REST API 默认禁用，你需要通过 用户配置文件 启用它。","text_tokens":["用户","禁用","你","。","0","，","之后"," ","文件","它","启用","rest","需要","通过",".","配置","2.5","配置文件","默认","api"],"title":"REST API","title_tokens":["rest"," ","api"]},{"location":"dev_guide/security/#websocket-api","text":"如果你只是将 CodeLab Adapter 当作 message hub（空间编程），你也通过设置 OPEN_WEBSOCKET_API = False ，WEBSOCKET API 将被禁用，那样 Web UI 将无法起作用。","text_tokens":["禁用","你","作用","。","如果","hub","ui","也","无法","起","，","=","（","web"," ","当作","被","open","编程","message","websocket","将","_","通过","false","codelab","只是","adapter","设置","那样","api","）","空间"],"title":"WEBSOCKET API","title_tokens":[" ","websocket","api"]},{"location":"dev_guide/security/#zeromq","text":"默认只接受本地（127.0.0.1）创建的 Adapter Node 的 ZeroMQ 消息， 如果你希望构建分布式应用，请设置 OPEN_MESSAGE_HUB=True ，那样 CodeLab Adapter 将接受来自其他机器的 ZeroMQ 连接请求。 当 MESSAGE_HUB 处于 open 状态时，如何保证安全呢？答案是：使用 token。","text_tokens":["的","本地","时","应用","请求","如何","你","布式","呢","。","：","如果","zeromq","hub","使用","，","处于","来自","=","（","node","希望","token","分布式","保证","分布"," ","状态","0.1","构建","连接","open","message","安全","将","？","_","是","接受","分布式应用","请",".","true","codelab","adapter","消息","其他","默认","127.0","设置","只","那样","当","机器","答案","）","创建"],"title":"ZeroMQ","title_tokens":["zeromq"]},{"location":"dev_guide/security/#mqtt","text":"如果你要使用 MQTT gateway，出于安全性考虑，请替换为自己的 mqtt uri，默认的插件使用开放的账号。","text_tokens":["的","替换","你","mqtt","gateway","开放","。","如果","插件","使用","，"," ","安全","安全性","自己","uri","请","考虑","为","默认","账号","要","出于"],"title":"MQTT","title_tokens":["mqtt"]},{"location":"dev_guide/security/#python-kernel","text":"考虑到运行真实 Python 代码的风险，2.5.0 之后，我们 使用 eval 替代 exec ，并且对其做了限制，尽管如此，黑客社区依然有针对 eval 的精妙攻击方式。 所以我们使用 verify_token 验证请求的消息是否携带 token，考虑到兼容性，目前来自 WEBSOCKET API 的消息，默认被加上 token，所以我们在未来版本中将考虑对请求域名做检验。 如果你构建了安全攸关的应用，请考虑使用 verify_token 校验 token。 Tip 如果你希望像原先那样，真实地运行完整的 Python 代码，原先的插件在这儿: extension_python_kernel_exec.py(v2) 。 Tip 如果你只是希望在浏览器中教学 Python 语法，在浏览器中运行的 Brython 可能是更好的的选择。","text_tokens":["的","(","应用","所以","攸关","教学","你","其","尽管","如果","容性","我们","地","kernel","做","浏览器","这儿","携带","社区","websocket","检验",".","替代","兼容","只是","了","限制","验证","py","可能",":","在","请求","exec","未来","如此","token","来自","之后","tip","extension","被","真实",")","更好","python","_","中","对","考虑","那样","并且","是否","校验","方式","浏览","兼容性","。","0","尽管如此","加上","，","希望","构建","中将","运行","请","有","依然","语法","默认","api","精妙","攻击","版本","风险","针对","攻击方式","像","插件","使用"," ","eval","安全","黑客","代码","完整","到","是","域名","verify","v2","brython","原先","2.5","消息","选择","目前"],"title":"Python Kernel","title_tokens":[" ","kernel","python"]},{"location":"dev_guide/sync-message/","text":"同步风格的消息 ¶ 问题 ¶ 有开发者在 issue 提了这个问题： 怎么处理异步发送的消息，如何等待它成功执行返回？ 同步通信的过程可以由下图表示： 如果你熟悉 http，就会看出它们是相似的。 如果你熟悉 ROS ，可能会觉得，同步模式类似 service，异步模式类似 action。 思路 ¶ 无论是 websocket 还是 ZeroMQ pub/sub，都是异步的。 我们如何在异步中实现，同步模式呢？策略是使用 message_id。 目前 Scratch EIM 已经支持同步风格的积木（阻塞风格）。 实现 ¶ 这些同步风格的积木需要与同步风格的 CodeLab Adapter 插件一起使用。让我们来实现它。 Sync extension ¶ 功能依然是反转字符串，在同步插件中，完成反转字符串功能，需要一秒钟。 以下是插件源码： extension_sync_helloworld.py import time from codelab_adapter.core_extension import Extension class SyncHelloWorldExtension ( Extension ): def __init__ ( self ): super () . __init__ () self . NODE_ID = \"eim\" def send_message_to_scratch ( self , payload ): message = self . message_template () message [ \"payload\" ] = payload self . publish ( message ) def extension_message_handle ( self , topic , payload ): self . logger . info ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转字符串 time . sleep ( 1 ) payload [ \"content\" ] = content_send_to_scratch self . send_message_to_scratch ( payload ) def run ( self ): while self . _running : time . sleep ( 1 ) export = SyncHelloWorldExtension 通过与 hello world 教程 的对比，可以看出同步消息与异步消息在 CodeLab Adapter 插件一侧的区别：通过返回来自 Scratch 的消息中携带的 message_id（message_id 在 payload 中，通过观察日志，可以看到 payload 内部细节）。让请求者得知当前消息被响应了。 同步消息与异步消息，在 Scratch 插件一侧的区别表现为不同的积木（是否 wait/等待 ），js 代码层面的差异表现在： 发送消息的函数不同 ，这部分你可以直接使用 EIM 插件，可以不做深究。 刷新 Web UI，点击运行 extension_hello_world.py ，接着你就可以在 Scratch 中与你的插件交互了。 如果你将 5 个上图中的积木拼在一起，它们将依次运行，一共耗时 5 秒。 FAQ ¶ 如果某个积木，在 wait 的过程中，没有得到响应会发生什么？ 超时时间是 5 秒，所以 5 秒后会继续往下运行。 参考: ¶ codelab-adapter 与应答模式","text_tokens":[",","的","提了","(","template","可以","所以","看到","上","你","呢","core","wait","超时","开发","部分","深究","执行","如果","f","1","我们","就","类似","观察","风格","（","send","做","'","问题","往","sync","一起","发生","websocket","携带","内部","synchelloworldextension","功能","import","什么","无论是","]","ros","一共","这些","后会","scratch","通信","需要","js","模式",".","publish","为","codelab","怎么","adapter","了","应答","得到","下","会","区别","点击","接着","已经","让","这部","-","一侧","可能","py",":","在","实现","请求","处理","\"","没有","run","ui","self","来自","extension","logger","参考","pub","成功","拼在一起","耗时","请求者","被","差异",")","content","响应","__","/","world","将","来","等待","当前","_","from","中","过程","某个","通过","通过观察","秒钟","id","支持","发送","eim","issue","helloworld","熟悉","str","觉得","是否","它们","}","表示","函数","handle","topic","秒","如何","思路","。","：","init","，","faq","web","由","完成","to","#","hello","细节","表现","不同","得知","action","刷新","直接","无论","相似","message","图","教程","？","运行","以下","time","这部分","有","返回","还是","¶","依然","一秒","交互","继续","字符","super","while","异步","）","{","日志","export","开发者","下图","反转","sleep","字符串","对比","同步","一秒钟","class","[","zeromq","插件","使用","积木","info","service","node","=","running"," ","看出","时间","它","个","def","http","sub","与","type","代码","这个","都","the","不","依次","层面","是","源码","if","阻塞","消息","5","payload","目前","策略"],"title":"同步风格的消息(sync message)","title_tokens":["的","message","(","消息","风格"," ","同步",")","sync"]},{"location":"dev_guide/sync-message/#_1","text":"","text_tokens":[],"title":"同步风格的消息","title_tokens":["同步","消息","风格","的"]},{"location":"dev_guide/sync-message/#_2","text":"有开发者在 issue 提了这个问题： 怎么处理异步发送的消息，如何等待它成功执行返回？ 同步通信的过程可以由下图表示： 如果你熟悉 http，就会看出它们是相似的。 如果你熟悉 ROS ，可能会觉得，同步模式类似 service，异步模式类似 action。","text_tokens":["熟悉","觉得","的","提了","开发者","它们","表示","可以","下图","可能","在","如何","你","处理","开发","同步","：","。","执行","如果","就","类似","，","service","由"," ","成功","看出","action","它","问题","http","相似","等待","？","这个","ros","过程","是","通信","有","模式","返回","怎么","消息","发送","异步","会","issue"],"title":"问题","title_tokens":["问题"]},{"location":"dev_guide/sync-message/#_3","text":"无论是 websocket 还是 ZeroMQ pub/sub，都是异步的。 我们如何在异步中实现，同步模式呢？策略是使用 message_id。 目前 Scratch EIM 已经支持同步风格的积木（阻塞风格）。","text_tokens":["的","在","实现","如何","呢","。","同步","zeromq","我们","使用","，","积木","风格","（","pub"," ","无论","message","websocket","/","sub","？","_","都","无论是","中","是","scratch","模式","还是","阻塞","id","支持","异步","eim","目前","策略","）","已经"],"title":"思路","title_tokens":["思路"]},{"location":"dev_guide/sync-message/#_4","text":"这些同步风格的积木需要与同步风格的 CodeLab Adapter 插件一起使用。让我们来实现它。","text_tokens":["让","的","实现","。","同步","插件","我们","使用","积木","风格"," ","它","一起","与","来","这些","需要","codelab","adapter"],"title":"实现","title_tokens":["实现"]},{"location":"dev_guide/sync-message/#sync-extension","text":"功能依然是反转字符串，在同步插件中，完成反转字符串功能，需要一秒钟。 以下是插件源码： extension_sync_helloworld.py import time from codelab_adapter.core_extension import Extension class SyncHelloWorldExtension ( Extension ): def __init__ ( self ): super () . __init__ () self . NODE_ID = \"eim\" def send_message_to_scratch ( self , payload ): message = self . message_template () message [ \"payload\" ] = payload self . publish ( message ) def extension_message_handle ( self , topic , payload ): self . logger . info ( f 'the message payload from scratch: {payload}' ) content = payload [ \"content\" ] if type ( content ) == str : content_send_to_scratch = content [:: - 1 ] # 反转字符串 time . sleep ( 1 ) payload [ \"content\" ] = content_send_to_scratch self . send_message_to_scratch ( payload ) def run ( self ): while self . _running : time . sleep ( 1 ) export = SyncHelloWorldExtension 通过与 hello world 教程 的对比，可以看出同步消息与异步消息在 CodeLab Adapter 插件一侧的区别：通过返回来自 Scratch 的消息中携带的 message_id（message_id 在 payload 中，通过观察日志，可以看到 payload 内部细节）。让请求者得知当前消息被响应了。 同步消息与异步消息，在 Scratch 插件一侧的区别表现为不同的积木（是否 wait/等待 ），js 代码层面的差异表现在： 发送消息的函数不同 ，这部分你可以直接使用 EIM 插件，可以不做深究。 刷新 Web UI，点击运行 extension_hello_world.py ，接着你就可以在 Scratch 中与你的插件交互了。 如果你将 5 个上图中的积木拼在一起，它们将依次运行，一共耗时 5 秒。","text_tokens":[",","的","template","(","可以","看到","上","你","core","wait","部分","深究","如果","f","1","就","观察","send","（","做","'","sync","一起","携带","内部","synchelloworldextension","功能","import","]","一共","需要","scratch","js",".","publish","为","codelab","adapter","了","接着","区别","点击","让","这部","-","一侧","py",":","在","请求","\"","run","ui","self","来自","extension","logger","拼在一起","耗时","请求者","被","差异",")","content","响应","__","/","world","将","等待","当前","_","from","中","通过","通过观察","秒钟","id","发送","eim","helloworld","str","是否","}","它们","函数","handle","topic","秒","。","：","init","，","web","完成","hello","to","#","细节","表现","刷新","不同","得知","直接","message","图","教程","运行","以下","time","这部分","返回","依然","一秒","交互","字符","super","while","异步","{","日志","）","export","反转","sleep","字符串","对比","一秒钟","同步","class","[","插件","使用","info","running","=","node","积木"," ","看出","个","def","与","type","代码","the","不","依次","层面","是","源码","if","消息","5","payload"],"title":"Sync extension","title_tokens":[" ","extension","sync"]},{"location":"dev_guide/sync-message/#faq","text":"如果某个积木，在 wait 的过程中，没有得到响应会发生什么？ 超时时间是 5 秒，所以 5 秒后会继续往下运行。","text_tokens":["的","所以","在","秒","wait","超时","没有","。","如果","，","积木"," ","时间","往","响应","发生","？","运行","什么","中","过程","后会","是","某个","5","继续","得到","下","会"],"title":"FAQ","title_tokens":["faq"]},{"location":"dev_guide/sync-message/#_5","text":"codelab-adapter 与应答模式","text_tokens":["模式","-","codelab","adapter","与","应答"," "],"title":"参考:","title_tokens":["参考",":"]},{"location":"dev_guide/system_command/","text":"codelab-message-pub 系统命令 ¶ 安装完 codelab_adapter_client 之后，将生成 codelab-message-pub 系统命令，它方便用来将 CodeLab Adapter 与其他编程语言做集成，我们展示了与 30+ 种编程语言结合的例子。 Unix/Linux 操作系统仅仅使用信号（signal）便能构建非常复杂的协同程序。Erlang 从 SmallTalk 那儿学到仅使用 message 来协同程序，message 是个极其强大的概念。 CodeLab Adapter 的核心设计思路是： Everything Is a Message （EIM），我们在最新的 codelab_adapter_client 版本中，为其加入系统命令，方便在其他语言构建的程序中往 CodeLab Adapter 发送消息，这样一来，你就可以使用任何编程语言为 Scratch 构建插件，或者为 CodeLab Adapter 构建插件。 典型使用案例： ¶ 在 CodeLab 内部，我们的魔杖程序（使用魔杖控制空间里的事物）的机器视觉（CV）部分是使用 C++ 写的（因为深度相机的 C++ SDK 比较完备），为了让深度相机与 Scratch 协同工作， codelab-message-pub 便是理想的选择，它能够将消息的触角延伸到任何编程语言里。 codelab-message-pub ¶ 安装 ¶ pip install codelab_adapter_client --upgrade 确保 codelab_adapter_client >= 1.6.2 使用帮助 ¶ > codelab-message-pub -h usage: codelab-message-pub [ -h ] [ -i CODELAB_ADAPTER_IP_ADDRESS ] [ -n NAME ] [ -p PUBLISHER_PORT ] [ -s SUBSCRIBER_PORT ] [ -t TOPIC ] [ -d NODE_ID ] [ -c CONTENT ] [ -j JSON_MESSAGE ] optional arguments: -h, --help show this help message and exit -i CODELAB_ADAPTER_IP_ADDRESS None or IP address used by CodeLab Adapter -n NAME Set name in banner -p PUBLISHER_PORT Publisher IP port -s SUBSCRIBER_PORT Subscriber IP port -t TOPIC message topic -d NODE_ID node id -c CONTENT payload [ 'content' ] -j JSON_MESSAGE json message ( with topic and payload ) 使用方法 ¶ > codelab-message-pub -t hello_topic > codelab-message-pub -c hello_content > codelab-message-pub -j '{\"payload\":{\"content\":\"test contenst\", \"token\":\"xxx\"}}' 使用 codelab-message-pub 时记得先打开 CodeLab Adapter。 支持语言 ¶ 以下是我们给出的主流/非主流编程语言与 codelab-message-pub 集成的范例，本质上是系统调用。 部分编程语言使用 labstack 测试。 C++ ¶ #include <stdio.h> #include <stdlib.h> int main () { system ( \"codelab-message-pub -c hello_content\" ); } Rust ¶ // https://doc.rust-lang.org/book/ch01-02-hello-world.html // https://doc.rust-lang.org/std/process/struct.Command.html // https://stackoverflow.com/questions/21011330/how-do-i-invoke-a-system-command-in-rust-and-capture-its-output use std :: process :: Command ; fn main () { Command :: new ( \"codelab-message-pub\" ) . arg ( \"-c\" ) . arg ( \"hello_content\" ) . spawn () . expect ( \"command failed\" ); } rustc main.rs ./main Golang ¶ // https://golang.org/pkg/os/exec/ // https://tutorialedge.net/golang/executing-system-commands-with-golang/ package main import ( \"fmt\" \"os/exec\" \"runtime\" ) func execute () { out , err := exec . Command ( \"codelab-message-pub\" , \"-c\" , \"hello_content\" ). Output () if err != nil { fmt . Printf ( \"%s\" , err ) } fmt . Println ( \"Command Successfully Executed\" ) output := string ( out [:]) fmt . Println ( output ) } func main () { if runtime . GOOS == \"windows\" { fmt . Println ( \"Can't Execute this on a windows machine\" ) } else { execute () } } go run main.go swift ¶ //https://stackoverflow.com/questions/26971240/how-do-i-run-an-terminal-command-in-a-swift-script-e-g-xcodebuild import Foundation @ discardableResult func shell ( _ args : String ...) -> Int32 { let task = Process () task . launchPath = \"/usr/bin/env\" task . arguments = args task . launch () task . waitUntilExit () return task . terminationStatus } shell ( \"codelab-message-pub\" , \"-c\" , \"hello_content\" ) c ¶ #include <stdio.h> #include <stdlib.h> #include <string.h> int main () { char command [ 50 ]; strcpy ( command , \"codelab-message-pub -c hello_content\" ); system ( command ); return ( 0 ); } bash ¶ codelab-message-pub -c hello_content Racket ¶ ( system \"codelab-message-pub -c hello_content\" ) Scheme ¶ ( system \"codelab-message-pub -c hello_content\" ) Elisp(Emacs) ¶ ( shell-command \"codelab-message-pub -c hello_content\" ) Hy ¶ (import subprocess) (.call subprocess [\"codelab-message-pub\" \"-c\" \"hello_content\"]) SmallTalk(Pharo) ¶ command := OSProcess waitForCommand: 'codelab-message-pub -c hello_content' . command exitStatus . Haskell ¶ module Main where import System.Process main = callCommand \"codelab-message-pub -c hello_content\" MATLAB ¶ % https://www.mathworks.com/help/matlab/ref/system.html system ( \" codelab - message - pub - c hello_content \" ) Julia ¶ run ( `codelab-message-pub -c hello_content` ) Lua ¶ os.execute ( \"codelab-message-pub -c hello_content\" ) Perl ¶ system ( \"codelab-message-pub -c hello_content\" ) PHP ¶ <?php system ( \"codelab-message-pub -c hello_content\" ); ?> Dart ¶ import 'dart:io' ; main () { Process . run ( 'codelab-message-pub' , [ '-c' , 'hello_content' ]); } R ¶ system ( \"codelab-message-pub -c hello_content\" ) Ruby ¶ system ( \"codelab-message-pub -c hello_content\" ) Crystal ¶ system \"codelab-message-pub -c hello_content\" Python ¶ import subprocess subprocess . call ([ \"codelab-message-pub -c hello_content\" ], shell = True ) JavaScript(NodeJS) ¶ const { execSync } = require ( 'child_process' ); execSync ( 'codelab-message-pub -c hello_content' ); Prolog ¶ shell ( 'codelab-message-pub -c hello_content' ). Erlang ¶ !/ usr / bin / env escript main (_) -> output = os : cmd ( \"codelab-message-pub -c hello_content\" ), io : fwrite ( output ). Java ¶ Runtime r = Runtime . getRuntime (); Process p = r . exec ( \"codelab-message-pub -c hello_content\" ); p . waitFor (); Kotlin ¶ the same as Java Clojure ¶ ( use ' [ clojure.java.shell :only [ sh ]]) ( sh \"codelab-message-pub\" \"-c\" \"hello_content\" ) Scala ¶ import sys.process._ val cmd = \"codelab-message-pub -c hello_content\" val output = cmd .! // Captures the output Groovy ¶ \"codelab-message-pub -c hello_content\" . execute () Processing ¶ // https://forum.processing.org/two/discussion/24401/how-can-i-run-a-command-in-terminal-from-within-processing exec ( \"codelab-message-pub\" , \"-c\" , \"hello_content\" ); Fortran ¶ CALL execute_command_line ( 'codelab-message-pub -c hello_content' ) Ada ¶ -- https://www.pegasoft.ca/resources/boblap/13.html function system ( cmd : string ) returns integer ; pragma Import ( C , system ); Result := system ( \"codelab-message-pub -c hello_content\" & ASCII . NUL ); Brainfuck ¶ ref : https://kimiyuki.net/blog/2016/04/01/bash-on-brainfuck-on-anarchy-golf/ C# ¶ // https://docs.microsoft.com/en-us/dotnet/core/tutorials/using-with-xplat-cli // https://kimsereyblog.blogspot.com/2018/01/start-processes-from-c-in-dotnet-core.html // https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-run?tabs=netcore21#examples Pascal ¶ ref :https://wiki.freepascal.org/Executing_External_Programs Assembly ¶ ref: https://stackoverflow.com/questions/9342410/sys-execve-system-call-from-assembly SQL ¶ ref: https://stackoverflow.com/questions/43205594/running-system-command-with-argument-in-a-postgresql-function","text_tokens":[",","e","的","tabs","exit","g","为了","上","expect","典型","tutorials","help","require","address","事物","做","stdlib","struct","os","external","java","arguments","command","else","processing","scratch","can","为","9342410","contenst","how","因为","assembly","让","-","lua","invoke","在","package","failed","printf","stackoverflow","pub","stdio","ascii","postgresql","任何","integer","fortran","strcpy","forum","2","复杂","call","记得","发送","eim","char","工作","!","executed","erlang","26971240","<","思路","func","discardableresult","exitstatus","php","sql","env","深度","pkg","或者","module","terminal","构建","方法","swift","命令","04","延伸","信号","¶","optional","examples","ruby","a","rs","本质","2018","插件","matlab","golang","=","do","范例","running","new"," ","sys","launch","this","生成","到","if","nil","帮助","非常复杂","show","by","haskell","最新","shell","主流","其","部分","or","emacs","waitforcommand","int32","golf","returns","port","discussion","none","function","as","doc","kotlin","use","import","]","便是","ch01","设计","arg","t",".","where","and","+","机器","execute","usr","scheme","publisher","ca","操作系统","same","lang","i",")","content","successfully","waituntilexit","核心","结合","来","触角","racket","c","us","usage","execsync","案例","支持","runtime","43205594","}","capture","html","anarchy","foundation","cv","c#","netcore21","。","subscriber","questions","打开","programs","理想","execve","hello","用来","microsoft","确保","学到","message","那儿","以下","only","json","blogspot","tutorialedge","true","commands","比较","nul","client","）","{","io","程序","subprocess","cmd","args","方便","used","13","[","操作","docs","resources","kimiyuki","个","child","24401","21011330","中往","与","给出","everything","result","系统命令","pharo","r","消息","argument","选择","控制","便","(","using","go","可以","process","core","h","非主流","sh","概念","prolog","sdk","内部","com","测试","仅仅","machine","www","en","xxx","fwrite","banner",":","相机","https","协同工作","install","run","语言","token","之后","task","elisp","/","将","include","python","_","dart","from","从","中","rust","linux","id","?","2016","c++","强大","展示","能够","topic","集成","例子","极其","：","0","fn","bin","println","an","视觉","这样一来","hy","crystal","系统","line","main","upgrade","out","里","on","同工","clojure","val","smalltalk","in","%","node","dotnet","book","编程","能","xplat","windows","groovy","net","getruntime","01","name","nodejs","payload","launchpath","within","its","test","这样","terminationstatus","时","freepascal","安装","goos","const","with","你","escript","scala","pip","j","output","我们","就","org",">","（","1.6","完备","system","spawn","fmt","err","'","script","._","wiki","mathworks","rustc","codelab","unix","50","adapter","了","调用","cli","processes","signal","labstack","exec","\"","一来","s","非常","@","编程语言","协同程序","ip","xcodebuild","30","p","pegasoft","int","02","julia","world","std","perl","d","brainfuck","callcommand","n","...","tools","bash","let",";","，","set","#","osprocess","ada","`","waitfor","captures","协同","start","其他","pascal","string","写","空间","ref","加入","版本","魔杖","&","种","two","kimsereyblog","使用","pragma","javascript","它","仅","return","先","boblap","executing","the","是","blog","完","is"],"title":"与其他编程语言集成(system command)","title_tokens":["(","语言","编程语言","与","system","其他","集成"," ","command",")","编程"]},{"location":"dev_guide/system_command/#codelab-message-pub","text":"安装完 codelab_adapter_client 之后，将生成 codelab-message-pub 系统命令，它方便用来将 CodeLab Adapter 与其他编程语言做集成，我们展示了与 30+ 种编程语言结合的例子。 Unix/Linux 操作系统仅仅使用信号（signal）便能构建非常复杂的协同程序。Erlang 从 SmallTalk 那儿学到仅使用 message 来协同程序，message 是个极其强大的概念。 CodeLab Adapter 的核心设计思路是： Everything Is a Message （EIM），我们在最新的 codelab_adapter_client 版本中，为其加入系统命令，方便在其他语言构建的程序中往 CodeLab Adapter 发送消息，这样一来，你就可以使用任何编程语言为 Scratch 构建插件，或者为 CodeLab Adapter 构建插件。","text_tokens":["的","便","安装","可以","最新","你","其","我们","就","（","概念","做","设计","scratch","为","codelab","unix","仅仅","adapter","了","+","-","signal","在","一来","操作系统","非常","语言","编程语言","之后","协同程序","pub","30","核心","结合","/","任何","将","来","_","从","中","linux","复杂","发送","eim","强大","展示","erlang","集成","思路","例子","极其","。","：","，","或者","这样一来","用来","构建","学到","message","那儿","系统","命令","协同","信号","其他","client","a","）","加入","版本","程序","种","方便","操作","插件","使用","smalltalk"," ","它","个","仅","编程","能","中往","与","生成","everything","是","系统命令","消息","非常复杂","完","is","这样"],"title":"codelab-message-pub 系统命令","title_tokens":["message","-","codelab","系统命令","pub"," ","系统","命令"]},{"location":"dev_guide/system_command/#_1","text":"在 CodeLab 内部，我们的魔杖程序（使用魔杖控制空间里的事物）的机器视觉（CV）部分是使用 C++ 写的（因为深度相机的 C++ SDK 比较完备），为了让深度相机与 Scratch 协同工作， codelab-message-pub 便是理想的选择，它能够将消息的触角延伸到任何编程语言里。","text_tokens":["让","的","-","能够","里","在","程序","魔杖","为了","相机","控制","cv","协同工作","。","部分","同工","深度","我们","使用","，","视觉","理想","语言","（","编程语言","完备","pub"," ","事物","它","编程","message","sdk","任何","将","与","内部","触角","便是","是","scratch","到","协同","延伸","codelab","消息","比较","c++","写","机器","选择","因为","）","空间","工作"],"title":"典型使用案例：","title_tokens":["：","案例","使用","典型"]},{"location":"dev_guide/system_command/#codelab-message-pub_1","text":"","text_tokens":[],"title":"codelab-message-pub","title_tokens":["pub","message","-","codelab"]},{"location":"dev_guide/system_command/#_2","text":"pip install codelab_adapter_client --upgrade 确保 codelab_adapter_client >= 1.6.2","text_tokens":["pip",".","-","codelab","adapter",">","=","1.6","确保","2","_"," ","client","install","upgrade"],"title":"安装","title_tokens":["安装"]},{"location":"dev_guide/system_command/#_3","text":"> codelab-message-pub -h usage: codelab-message-pub [ -h ] [ -i CODELAB_ADAPTER_IP_ADDRESS ] [ -n NAME ] [ -p PUBLISHER_PORT ] [ -s SUBSCRIBER_PORT ] [ -t TOPIC ] [ -d NODE_ID ] [ -c CONTENT ] [ -j JSON_MESSAGE ] optional arguments: -h, --help show this help message and exit -i CODELAB_ADAPTER_IP_ADDRESS None or IP address used by CodeLab Adapter -n NAME Set name in banner -p PUBLISHER_PORT Publisher IP port -s SUBSCRIBER_PORT Subscriber IP port -t TOPIC message topic -d NODE_ID node id -c CONTENT payload [ 'content' ] -j JSON_MESSAGE json message ( with topic and payload )","text_tokens":[",","-","(","banner",":","exit","publisher","topic","with","subscriber","h","s","used","[","j","or",">","set","node","help","in","ip","pub"," ","address","port","i","p","content","none","'",")","message","_","arguments","this","]","c","json","t","usage","codelab","d","and","adapter","name","id","optional","n","payload","show","by"],"title":"使用帮助","title_tokens":["帮助","使用"]},{"location":"dev_guide/system_command/#_4","text":"> codelab-message-pub -t hello_topic > codelab-message-pub -c hello_content > codelab-message-pub -j '{\"payload\":{\"content\":\"test contenst\", \"token\":\"xxx\"}}' 使用 codelab-message-pub 时记得先打开 CodeLab Adapter。","text_tokens":[",","xxx","-","}","时",":","topic","\"","test","。","打开","j","使用",">","token","hello","pub"," ","'","content","先","message","_","c","t","codelab","contenst","adapter","payload","记得","{"],"title":"使用方法","title_tokens":["方法","使用"]},{"location":"dev_guide/system_command/#_5","text":"以下是我们给出的主流/非主流编程语言与 codelab-message-pub 集成的范例，本质上是系统调用。 部分编程语言使用 labstack 测试。","text_tokens":["的","-","labstack","上","集成","主流","。","部分","非主流","我们","使用","，","语言","编程语言","范例","pub"," ","编程","message","/","与","以下","系统","给出","是","测试","codelab","调用","本质"],"title":"支持语言","title_tokens":["语言","支持"]},{"location":"dev_guide/system_command/#c","text":"#include <stdio.h> #include <stdlib.h> int main () { system ( \"codelab-message-pub -c hello_content\" ); }","text_tokens":["-","(","}","<","\"","h",";",">","system","hello","#","pub"," ","stdio",")","stdlib","content","int","message","include","_","c",".","codelab","main","{"],"title":"C++","title_tokens":["c++"]},{"location":"dev_guide/system_command/#rust","text":"// https://doc.rust-lang.org/book/ch01-02-hello-world.html // https://doc.rust-lang.org/std/process/struct.Command.html // https://stackoverflow.com/questions/21011330/how-do-i-invoke-a-system-command-in-rust-and-capture-its-output use std :: process :: Command ; fn main () { Command :: new ( \"codelab-message-pub\" ) . arg ( \"-c\" ) . arg ( \"hello_content\" ) . spawn () . expect ( \"command failed\" ); } rustc main.rs ./main","text_tokens":["{","-","capture","invoke","(","process","html",":","}","https","expect","\"","questions","fn",";","output","failed","org","stackoverflow","do","in","system","spawn","hello","new","lang"," ","pub","book","i",")","struct","content","02","message","doc","/","world","21011330","use","com","_","std","command","c","ch01","arg","rustc",".","codelab","rust","and","how","main","a","rs","its"],"title":"Rust","title_tokens":["rust"]},{"location":"dev_guide/system_command/#golang","text":"// https://golang.org/pkg/os/exec/ // https://tutorialedge.net/golang/executing-system-commands-with-golang/ package main import ( \"fmt\" \"os/exec\" \"runtime\" ) func execute () { out , err := exec . Command ( \"codelab-message-pub\" , \"-c\" , \"hello_content\" ). Output () if err != nil { fmt . Printf ( \"%s\" , err ) } fmt . Println ( \"Command Successfully Executed\" ) output := string ( out [:]) fmt . Println ( output ) } func main () { if runtime . GOOS == \"windows\" { fmt . Println ( \"Can't Execute this on a windows machine\" ) } else { execute () } } go run main.go","text_tokens":[",","!","executed","-","(","}","go",":","goos","on","with","exec","https","out","\"","package","func","s","run","[","pkg","output","println","printf","org","golang","=","%","system","hello","pub"," ","fmt","err",")","content","successfully","'","message","/","windows","os","_","import","executing","command","]","this","c","else","net","can","if",".","t","nil","tutorialedge","codelab","commands","main","string","machine","execute","a","{","runtime"],"title":"Golang","title_tokens":["golang"]},{"location":"dev_guide/system_command/#swift","text":"//https://stackoverflow.com/questions/26971240/how-do-i-run-an-terminal-command-in-a-swift-script-e-g-xcodebuild import Foundation @ discardableResult func shell ( _ args : String ...) -> Int32 { let task = Process () task . launchPath = \"/usr/bin/env\" task . arguments = args task . launch () task . waitUntilExit () return task . terminationStatus } shell ( \"codelab-message-pub\" , \"-c\" , \"hello_content\" )","text_tokens":[",","e","terminationstatus","-","(","usr","}","process",":","26971240","g","foundation","shell","https","args","let","func","discardableresult","questions","\"","run","bin","env","an","@","int32","stackoverflow","do","in",">","terminal","task","=","xcodebuild","hello","pub"," ","i",")","content","return","waituntilexit","swift","script","launch","message","/","com","_","import","command","arguments","c",".","codelab","how","...","string","launchpath","a","{"],"title":"swift","title_tokens":["swift"]},{"location":"dev_guide/system_command/#c_1","text":"#include <stdio.h> #include <stdlib.h> #include <string.h> int main () { char command [ 50 ]; strcpy ( command , \"codelab-message-pub -c hello_content\" ); system ( command ); return ( 0 ); }","text_tokens":[",","-","(","}","<","\"","h","0","[",";",">","system","hello","#","pub"," ","stdio",")","stdlib","content","int","return","message","include","_","command","]","strcpy","c",".","codelab","50","string","main","char","{"],"title":"c","title_tokens":["c"]},{"location":"dev_guide/system_command/#bash","text":"codelab-message-pub -c hello_content","text_tokens":["message","-","codelab","hello","_","pub"," ","c","content"],"title":"bash","title_tokens":["bash"]},{"location":"dev_guide/system_command/#racket","text":"( system \"codelab-message-pub -c hello_content\" )","text_tokens":["message","-","codelab","(","c","system","hello","_","pub"," ","\"",")","content"],"title":"Racket","title_tokens":["racket"]},{"location":"dev_guide/system_command/#scheme","text":"( system \"codelab-message-pub -c hello_content\" )","text_tokens":["message","-","codelab","(","c","system","hello","_","pub"," ","\"",")","content"],"title":"Scheme","title_tokens":["scheme"]},{"location":"dev_guide/system_command/#elispemacs","text":"( shell-command \"codelab-message-pub -c hello_content\" )","text_tokens":["message","-","codelab","(","c","hello","shell","_","pub","command"," ","\"",")","content"],"title":"Elisp(Emacs)","title_tokens":[")","emacs","elisp","("]},{"location":"dev_guide/system_command/#hy","text":"(import subprocess) (.call subprocess [\"codelab-message-pub\" \"-c\" \"hello_content\"])","text_tokens":["[",".","message","-","codelab","(","c","hello","call","_","import","subprocess"," ","pub","]","\"",")","content"],"title":"Hy","title_tokens":["hy"]},{"location":"dev_guide/system_command/#smalltalkpharo","text":"command := OSProcess waitForCommand: 'codelab-message-pub -c hello_content' . command exitStatus .","text_tokens":[".","message","waitforcommand","codelab","-","=",":","hello","_","pub","command"," ","c","exitstatus","osprocess","'","content"],"title":"SmallTalk(Pharo)","title_tokens":[")","pharo","(","smalltalk"]},{"location":"dev_guide/system_command/#haskell","text":"module Main where import System.Process main = callCommand \"codelab-message-pub -c hello_content\"","text_tokens":["-","process","\"","module","=","system","hello","pub"," ","content","message","_","import","c",".","where","codelab","callcommand","main"],"title":"Haskell","title_tokens":["haskell"]},{"location":"dev_guide/system_command/#matlab","text":"% https://www.mathworks.com/help/matlab/ref/system.html system ( \" codelab - message - pub - c hello_content \" )","text_tokens":["-","(","html",":","https","\"","matlab","%","help","system","hello","pub"," ",")","content","message","/","com","mathworks","_","c",".","codelab","www","ref"],"title":"MATLAB","title_tokens":["matlab"]},{"location":"dev_guide/system_command/#julia","text":"run ( `codelab-message-pub -c hello_content` )","text_tokens":["message","-","codelab","(","hello","_","pub"," ","`","c",")","content","run"],"title":"Julia","title_tokens":["julia"]},{"location":"dev_guide/system_command/#lua","text":"os.execute ( \"codelab-message-pub -c hello_content\" )","text_tokens":[".","message","-","codelab","(","\"","c","os","hello","_","pub"," ","execute",")","content"],"title":"Lua","title_tokens":["lua"]},{"location":"dev_guide/system_command/#perl","text":"system ( \"codelab-message-pub -c hello_content\" )","text_tokens":["message","-","codelab","(","c","system","hello","_","pub"," ","\"",")","content"],"title":"Perl","title_tokens":["perl"]},{"location":"dev_guide/system_command/#php","text":"<?php system ( \"codelab-message-pub -c hello_content\" ); ?>","text_tokens":[";","message","-","codelab","(",">","c","system","?","<","hello","_","pub"," ","\"","php",")","content"],"title":"PHP","title_tokens":["php"]},{"location":"dev_guide/system_command/#dart","text":"import 'dart:io' ; main () { Process . run ( 'codelab-message-pub' , [ '-c' , 'hello_content' ]); }","text_tokens":[",","io","-","(","}","process",":","run","[",";","hello","pub"," ","'",")","content","message","dart","import","_","]","c",".","codelab","main","{"],"title":"Dart","title_tokens":["dart"]},{"location":"dev_guide/system_command/#r","text":"system ( \"codelab-message-pub -c hello_content\" )","text_tokens":["message","-","codelab","(","c","system","hello","_","pub"," ","\"",")","content"],"title":"R","title_tokens":["r"]},{"location":"dev_guide/system_command/#ruby","text":"system ( \"codelab-message-pub -c hello_content\" )","text_tokens":["message","-","codelab","(","c","system","hello","_","pub"," ","\"",")","content"],"title":"Ruby","title_tokens":["ruby"]},{"location":"dev_guide/system_command/#crystal","text":"system \"codelab-message-pub -c hello_content\"","text_tokens":["message","-","codelab","c","system","hello","_","pub"," ","\"","content"],"title":"Crystal","title_tokens":["crystal"]},{"location":"dev_guide/system_command/#python","text":"import subprocess subprocess . call ([ \"codelab-message-pub -c hello_content\" ], shell = True )","text_tokens":[",","-","(","shell","subprocess","\"","[","=","hello","pub"," ",")","content","message","_","import","]","c",".","codelab","true","call"],"title":"Python","title_tokens":["python"]},{"location":"dev_guide/system_command/#javascriptnodejs","text":"const { execSync } = require ( 'child_process' ); execSync ( 'codelab-message-pub -c hello_content' );","text_tokens":["-","}","(","process","const",";","=","require","hello","pub"," ","'",")","content","child","message","_","c","codelab","execsync","{"],"title":"JavaScript(NodeJS)","title_tokens":[")","nodejs","javascript","("]},{"location":"dev_guide/system_command/#prolog","text":"shell ( 'codelab-message-pub -c hello_content' ).","text_tokens":[".","message","-","codelab","(","hello","shell","_","pub"," ","c","'","content",")"],"title":"Prolog","title_tokens":["prolog"]},{"location":"dev_guide/system_command/#erlang","text":"!/ usr / bin / env escript main (_) -> output = os : cmd ( \"codelab-message-pub -c hello_content\" ), io : fwrite ( output ).","text_tokens":[",","!","io","-","fwrite","usr","(",":","cmd","\"","escript","bin","env","output",">","=","hello","pub"," ",")","content","message","/","os","_","c",".","codelab","main"],"title":"Erlang","title_tokens":["erlang"]},{"location":"dev_guide/system_command/#java","text":"Runtime r = Runtime . getRuntime (); Process p = r . exec ( \"codelab-message-pub -c hello_content\" ); p . waitFor ();","text_tokens":["-","(","process","exec","\"",";","=","hello","pub"," ","p",")","content","message","_","c","waitfor","getruntime",".","codelab","r","runtime"],"title":"Java","title_tokens":["java"]},{"location":"dev_guide/system_command/#kotlin","text":"the same as Java","text_tokens":["as","same","java","the"," "],"title":"Kotlin","title_tokens":["kotlin"]},{"location":"dev_guide/system_command/#clojure","text":"( use ' [ clojure.java.shell :only [ sh ]]) ( sh \"codelab-message-pub\" \"-c\" \"hello_content\" )","text_tokens":["-","(",":","shell","\"","clojure","sh","[","hello","pub"," ","'",")","content","message","use","_","java","]","only","c",".","codelab"],"title":"Clojure","title_tokens":["clojure"]},{"location":"dev_guide/system_command/#scala","text":"import sys.process._ val cmd = \"codelab-message-pub -c hello_content\" val output = cmd .! // Captures the output","text_tokens":["!","-","process","cmd","\"","output","val","=","hello","pub"," ","sys","content","._","message","/","_","import","the","c","captures",".","codelab"],"title":"Scala","title_tokens":["scala"]},{"location":"dev_guide/system_command/#groovy","text":"\"codelab-message-pub -c hello_content\" . execute ()","text_tokens":[".","message","-","codelab","(","execute","c","hello","_","pub"," ","\"",")","content"],"title":"Groovy","title_tokens":["groovy"]},{"location":"dev_guide/system_command/#processing","text":"// https://forum.processing.org/two/discussion/24401/how-can-i-run-a-command-in-terminal-from-within-processing exec ( \"codelab-message-pub\" , \"-c\" , \"hello_content\" );","text_tokens":[",","-","(",":","exec","https","\"","run","two",";","org","in","terminal","hello","pub"," ","discussion","i",")","content","24401","message","/","from","_","command","c","processing","forum","can",".","codelab","how","a","within"],"title":"Processing","title_tokens":["processing"]},{"location":"dev_guide/system_command/#fortran","text":"CALL execute_command_line ( 'codelab-message-pub -c hello_content' )","text_tokens":["message","-","codelab","line","(","c","hello","call","_","pub","command"," ","execute","'","content",")"],"title":"Fortran","title_tokens":["fortran"]},{"location":"dev_guide/system_command/#ada","text":"-- https://www.pegasoft.ca/resources/boblap/13.html function system ( cmd : string ) returns integer ; pragma Import ( C , system ); Result := system ( \"codelab-message-pub -c hello_content\" & ASCII . NUL );","text_tokens":[",","-","(","html",":","&","https","cmd","\"","13","ca",";","pragma","=","system","hello","returns","pub"," ","resources",")","content","pegasoft","function","message","boblap","ascii","/","integer","_","import","c",".","result","codelab","string","www","nul"],"title":"Ada","title_tokens":["ada"]},{"location":"dev_guide/system_command/#brainfuck","text":"ref : https://kimiyuki.net/blog/2016/04/01/bash-on-brainfuck-on-anarchy-golf/","text_tokens":[".","-","/","blog","01",":","on","brainfuck","2016","anarchy","golf","https"," ","kimiyuki","bash","net","04","ref"],"title":"Brainfuck","title_tokens":["brainfuck"]},{"location":"dev_guide/system_command/#c_2","text":"// https://docs.microsoft.com/en-us/dotnet/core/tutorials/using-with-xplat-cli // https://kimsereyblog.blogspot.com/2018/01/start-processes-from-c-in-dotnet-core.html // https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-run?tabs=netcore21#examples","text_tokens":["processes","-","using","tabs","html",":","with","https","core","netcore21","2018","run","kimsereyblog","in","docs","tutorials","=","#"," ","microsoft","dotnet","xplat","/","com","from","c","blogspot","us",".","01","cli","start","?","tools","examples","en"],"title":"C#","title_tokens":["c#"]},{"location":"dev_guide/system_command/#pascal","text":"ref :https://wiki.freepascal.org/Executing_External_Programs","text_tokens":[".","programs","/","wiki","freepascal","org",":","external","_","https"," ","executing","ref"],"title":"Pascal","title_tokens":["pascal"]},{"location":"dev_guide/system_command/#assembly","text":"ref: https://stackoverflow.com/questions/9342410/sys-execve-system-call-from-assembly","text_tokens":["assembly",".","-","9342410","/","execve","stackoverflow",":","system","com","call","from","https"," ","sys","questions","ref"],"title":"Assembly","title_tokens":["assembly"]},{"location":"dev_guide/system_command/#sql","text":"ref: https://stackoverflow.com/questions/43205594/running-system-command-with-argument-in-a-postgresql-function","text_tokens":["43205594","-",":","with","https","questions","stackoverflow","running","in","system"," ","function","postgresql","/","com","command",".","argument","a","ref"],"title":"SQL","title_tokens":["sql"]},{"location":"dev_guide/定制与分发/","text":"定制与分发 ¶ v3.7.2 版本之后，引入了一个钩子(hook): Adapter 在启动时，将加载 app_settings.py 文件。 app_settings.py 可以是任意 Python 脚本！ 文件位置 ¶ app_settings.py 的位置在不同系统下位置不同。 Windows ¶ 在 Windows 系统下，位于 src 目录下 MacOS ¶ 在 MacOS 系统下，位于 CodeLab-Adapter.app/Contents/Resources/ 典型应用场景 ¶ 初始化配置信息 ¶ app_settings.py 优先级高于 user_settings.py , 兼容user_settings.py的所有配置参数。 所以你可以使用该钩子配置 Adapter 的行为（诸如开启局域网访问权限，将其作为局域网消息中心） 重新分发 Adapter ¶ 近期我们发布了 Adapter 完整版, 将 Adapter Node 的环境(嵌入了 Python 解释器和依赖包)打包分发，用户不需要在本地安装 Python，即可运行 Adapter Node。 这项工作的最初动机是简化 DynamicTable 的使用，由于 DynamicTable 希望进入家庭，开箱可用是设计目标之一。所以我们选择将 环境和 Adapter 整体分发。 目前 Python 社区打包分发的机制五花八门，我几乎试遍了所有的机制。目前最喜欢的技巧是在 hack CMU 的 Calypso 软件时学来的:，它的内部 Python 环境十分复杂，但却做到了开箱可用。 这项工作的一个产物是，开发者可以将 Adapter 的自定义插件，连同整个环境一起分发！ Jypyterlab 、 OpenCV 、Tensorflow、 Numpy 等等这些复杂依赖，都能做到开箱可用。 你无需支出什么工作，便可把定制后的整个开发/教学 Python 环境分发给用户。 以上这些都基于 app_settings.py 钩子！ 生命周期 ¶ 利用这个钩子，也可以改变 Adapter 的运行生命周期，如果你愿意基于 Adapter 构建可扩展的 Python/Scratch 环境，将变得极其简易。 我看到目前 STEAM/编程教育许多团队在环境打包上，投入了很多人力，但灵活性做的很差。 将其视为 hack 机制, WTFPL Adapter 主页 ¶ 如果你想修改软件启动时打开的页面，只需要修改 WEB_UI_ENDPOINT 即可，诸如: WEB_UI_ENDPOINT = \"https://www.codelab.club/\" , 每次打开软件都将自动打开CodeLab主页 白名单(允许无 token 使用) ¶ 在 用户配置文件 或者app_settings.py修改 USER_WHITELIST_HOSTNAME 即可。 形如 USER_WHITELIST_HOSTNAME = [ \"codelab.club\" ]","text_tokens":[",","的","jypyterlab","便","(","时","用户","可以","一个","应用","所以","解释","安装","hook","目标","你","之一","教学","行为","看到","上","典型","分发","其","家庭","开发","calypso","我","如果","我们","利用","近期","软件","自定义","（","最","嵌入","club","做","八门","完整版","周期","投入","一起","settings","社区","名单","内部","endpoint","什么","]","设计","这些","后","需要","scratch",".","启动","兼容","codelab","作为","了","adapter","活性","生命","www","所有","下","自动","人力","numpy","即可","-","本地","时学来","以上","py","基于",":","在","机制","五花八门","发给","整版","局域","https","\"","优先","高于","连同","整体","ui","差","优先级","token","之后","释器","分","扩展","视为","文件","诸如","改变","灵活性","任意","和",")","/","自定","将","最初","python","目录","_","产物","想","局域网","hack","形","灵活","十分","、","配置","整个","2","配置文件","复杂","只","wtfpl","钩子","场景","几乎","许多","工作","简化","如","dynamictable","依赖","白名单","动机","等等","极其","。","很多","教育","hostname","初始化","steam","打开","也","，","opencv","主页","页面","web","或者","希望","可用","定制","不同","技巧","构建","引入","脚本","包","可","位置","这项","定义","加载","支出","初始","运行","进入","！","系统","把","该","学来","权限","很","允许","变得","¶","访问","解释器","参数","打包","）","版本","开发者","愿意","tensorflow","信息","无","开箱","位于","[","喜欢","插件","使用","却","contents","=","node","无需"," ","resources","由于","src","它","但","编程","能","试遍","每次","whitelist","windows","与","做到","这个","中心","cmu","都","完整","不","修改","十分复杂","user","是","环境","团队","app","开启","生命周期","消息","v3.7","重新","五花","选择","目前","macos","简易","发布"],"title":"定制与分发","title_tokens":["分发","定制","与"]},{"location":"dev_guide/定制与分发/#_1","text":"v3.7.2 版本之后，引入了一个钩子(hook): Adapter 在启动时，将加载 app_settings.py 文件。 app_settings.py 可以是任意 Python 脚本！","text_tokens":["版本","(","时","py","一个",":","在","可以","hook","。","，","之后"," ","文件","引入","任意",")","脚本","settings","加载","将","python","_","！","是","app",".","启动","了","adapter","2","v3.7","钩子"],"title":"定制与分发","title_tokens":["分发","定制","与"]},{"location":"dev_guide/定制与分发/#_2","text":"app_settings.py 的位置在不同系统下位置不同。","text_tokens":["app",".","位置","settings","的","py","在","_"," ","不同","系统","下","。"],"title":"文件位置","title_tokens":["位置","文件"]},{"location":"dev_guide/定制与分发/#windows","text":"在 Windows 系统下，位于 src 目录下","text_tokens":["，","windows","在","目录"," ","系统","下","src","位于"],"title":"Windows","title_tokens":["windows"]},{"location":"dev_guide/定制与分发/#macos","text":"在 MacOS 系统下，位于 CodeLab-Adapter.app/Contents/Resources/","text_tokens":["app",".","-","codelab","，","/","adapter","contents","在"," ","系统","下","resources","macos","位于"],"title":"MacOS","title_tokens":["macos"]},{"location":"dev_guide/定制与分发/#_3","text":"","text_tokens":[],"title":"典型应用场景","title_tokens":["应用","场景","典型"]},{"location":"dev_guide/定制与分发/#_4","text":"app_settings.py 优先级高于 user_settings.py , 兼容user_settings.py的所有配置参数。 所以你可以使用该钩子配置 Adapter 的行为（诸如开启局域网访问权限，将其作为局域网消息中心）","text_tokens":[",","的","py","可以","所以","你","局域","行为","。","高于","优先","其","使用","优先级","，","（"," ","诸如","settings","将","_","中心","该","user","局域网","app",".","权限","兼容","开启","配置","adapter","访问","作为","消息","参数","钩子","所有","）"],"title":"初始化配置信息","title_tokens":["配置","初始","信息","初始化"]},{"location":"dev_guide/定制与分发/#adapter","text":"近期我们发布了 Adapter 完整版, 将 Adapter Node 的环境(嵌入了 Python 解释器和依赖包)打包分发，用户不需要在本地安装 Python，即可运行 Adapter Node。 这项工作的最初动机是简化 DynamicTable 的使用，由于 DynamicTable 希望进入家庭，开箱可用是设计目标之一。所以我们选择将 环境和 Adapter 整体分发。 目前 Python 社区打包分发的机制五花八门，我几乎试遍了所有的机制。目前最喜欢的技巧是在 hack CMU 的 Calypso 软件时学来的:，它的内部 Python 环境十分复杂，但却做到了开箱可用。 这项工作的一个产物是，开发者可以将 Adapter 的自定义插件，连同整个环境一起分发！ Jypyterlab 、 OpenCV 、Tensorflow、 Numpy 等等这些复杂依赖，都能做到开箱可用。 你无需支出什么工作，便可把定制后的整个开发/教学 Python 环境分发给用户。 以上这些都基于 app_settings.py 钩子！","text_tokens":[",","的","jypyterlab","便","(","用户","安装","之一","所以","解释","一个","目标","可以","教学","你","开发","分发","家庭","calypso","我","我们","近期","软件","自定义","最","嵌入","八门","完整版","一起","settings","社区","内部","什么","设计","这些","后","需要",".","了","adapter","所有","numpy","即可","时学来","本地","以上","基于","py",":","在","机制","五花八门","发给","整版","连同","整体","分","释器","和",")","/","自定","将","最初","python","_","产物","hack","十分","、","整个","复杂","钩子","几乎","工作","简化","dynamictable","依赖","动机","等等","。","，","opencv","希望","可用","定制","技巧","包","可","这项","定义","支出","运行","进入","！","把","学来","解释器","打包","开发者","tensorflow","开箱","喜欢","插件","使用","却","node","无需"," ","由于","它","但","能","试遍","做到","cmu","都","完整","不","十分复杂","是","环境","app","五花","选择","目前","发布"],"title":"重新分发 Adapter","title_tokens":["分发","adapter"," ","重新"]},{"location":"dev_guide/定制与分发/#_5","text":"利用这个钩子，也可以改变 Adapter 的运行生命周期，如果你愿意基于 Adapter 构建可扩展的 Python/Scratch 环境，将变得极其简易。 我看到目前 STEAM/编程教育许多团队在环境打包上，投入了很多人力，但灵活性做的很差。 将其视为 hack 机制, WTFPL","text_tokens":[",","的","扩展","基于","可以","愿意","在","机制","看到","上","你","极其","。","其","很多","教育","如果","我","steam","也","利用","许多","，","差","视为"," ","做","改变","构建","灵活性","周期","投入","可","编程","但","/","将","运行","这个","python","hack","scratch","环境","团队","灵活","很","生命周期","adapter","变得","了","活性","生命","钩子","打包","目前","wtfpl","人力","简易"],"title":"生命周期","title_tokens":["生命周期","周期","生命"]},{"location":"dev_guide/定制与分发/#adapter_1","text":"如果你想修改软件启动时打开的页面，只需要修改 WEB_UI_ENDPOINT 即可，诸如: WEB_UI_ENDPOINT = \"https://www.codelab.club/\" , 每次打开软件都将自动打开CodeLab主页","text_tokens":["即可",",","的","时",":","你","https","\"","打开","如果","ui","软件","页面","，","web","=","主页","club"," ","诸如","每次","/","将","endpoint","_","都","修改","想","需要",".","启动","codelab","只","www","自动"],"title":"Adapter 主页","title_tokens":["adapter"," ","主页"]},{"location":"dev_guide/定制与分发/#token","text":"在 用户配置文件 或者app_settings.py修改 USER_WHITELIST_HOSTNAME 即可。 形如 USER_WHITELIST_HOSTNAME = [ \"codelab.club\" ]","text_tokens":["即可","用户","py","在","\"","。","hostname","[","或者","=","club"," ","文件","settings","whitelist","_","]","修改","形","user","app",".","codelab","配置","配置文件","如"],"title":"白名单(允许无 token 使用)","title_tokens":["允许","(","使用","名单","token","白名单"," ","无",")"]},{"location":"dev_guide/接入第三方平台/","text":"开放连接 ¶ CodeLab Adapter v3 允许 codelab.club 的合作方将 CodeLab Adapter v3 接入到自己的平台。从而让平台获得与开源硬件/AI/IoT 交互的能力，同时他们也可以将 CodeLab Adapter 用作真实的 Python 解释器（与本地文件系统/网络交互）。 我们将在这篇文章中展示如何将 CodeLab Adapter 接入到任何 Scratch 3.0 平台中。事实上，你可以将它接入任何 web 平台中（blockly/brython/electron……）。 本文中，我们给出了 CodeLab Adapter EIM 插件的源码 以及 scratch3-adapter extension_eim 的源码 。 教程 ¶ 我们假设你已经读了 创建你的第一个 Scratch 3.0 Extension ，如果没有，阅读完再回来。最好跟着文章操作一遍。 在 Scratch 3.0 中创建 EIM Extension ¶ Scratch 3.0 插件源码 ¶ 在 scratch-vm/src/extensions 目录创建 scratch3_eim/index.js Scratch 3.0 EIM 插件的源码我们已经放到 GitHub 上了： scratch3_eim ，源码本身不做过多解释，对照着它的功能，很容易搞懂。 值得注意的是， scratch3_eim 依赖于 socket.io-client ，你需要在 scratch-vm 中先安装依赖： socket.io-client Scratch 3.0 与 CodeLab Adapter 建立连接，最关键的部分是： this . socket = io ( `// ${ adapterHost } :12358` + \"/test\" , { transports : [ \"websocket\" ] }); 从架构图中，你可以更好地理解它们的交互： 从架构途图中也可以看出， CodeLab Adapter 支持任何平台。Scratch3 .0 只是它的一个 client，并没有特殊性，你可以在 blockly app 或者任何其他什么地方接入 CodeLab Adapter 。 CodeLab Adapter extension_eim 源码 ¶ CodeLab Adapter extension_eim 的源码，我们也已经更新到 GitHub 上： extension_eim.py 此外 extension_eim_monitor.py extension_eim_trigger.py 也是可以配合 Scratch 3.0 EIM 插件使用的。 开发者优先 ¶ 目前我们允许开发者在本地（ 127.0.0.1 ）将 CodeLab Adapter 接入到任何平台中。 需要注意的是，你需要将网站运行为 https（ webpack-dev-server --https ）来与 CodeLab Adapter 通信。 参考 ¶ 创建你的第一个 Scratch 3.0 Extension CodeLab Adapter 可以支持其他平台吗？","text_tokens":[",","的","(","可以","一个","安装","解释","吗","上","socket","你","vm","开发","部分","如果","从而","我们","（","中先","地","club","用作","最","做","trigger","篇文章","事实","特殊性","websocket","功能","什么","]","平台","scratch","需要","js","他们","通信",".","为","codelab","关键","只是","adapter","了","adapterhost","网站","+","本身","接入","值得","已经","让","-","本地","py",":","在","ai","跟着","事实上","index","https","没有","开放","\"","优先","硬件","extension","释器","…","参考","第一","文件","0.1","真实",")","更新","地方","合作","网络","/","任何","回来","将","自己","注意","赖于","python","目录","_","更好","此外","获得","来","中","从","dev","构图","server","支持","eim","合作方","建立","假设","展示","架构","}","它们","并","依赖","electron","如何","着","。","：","0",";","也","，","或者","web","v3","文章","scratch3","读","阅读","连接","一遍","第一个","extensions","教程","iot","开源","blockly","本文","放到","对照","这","途图","多","运行","？","`","特殊","系统","搞懂","monitor","github","允许","很","webpack","¶","以及","值得注意","解释器","其他","交互","127.0","client","）","{","io","开发者","配合","[","操作","插件","理解","使用","12358","=","$","transports"," ","看出","它","src","与","this","不","给出","到","源码","是","完再","架构图","app","brython","最好","过","依赖于","文件系统","3.0","能力","同时","目前","test","容易","创建"],"title":"接入第三方平台","title_tokens":["三方","第三","接入","平台","第三方"]},{"location":"dev_guide/接入第三方平台/#_1","text":"CodeLab Adapter v3 允许 codelab.club 的合作方将 CodeLab Adapter v3 接入到自己的平台。从而让平台获得与开源硬件/AI/IoT 交互的能力，同时他们也可以将 CodeLab Adapter 用作真实的 Python 解释器（与本地文件系统/网络交互）。 我们将在这篇文章中展示如何将 CodeLab Adapter 接入到任何 Scratch 3.0 平台中。事实上，你可以将它接入任何 web 平台中（blockly/brython/electron……）。 本文中，我们给出了 CodeLab Adapter EIM 插件的源码 以及 scratch3-adapter extension_eim 的源码 。","text_tokens":["让","展示","的","-","本地","可以","解释","在","ai","electron","如何","事实上","你","。","extension","从而","也","我们","，","插件","硬件","（","v3","释器","文章","web","…","scratch3","club"," ","用作","文件","真实","它","篇文章","事实","合作","）","网络","/","开源","iot","将","自己","与","这","python","任何","blockly","本文","_","获得","中","系统","给出","到","平台","scratch","源码","他们","允许",".","codelab","brython","adapter","了","以及","解释器","交互","文件系统","3.0","能力","同时","eim","接入","合作方"],"title":"开放连接","title_tokens":["开放","连接"]},{"location":"dev_guide/接入第三方平台/#_2","text":"我们假设你已经读了 创建你的第一个 Scratch 3.0 Extension ，如果没有，阅读完再回来。最好跟着文章操作一遍。","text_tokens":["假设","的","一个","跟着","你","没有","。","如果","操作","我们","，","extension","文章","已经","读","第一"," ","阅读","一遍","第一个","回来","scratch","完再","最好","了","3.0","创建"],"title":"教程","title_tokens":["教程"]},{"location":"dev_guide/接入第三方平台/#scratch-30-eim-extension","text":"","text_tokens":[],"title":"在 Scratch 3.0 中创建 EIM Extension","title_tokens":["extension","在","3.0"," ","中","eim","scratch","创建"]},{"location":"dev_guide/接入第三方平台/#scratch-30","text":"在 scratch-vm/src/extensions 目录创建 scratch3_eim/index.js Scratch 3.0 EIM 插件的源码我们已经放到 GitHub 上了： scratch3_eim ，源码本身不做过多解释，对照着它的功能，很容易搞懂。 值得注意的是， scratch3_eim 依赖于 socket.io-client ，你需要在 scratch-vm 中先安装依赖： socket.io-client Scratch 3.0 与 CodeLab Adapter 建立连接，最关键的部分是： this . socket = io ( `// ${ adapterHost } :12358` + \"/test\" , { transports : [ \"websocket\" ] }); 从架构图中，你可以更好地理解它们的交互： 从架构途图中也可以看出， CodeLab Adapter 支持任何平台。Scratch3 .0 只是它的一个 client，并没有特殊性，你可以在 blockly app 或者任何其他什么地方接入 CodeLab Adapter 。","text_tokens":[",","的","(","安装","可以","一个","解释","上","socket","你","vm","部分","我们","中先","地","最","做","特殊性","websocket","功能","什么","]","平台","scratch","需要","js",".","codelab","关键","只是","了","adapter","adapterhost","+","本身","接入","值得","已经","-",":","在","index","\"","没有",")","地方","/","赖于","更好","任何","注意","目录","_","从","中","构图","支持","eim","建立","架构","}","它们","并","依赖","着","。","：","0",";","也","，","或者","scratch3","连接","extensions","对照","blockly","放到","途图","多","`","特殊","搞懂","github","很","值得注意","其他","交互","client","{","io","[","插件","理解","12358","=","$","transports"," ","看出","src","它","与","this","不","源码","是","app","架构图","过","依赖于","3.0","test","容易","创建"],"title":"Scratch 3.0 插件源码","title_tokens":["插件","3.0"," ","源码","scratch"]},{"location":"dev_guide/接入第三方平台/#codelab-adapter-extension_eim","text":"CodeLab Adapter extension_eim 的源码，我们也已经更新到 GitHub 上： extension_eim.py 此外 extension_eim_monitor.py extension_eim_trigger.py 也是可以配合 Scratch 3.0 EIM 插件使用的。","text_tokens":["的","配合","py","可以","上","。","：","我们","也","插件","，","使用","extension"," ","trigger","更新","此外","_","到","源码","是","monitor","scratch","github",".","codelab","adapter","3.0","eim","已经"],"title":"CodeLab Adapter extension_eim 源码","title_tokens":["codelab","adapter","extension","_"," ","eim","源码"]},{"location":"dev_guide/接入第三方平台/#_3","text":"目前我们允许开发者在本地（ 127.0.0.1 ）将 CodeLab Adapter 接入到任何平台中。 需要注意的是，你需要将网站运行为 https（ webpack-dev-server --https ）来与 CodeLab Adapter 通信。","text_tokens":["的","-","开发者","本地","在","你","https","开发","。","我们","，","（"," ","0.1","任何","将","注意","来","与","运行","中","dev","到","平台","需要","是","通信","允许",".","为","server","codelab","webpack","adapter","网站","127.0","目前","接入","）"],"title":"开发者优先","title_tokens":["优先","开发者","开发"]},{"location":"dev_guide/接入第三方平台/#_4","text":"创建你的第一个 Scratch 3.0 Extension CodeLab Adapter 可以支持其他平台吗？","text_tokens":["的","codelab","adapter","一个","extension","可以","其他","吗","？","3.0","你","第一"," ","支持","第一个","平台","scratch","创建"],"title":"参考","title_tokens":["参考"]},{"location":"dev_guide/自定义插件/","text":"say python插件","text_tokens":["say"," ","插件","python"],"title":"自定义插件","title_tokens":["自定","定义","插件","自定义"]},{"location":"extension_guide/Aelos/","text":"Aelos Robot ¶ Demonstration： 在 Scratch3 中玩转机器人：Python、Deep Learning、Posenet and Robot！","text_tokens":["demonstration","在","机器人","posenet","：","玩转","scratch3"," ","learning","python","中","！","robot","、","aelos","¶","and","deep","机器"],"title":"Aelos Robot(正在迁移中)","title_tokens":["robot","正在","(","aelos","迁移"," ","中",")"]},{"location":"extension_guide/Aelos/#aelos-robot","text":"Demonstration： 在 Scratch3 中玩转机器人：Python、Deep Learning、Posenet and Robot！","text_tokens":["robot","、","and","demonstration","在","机器人","python","learning","scratch3","posenet","deep"," ","中","！","机器","：","玩转"],"title":"Aelos Robot","title_tokens":["aelos","robot"," "]},{"location":"extension_guide/Aqara/","text":"Tutorial ¶ 提醒 Aqara 是实验性插件，未来可能移除。如果你比较依赖于它，建议自行维护Adapter Node，直接与Aqara云通信，这是一个例子: extension_Aqara_scene.py 。 我们准备长期支持的项目是 Longan hub 、 Home Assistant 和 WebThings 介绍 ¶ Aqara(绿米)智能家居用户可在 CodeLab 创作平台上对智能设备进行编程，让孩子将智能家庭改造为魔法世界吧！ Demo ¶ 更多好玩的演示 参考: CodeLab projects 提醒 目前只支持 Aqara 网关，不支持小米网关。 获取 token ¶ 点击 打开绿米授权 积木，将打开登陆页面，使用 Aqara 账号登陆后，将获得一个token。 连接到云 ¶ 之后将token复制到 连接 积木里, 运行它即可。 hello world ¶ 构建一个入门程序: 当小猫被点击时，将灯泡打开 扩展性 ¶ 使用 场景 积木，可以调用 Aqara APP 里定义的任何场景！ 如果你发现某些设备没有被积木化，可以通过把它纳入场景中，之后通过场景积木调用它！","text_tokens":[",","的","(","时","用户","扩展","一个","可以","上","你","demo","家庭","如果","实验性","我们","化","longan","获取","aqara","家居","tutorial","绿米","projects","设备","后","平台","通信",".","为","codelab","adapter","长期","介绍","调用","账号","移除","点击","即可","让","这是","小米","可能","py",":","在","未来","没有","入门","hub","复制","实验","webthings","token","发现","extension","之后","参考","世界","和","被",")","某些","home","赖于","world","将","任何","_","获得","中","吧","改造","对","通过","登陆","演示","scene","、","assistant","云","只","支持","提醒","当","场景","灯泡","依赖","建议","例子","。","打开","好玩","，","页面","hello","连接","构建","直接","可","展性","定义","运行","多","！","把","魔法","¶","比较","自行","项目","进行","里","程序","智能","插件","使用","积木","复制到","更","node","准备","创作"," ","扩展性","它","编程","维护","与","网关","不","纳入","是","到","app","依赖于","小猫","智能家居","授权","目前","孩子"],"title":"Aqara","title_tokens":["aqara"]},{"location":"extension_guide/Aqara/#tutorial","text":"提醒 Aqara 是实验性插件，未来可能移除。如果你比较依赖于它，建议自行维护Adapter Node，直接与Aqara云通信，这是一个例子: extension_Aqara_scene.py 。 我们准备长期支持的项目是 Longan hub 、 Home Assistant 和 WebThings","text_tokens":["的","这是","可能","一个",":","py","依赖","你","未来","建议","例子","。","如果","hub","实验","实验性","插件","，","我们","webthings","node","extension","准备","aqara","longan"," ","和","它","直接","维护","home","赖于","与","_","是","通信",".","依赖于","scene","、","assistant","adapter","长期","比较","自行","云","支持","提醒","项目","移除"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/Aqara/#_1","text":"Aqara(绿米)智能家居用户可在 CodeLab 创作平台上对智能设备进行编程，让孩子将智能家庭改造为魔法世界吧！","text_tokens":["让","(","用户","在","上","智能","家庭","，","aqara","创作","家居"," ","世界","绿米",")","可","编程","孩子","设备","将","！","吧","平台","改造","对","为","魔法","codelab","智能家居","进行"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/Aqara/#demo","text":"更多好玩的演示 参考: CodeLab projects 提醒 目前只支持 Aqara 网关，不支持小米网关。","text_tokens":["的","小米",":","。","好玩","，","更","aqara","参考"," ","projects","网关","多","不","演示","codelab","只","支持","提醒","目前"],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/Aqara/#token","text":"点击 打开绿米授权 积木，将打开登陆页面，使用 Aqara 账号登陆后，将获得一个token。","text_tokens":["登陆","使用","，","积木","页面","将","一个","token","aqara","账号","授权"," ","获得","。","后","点击","绿米","打开"],"title":"获取 token","title_tokens":["token"," ","获取"]},{"location":"extension_guide/Aqara/#_2","text":"之后将token复制到 连接 积木里, 运行它即可。","text_tokens":[",","即可","复制","复制到","token","将","之后","积木","里","运行"," ","连接","。","它"],"title":"连接到云","title_tokens":["到","云","连接"]},{"location":"extension_guide/Aqara/#hello-world","text":"构建一个入门程序: 当小猫被点击时，将灯泡打开","text_tokens":["被","小猫","时","，","一个",":","将","程序"," ","当","构建","灯泡","入门","点击","打开"],"title":"hello world","title_tokens":["world"," ","hello"]},{"location":"extension_guide/Aqara/#_3","text":"使用 场景 积木，可以调用 Aqara APP 里定义的任何场景！ 如果你发现某些设备没有被积木化，可以通过把它纳入场景中，之后通过场景积木调用它！","text_tokens":["的","可以","里","你","没有","如果","使用","，","积木","发现","化","之后","aqara"," ","被","它","某些","定义","任何","设备","！","把","中","纳入","通过","app","调用","场景"],"title":"扩展性","title_tokens":["展性","扩展性","扩展"]},{"location":"extension_guide/Box2D/","text":"Tutorial ¶ 该文档由 @Hanson 同学 创建。 介绍 ¶ Box2D 是一个被广泛使用的 2D C++物理引擎，Codelab Scratch 中的 Box2D 插件基于 Javascript 构建。 不依赖于 CodeLab Adapter。 步骤 1 在 Codelab Scratch 中导入 Box2D 插件 ¶ 步骤 2 创建一个 Box2D 世界 ¶ 创建一个世界之后才能模拟物理。 使用 setup stage 模块在舞台上创建一个世界。它有 3 种样式： Boxed stage：有地板、墙和天花板的世界。墙和地板分别是舞台的下、左右边框，而天花板在舞台的 y=940 的高度。 Open(with floor)：只有地板的世界。 Open(no floor)：啥也没有的世界，但它还是一个世界。 之后可以选择设置重力中心（set gravity to），可以想象那里有一个质量无限大的物体吸引着其他物体。也可以不设置，默认在舞台下方。 步骤 3 使角色加入到物理世界 ¶ 只有被加入到物理世界他才会被物理法则所影响。 模块：Enable for** mode ** 参数 1 影响的对象： This costume 这个角色 This circle 角色的外接圆 This polygon 并不知道是什么意思，因为不会使用 All sprites 所有角色 参数 2 模式： Normal 普通 Precision 精确 步骤 4 重复模拟 ¶ 使用一个循环，其中有模块 step simulate 来重复模拟。 完成！ 至此，最基础的架构世界已经完成了。你现在可以使用运动模块等来让角色动起来。这些模块很好理解，只需要在架构好的世界里尝试一次就知道了。 注意：你的角色的质量会因大小而改变。你可以设置密度来影响它。 其它模块解释: Push with force** in direction ** 向某个方向施加一定大小的力。有惯性的影响。 注意：你的角色的质量会因大小而改变。你可以设置密度来影响它。 Spin with force ___ 顺时针旋转角色。参数为力量大小，有方向。同样受到惯性的影响。 Set density**_ roughness_** 设置密度和光滑程度。不知为何这里采用的是形容词来确定五种程度。 Set fixed___ 设置固定。 Touching any/feet 碰撞判断，参数为整个身体/脚。 Scroll 指的是舞台的滚动，舞台、重力中心和所有角色都会滚动。 异常 ¶ 当你的程序中出现了问题时，它并不会崩溃。现象就是你无法点击小绿旗来启动这个程序。此时你需要做的是检查程序，或是试着移除部分程序以确定哪里出现了问题。 已知问题 ¶ 当使角色加入物理世界时模块 Enable for** mode **参数为 this polygon 时会出现未知问题","text_tokens":["的","绿旗","步骤","(","时","所","可以","一个","那里","解释","step","上","with","形容","你","costume","意思","部分","天花板","mode","密度","1","啥","现在","就","形容词","（","法则","想象","他","最","做","tutorial","问题","导入","天花","并不知道","setup","力量","什么","这些","指","scratch","需要","广泛","模式","为","启动","codelab","scroll","for","介绍","adapter","地板","了","其它","未知","滚动","脚","设置","以","下","会","因为","所有","点击","物体","移除","已经","检查","让","基于",":","在","重复","动","没有","边框","方向","时会","@","之后","改变","世界","被","和",")","舞台","异常","普通","质量","/","2d","赖于","此时","来","注意","_","中","现象","enable","某个","重力","这里","、","分别","判断","整个","2","墙","只","c++","当","精确","或是","其中","同学","架构","*","才","知道","any","试着","并","碰撞","依赖","尝试","好","着","高度","文档","。","：","polygon","不知","normal","运动","会因","顺时针","3","为何","无法","box2d","样式","也","，","不会","受到","set","检查程序","由","完成","to","就是","物理","引擎","circle","旋转","构建","feet","崩溃","下方","hanson","起来","touching","无限大","940","模块","时针","模拟","只有","等","基础","！","光滑","该","y","惯性","有","precision","很","才能","施加","已知","使","还是","¶","gravity","向","其他","默认","而","sprites","力","参数","）","加入","direction","boxed","里","程序","种","程度","确定","4","一次","一定","出现","spin","插件","理解","使用","固定","in","=","density","五种","采用","___","身体","哪里"," ","循环","javascript","它","fixed","open","但","大小","floor","左右","all","吸引","顺时","这个","中心","同样","this","不","no","影响","都","小","是","到","roughness","角色","stage","无限","依赖于","至此","force","simulate","对象","选择","外接圆","push","当使","创建"],"title":"Box2D","title_tokens":["box2d"]},{"location":"extension_guide/Box2D/#tutorial","text":"该文档由 @Hanson 同学 创建。","text_tokens":["文档","同学","@","由","。"," ","该","hanson","创建"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/Box2D/#_1","text":"Box2D 是一个被广泛使用的 2D C++物理引擎，Codelab Scratch 中的 Box2D 插件基于 Javascript 构建。 不依赖于 CodeLab Adapter。","text_tokens":["的","基于","一个","依赖","。","box2d","插件","使用","，"," ","物理","引擎","javascript","构建","被","2d","赖于","不","中","是","scratch","广泛","codelab","依赖于","adapter","c++"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/Box2D/#1-codelab-scratch-box2d","text":"","text_tokens":[],"title":"步骤 1 在 Codelab Scratch 中导入 Box2D 插件","title_tokens":["1","box2d","步骤","codelab","插件","在"," ","中","scratch","导入"]},{"location":"extension_guide/Box2D/#2-box2d","text":"创建一个世界之后才能模拟物理。 使用 setup stage 模块在舞台上创建一个世界。它有 3 种样式： Boxed stage：有地板、墙和天花板的世界。墙和地板分别是舞台的下、左右边框，而天花板在舞台的 y=940 的高度。 Open(with floor)：只有地板的世界。 Open(no floor)：啥也没有的世界，但它还是一个世界。 之后可以选择设置重力中心（set gravity to），可以想象那里有一个质量无限大的物体吸引着其他物体。也可以不设置，默认在舞台下方。","text_tokens":["的","(","可以","一个","boxed","在","那里","上","with","种","着","高度","。","：","天花板","边框","没有","3","啥","样式","也","使用","，","=","之后","（","set","想象","to","物理"," ","世界","和","它",")","舞台","open","但","下方","天花","floor","质量","左右","无限大","940","setup","模块","吸引","中心","模拟","只有","不","no","是","y","有","才能","stage","重力","、","无限","分别","还是","gravity","地板","其他","默认","墙","而","设置","选择","下","）","物体","创建"],"title":"步骤 2 创建一个 Box2D 世界","title_tokens":["box2d","步骤","一个","2"," ","世界","创建"]},{"location":"extension_guide/Box2D/#3","text":"只有被加入到物理世界他才会被物理法则所影响。 模块：Enable for** mode ** 参数 1 影响的对象： This costume 这个角色 This circle 角色的外接圆 This polygon 并不知道是什么意思，因为不会使用 All sprites 所有角色 参数 2 模式： Normal 普通 Precision 精确","text_tokens":["的","加入","*","才","知道","所","所有","polygon","costume","。","：","不知","意思","mode","normal","1","使用","，","不会","法则","他","物理"," ","circle","世界","被","普通","all","并不知道","模块","这个","只有","this","什么","影响","enable","到","是","precision","模式","角色","for","2","sprites","参数","对象","外接圆","会","因为","精确"],"title":"步骤 3 使角色加入到物理世界","title_tokens":["3","角色","加入","步骤","使"," ","物理","世界","到"]},{"location":"extension_guide/Box2D/#4","text":"使用一个循环，其中有模块 step simulate 来重复模拟。 完成！ 至此，最基础的架构世界已经完成了。你现在可以使用运动模块等来让角色动起来。这些模块很好理解，只需要在架构好的世界里尝试一次就知道了。 注意：你的角色的质量会因大小而改变。你可以设置密度来影响它。 其它模块解释: Push with force** in direction ** 向某个方向施加一定大小的力。有惯性的影响。 注意：你的角色的质量会因大小而改变。你可以设置密度来影响它。 Spin with force ___ 顺时针旋转角色。参数为力量大小，有方向。同样受到惯性的影响。 Set density**_ roughness_** 设置密度和光滑程度。不知为何这里采用的是形容词来确定五种程度。 Set fixed___ 设置固定。 Touching any/feet 碰撞判断，参数为整个身体/脚。 Scroll 指的是舞台的滚动，舞台、重力中心和所有角色都会滚动。","text_tokens":["的","可以","一个","形容","解释","step","with","你","密度","现在","就","形容词","最","力量","这些","指","需要","为","scroll","了","其它","滚动","脚","设置","所有","会","已经","让",":","在","重复","动","方向","改变","世界","和","舞台","质量","/","来","注意","_","某个","这里","重力","、","判断","整个","只","其中","架构","*","知道","any","碰撞","尝试","好","会因","。","：","顺时针","运动","不知","为何","受到","，","set","完成","旋转","feet","起来","touching","时针","模块","模拟","等","光滑","基础","！","惯性","有","很","施加","向","而","力","参数","direction","里","程度","确定","一次","一定","spin","固定","理解","使用","in","五种","density","采用","___","身体","循环"," ","它","fixed","大小","顺时","中心","同样","都","影响","roughness","是","角色","至此","force","simulate","push"],"title":"步骤 4 重复模拟","title_tokens":["步骤","模拟","重复"," ","4"]},{"location":"extension_guide/Box2D/#_2","text":"当你的程序中出现了问题时，它并不会崩溃。现象就是你无法点击小绿旗来启动这个程序。此时你需要做的是检查程序，或是试着移除部分程序以确定哪里出现了问题。","text_tokens":["的","绿旗","时","小","试着","并","程序","你","确定","。","部分","出现","无法","，","不会","哪里","检查程序","就是","做","崩溃","它","问题","此时","来","这个","中","移除","现象","是","需要","启动","了","当","以","或是","点击","检查"],"title":"异常","title_tokens":["异常"]},{"location":"extension_guide/Box2D/#_3","text":"当使角色加入物理世界时模块 Enable for** mode **参数为 this polygon 时会出现未知问题","text_tokens":["加入","*","时","polygon","mode","出现","时会","物理"," ","世界","问题","模块","this","enable","角色","为","for","未知","当使","参数"],"title":"已知问题","title_tokens":["问题","已知"]},{"location":"extension_guide/Calypso/","text":"Tutorial ¶ Calypso 是 CMU 大学七年来对儿童如何学习基于规则的机器人编程的研究成果。由 David S. Touretzky 博士构建，他是 CMU 计算机科学和神经认知基础中心的研究教授。此外，Touretzky 一直活跃在互联网，主张言论自由。 Calypso 目前用于为 Cozmo 编程。被广泛用于 AI 教育项目. Demo ¶ 当 Cozmo 看到我表情悲伤时，将帮我升起窗帘: \"Give you some sunshine\" 相关代码: 在 Calypso 中: 源文件: give-you-sunshine.calypso , 关键部分是 当 cozmo 说 message sad 时, sad 消息将被发送到 Scratch EIM 插件里。 实际上只要 Cozmo 说的话形如 message xxx , xxx 消息都将被发送到 Scratch EIM 插件里。 想法最初来自 @jinlei 提到的圣经里关于 powerful word 的段落。 -- 在 Scratch 中: 源文件: Scratch-calypso 参考 ¶ calypso.software 使用 Calypso 的世界 AI 青年比赛（WAICY） Reading, Writing, 'Rithmetic ... and Now, Robotics AI4All 学生使用 Calypso 进行 AI 入门 介绍了人工智能主题（计算机视觉，路径规划，文本到语音等） ReadyAI 现在提供 Calypso 的机构许可证 : 在学校，外展计划和计算机营中使用 Calypso Activity: Cozmo's Shack","text_tokens":[",","的","算机","时","rithmetic","段落","robotics","看到","窗帘","demo","部分","some","calypso","我","waicy","now","现在","成果","（","提到","他","言论自由","tutorial","'","儿童","教授","关于","说","相关","scratch","广泛",".","为","关键","and","介绍","了","reading","规则","机器","shack","powerful","xxx","david","-","送到","基于",":","在","机器人","ai","sad","比赛","认知","\"","cozmo","入门","学校","s","计划","@","来自","许可","语音","主张","源文件","参考","文件","互联网","世界","和","被","七年","计算机科学","jinlei","将","来","活跃","最初","此外","中","形","路径","计算机","规划","机构","对","青年","...","当","发送","eim","大学","如","联网","外展","研究成果","用于","如何","一直","。","教育","博士","，","视觉","由","构建","文本","message","自由","互联","言论","writing","等","基础","ai4all","¶","升起","人工","项目","进行","）","word","提供","主题","里","许可证","智能","学生","插件","使用","圣经","实际","帮","只要","营中"," ","touretzky","software","give","编程","实际上","代码","科学","cmu","中心","都","you","人工智能","研究","sunshine","是","到","神经","发送到","悲伤","的话","计算","表情","消息","readyai","学习","目前","想法","activity"],"title":"Calypso","title_tokens":["calypso"]},{"location":"extension_guide/Calypso/#tutorial","text":"Calypso 是 CMU 大学七年来对儿童如何学习基于规则的机器人编程的研究成果。由 David S. Touretzky 博士构建，他是 CMU 计算机科学和神经认知基础中心的研究教授。此外，Touretzky 一直活跃在互联网，主张言论自由。 Calypso 目前用于为 Cozmo 编程。被广泛用于 AI 教育项目.","text_tokens":["联网","的","david","算机","基于","研究成果","机器人","在","用于","如何","一直","ai","认知","。","cozmo","s","教育","calypso","博士","，","成果","由","主张","他","言论自由"," ","touretzky","构建","互联网","和","目前","被","儿童","编程","教授","七年","自由","互联","计算机科学","言论","来","活跃","此外","科学","cmu","中心","基础","研究","计算机","是","对","广泛",".","神经","为","计算","学习","规则","机器","大学","项目"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/Calypso/#demo","text":"当 Cozmo 看到我表情悲伤时，将帮我升起窗帘: \"Give you some sunshine\" 相关代码: 在 Calypso 中: 源文件: give-you-sunshine.calypso , 关键部分是 当 cozmo 说 message sad 时, sad 消息将被发送到 Scratch EIM 插件里。 实际上只要 Cozmo 说的话形如 message xxx , xxx 消息都将被发送到 Scratch EIM 插件里。 想法最初来自 @jinlei 提到的圣经里关于 powerful word 的段落。 -- 在 Scratch 中: 源文件: Scratch-calypso","text_tokens":[",","powerful","xxx","的","-","送到","word","时",":","在","sad","看到","窗帘","里","段落","\"","。","cozmo","部分","some","calypso","我","插件","，","@","实际","来自","圣经","帮","源文件","只要","提到"," ","文件","被","give","关于","说","message","实际上","jinlei","将","代码","最初","都","you","中","sunshine","相关","形","是","scratch",".","发送到","悲伤","关键","的话","表情","消息","升起","当","发送","eim","想法","如"],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/Calypso/#_1","text":"calypso.software 使用 Calypso 的世界 AI 青年比赛（WAICY） Reading, Writing, 'Rithmetic ... and Now, Robotics AI4All 学生使用 Calypso 进行 AI 入门 介绍了人工智能主题（计算机视觉，路径规划，文本到语音等） ReadyAI 现在提供 Calypso 的机构许可证 : 在学校，外展计划和计算机营中使用 Calypso Activity: Cozmo's Shack","text_tokens":[",","外展","的","算机","提供","rithmetic","主题",":","robotics","在","ai","比赛","许可证","智能","学校","入门","计划","cozmo","s","calypso","waicy","now","学生","现在","使用","，","视觉","许可","（","语音","营中"," ","software","世界","和","文本","'","writing","人工智能","等","路径","规划","计算机","到","机构",".","ai4all","and","介绍","了","计算","readyai","reading","青年","...","shack","人工","进行","）","activity"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/EP3/","text":"RoboMaster 3.0 ¶ 提醒 目前只支持RoboMaster EP(暂不支持S1)，受限于大疆的开放接口: RoboMaster SDK 新手入门 - EP 篇 RoboMaster EP 插件的 3.0 版本， 基于 DJI 官方的 SDK: RoboMaster SDK 库。 能够充分利用设备的能力。 该插件能做到阻塞式( wait_for_completed )运行，这对于执行 序列 类程序很棒 使用说明 ¶ 目前该插件并未内置到 Adapter 中（因其复杂的打包依赖，而且跨平台兼容性不好）。 我们目前将插件构建为 Adapter Node ，可以在Adapter外部以普通Python文件运行，一旦运行起来，与普通Adapter插件是一样的，能够与Adapter体系的所有事物交互。 Python环境 ¶ 首先你本地需要有 Python 环境（ Python>=3.6 ） 你可以到 Python 官方 下载，也可以使用 CodeLab放在 国内的版本(Python3.7) 提醒 Mac 用户和 Linux 本地很可能内置了 Python3 安装依赖 ¶ pip install robomaster codelab_adapter_client --upgrade 开始！ ¶ 提醒 Tello 会占用 wifi，导致电脑无法联网，请使用 CodeLab Adapter 的离线模式: FAQ：离线使用 (在 >=3.4.0 的版本中可用)。 步骤 1：打开 CodeLab Scratch ¶ 运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。 步骤 1：运行 node_RoboMaster3.py ¶ 将 node_RoboMaster3.py 插件下载到本地（随便放在一个文件夹里），在命令行中进入到这个文件夹，使用 python node_RoboMaster3.py 运行它。 步骤 2: 前进! ¶ 选择 scratch3 中的 EIM 插件. 以下是一个简单 demo: EP3-demo 进阶 ¶ 更多API参考文档: RoboMaster SDK","text_tokens":["的","步骤","(","用户","可以","安装","一个","看到","你","wifi","并未","wait","demo","其","内置","执行","pip","绿色","容性","1","我们","利用","而且","简单",">","（","事物","说明","新手","式","正常","离线","sdk","设备","平台","需要","scratch","模式","对于","为",".","兼容","codelab","随便","for","充分利用","adapter","了","3.6","tello","一样","以","所有","充分","会","-","本地","一旦","基于","可能","跨平台","接口",":","在","py","序列","3.4","前进","开放","入门","install","robomaster3","completed","下载","篇","参考","成功","类","文件","大疆","和",")","普通","将","python","_","官方","中","件夹","首先","linux","2","复杂","只","支持","提醒","进阶","eim","联网","!","能够","依赖","兼容性","外部","ep","。","：","文档","不好","0","体系","打开","ep3","无法","库","也","，","faq","可用","scratch3","dji","构建","确保","连接","放在","开始","起来","这","运行","进入","多","以下","！","该","命令","python3","请","有","因","很","新手入门","¶","交互","指示","在线","国内","限于","打包","client","api","）","upgrade","电脑","代表","版本","robomaster","s1","程序","文件夹","里","占用","分利","受限","导致","指示灯","插件","使用","python3.7","=","node","更"," ","很棒","它","显示","能","命令行","暂","与","受限于","做到","这个","不","adapte","到","是","环境","阻塞","mac","3.0","能力","选择","目前"],"title":"RoboMaster 3.0","title_tokens":["3.0","robomaster"," "]},{"location":"extension_guide/EP3/#robomaster-30","text":"提醒 目前只支持RoboMaster EP(暂不支持S1)，受限于大疆的开放接口: RoboMaster SDK 新手入门 - EP 篇 RoboMaster EP 插件的 3.0 版本， 基于 DJI 官方的 SDK: RoboMaster SDK 库。 能够充分利用设备的能力。 该插件能做到阻塞式( wait_for_completed )运行，这对于执行 序列 类程序很棒","text_tokens":["的","-","(","版本","基于","能够","robomaster","s1","接口",":","程序","序列","分利","wait","ep","开放","入门","。","受限","充分","completed","执行","插件","库","利用","，","篇"," ","dji","类","很棒","大疆",")","新手","式","能","sdk","暂","设备","受限于","做到","运行","_","这","不","官方","该","对于","新手入门","阻塞","充分利用","for","3.0","只","支持","提醒","限于","能力","目前"],"title":"RoboMaster 3.0","title_tokens":["3.0","robomaster"," "]},{"location":"extension_guide/EP3/#_1","text":"目前该插件并未内置到 Adapter 中（因其复杂的打包依赖，而且跨平台兼容性不好）。 我们目前将插件构建为 Adapter Node ，可以在Adapter外部以普通Python文件运行，一旦运行起来，与普通Adapter插件是一样的，能够与Adapter体系的所有事物交互。","text_tokens":["的","能够","一旦","所有","可以","跨平台","在","依赖","兼容性","外部","并未","。","其","内置","不好","体系","容性","插件","而且","我们","，","（","node"," ","事物","文件","构建","起来","普通","将","与","python","运行","中","该","到","平台","是","因","为","兼容","adapter","一样","复杂","交互","打包","以","目前","）"],"title":"使用说明","title_tokens":["说明","使用"]},{"location":"extension_guide/EP3/#python","text":"首先你本地需要有 Python 环境（ Python>=3.6 ） 你可以到 Python 官方 下载，也可以使用 CodeLab放在 国内的版本(Python3.7) 提醒 Mac 用户和 Linux 本地很可能内置了 Python3","text_tokens":["的","本地","版本","(","可以","用户","可能","你","内置","也","下载","，","使用",">","=","（","python3.7"," ","和","放在",")","python","官方","到","需要","环境","python3","有","很","codelab","首先","linux","了","mac","3.6","国内","提醒","）"],"title":"Python环境","title_tokens":["环境","python"]},{"location":"extension_guide/EP3/#_2","text":"pip install robomaster codelab_adapter_client --upgrade","text_tokens":["pip","-","codelab","adapter","robomaster","_"," ","client","install","upgrade"],"title":"安装依赖","title_tokens":["安装","依赖"]},{"location":"extension_guide/EP3/#_3","text":"提醒 Tello 会占用 wifi，导致电脑无法联网，请使用 CodeLab Adapter 的离线模式: FAQ：离线使用 (在 >=3.4.0 的版本中可用)。","text_tokens":["联网","的","(","版本",":","在","占用","wifi","3.4","。","：","0","导致","无法","使用","，","faq",">","=","可用"," ",")","离线","中","请","模式",".","codelab","adapter","tello","提醒","会","电脑"],"title":"开始！","title_tokens":["开始","！"]},{"location":"extension_guide/EP3/#1-codelab-scratch","text":"运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。","text_tokens":["代表","看到","。","指示灯","绿色","，"," ","成功","连接","确保","显示","正常","与","运行","adapte","平台","scratch","codelab","adapter","指示","在线"],"title":"步骤 1：打开 CodeLab Scratch","title_tokens":["1","步骤","codelab"," ","：","scratch","打开"]},{"location":"extension_guide/EP3/#1-node_robomaster3py","text":"将 node_RoboMaster3.py 插件下载到本地（随便放在一个文件夹里），在命令行中进入到这个文件夹，使用 python node_RoboMaster3.py 运行它。","text_tokens":["本地","py","一个","文件夹","里","在","robomaster3","。","插件","下载","，","使用","node","（"," ","文件","放在","它","命令行","将","python","进入","_","这个","运行","中","到","命令",".","件夹","随便","）"],"title":"步骤 1：运行 node_RoboMaster3.py","title_tokens":[".","1","步骤","py","node","运行","_"," ","robomaster3","："]},{"location":"extension_guide/EP3/#2","text":"选择 scratch3 中的 EIM 插件. 以下是一个简单 demo: EP3-demo","text_tokens":["ep3",".","的","插件","简单","-","一个",":","scratch3","以下"," ","demo","中","选择","eim","是"],"title":"步骤 2: 前进!","title_tokens":["!","步骤",":","2"," ","前进"]},{"location":"extension_guide/EP3/#_4","text":"更多API参考文档: RoboMaster SDK","text_tokens":["sdk","更",":","robomaster","多","参考"," ","api","文档"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/EasyOCR/","text":"Tutorial ¶ 支持70多种语言的开箱可用OCR，包括中文，日文，韩文和泰文... EasyOCR 的一层薄薄包装，将 EasyOCR 的能力引入 Scratch 使用 ¶ 运行 CodeLab Adapter。 使用 pip 安装 easyocr: python -m pip install easyocr codelab_adapter_client>=1.9.2 运行以下程序: from codelab_adapter_client.utils import run_monitor , save_base64_to_image import easyocr reader = easyocr . Reader ([ 'ch_sim' , 'en' ], gpu = True ) # need to run only once to load model into memory def monitor ( msg ): filename = save_base64_to_image ( msg , \"tmp_img\" ) result = reader . readtext ( filename , detail = 0 ) if result : return str ( result ) run_monitor ( monitor ) 对以上机制不熟悉的朋友可以参考 Python对象的连接器：EIM 插件 打开 测试项目 由于 easyocr 的计算发生在本地，且基于神经网络，所以处理时间比较久， 处理后的结果将返回到 收到的消息 总结 ¶ 这个例子展示了，使用 CodeLab Adapter 可以轻松将 AI 能力接入Scratch","text_tokens":[",","且","的","(","安装","可以","所以","tmp","pip","into","多种语言",">","tutorial","'","发生","ch","多种","import","]","后","scratch","msg",".","测试","codelab","adapter","了","1.9","接入","en","-","本地","utils","以上","基于","easyocr",":","在","机制","ai","泰文","reader","处理","\"","install","run","神经网络","语言","gpu","参考","ocr","和","一层",")","网络","m","日文","将","python","once","_","from","对","总结","接器","2","...","filename","支持","eim","熟悉","str","展示","薄薄","包装","例子","70","。","：","0","model","打开","收到","memory","，","可用","to","#","连接","引入","save","base64","运行","以下","only","detail","连接器","monitor","神经网","true","返回","¶","久","轻松","韩文","比较","sim","client","项目","load","程序","结果","开箱","[","测试项目","插件","readtext","使用","="," ","时间","由于","中文","img","def","return","这个","不","到","need","if","result","神经","计算","包括","消息","朋友","image","能力","对象"],"title":"EasyOCR","title_tokens":["easyocr"]},{"location":"extension_guide/EasyOCR/#tutorial","text":"支持70多种语言的开箱可用OCR，包括中文，日文，韩文和泰文... EasyOCR 的一层薄薄包装，将 EasyOCR 的能力引入 Scratch","text_tokens":["的","薄薄","easyocr","包装","泰文","70","开箱","多种语言","，","语言","可用","ocr"," ","和","一层","引入","中文","日文","将","多种","scratch","包括","韩文","...","支持","能力"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/EasyOCR/#_1","text":"运行 CodeLab Adapter。 使用 pip 安装 easyocr: python -m pip install easyocr codelab_adapter_client>=1.9.2 运行以下程序: from codelab_adapter_client.utils import run_monitor , save_base64_to_image import easyocr reader = easyocr . Reader ([ 'ch_sim' , 'en' ], gpu = True ) # need to run only once to load model into memory def monitor ( msg ): filename = save_base64_to_image ( msg , \"tmp_img\" ) result = reader . readtext ( filename , detail = 0 ) if result : return str ( result ) run_monitor ( monitor ) 对以上机制不熟悉的朋友可以参考 Python对象的连接器：EIM 插件 打开 测试项目 由于 easyocr 的计算发生在本地，且基于神经网络，所以处理时间比较久， 处理后的结果将返回到 收到的消息","text_tokens":[",","且","的","(","安装","可以","所以","tmp","pip","into",">","'","发生","ch","import","]","后","msg",".","测试","codelab","adapter","1.9","en","-","本地","utils","以上","基于","easyocr",":","在","机制","reader","处理","\"","install","run","神经网络","gpu","参考",")","网络","m","将","python","once","_","from","对","接器","2","filename","eim","熟悉","str","。","：","0","model","打开","收到","memory","，","to","#","连接","save","base64","运行","以下","only","detail","连接器","monitor","神经网","true","返回","久","比较","sim","client","项目","load","程序","结果","[","测试项目","插件","readtext","使用","="," ","时间","由于","img","def","return","不","到","need","if","result","神经","计算","消息","朋友","image","对象"],"title":"使用","title_tokens":["使用"]},{"location":"extension_guide/EasyOCR/#_2","text":"这个例子展示了，使用 CodeLab Adapter 可以轻松将 AI 能力接入Scratch","text_tokens":["展示","codelab","使用","，","了","adapter","可以","轻松","将","ai","这个"," ","例子","能力","接入","scratch"],"title":"总结","title_tokens":["总结"]},{"location":"extension_guide/GameShell/","text":"Tutorial ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 使用 ¶ 参考 作为游戏机厅的 CodeLab 可编程空间 Demo ¶ 将 GameShell 接入 CodeLab Adapter 之后， 我们将其用作 CodeLab 可编程空间的控制手柄:","text_tokens":["的","版本","其设","安装",":","浏览","依赖","在","厅","控制","建议","demo","其","最佳","我们","firefox","使用","，","更","之后","手柄","可编程","参考"," ","用作","tutorial","效果","编程","浏览器","/","将","游戏机","多","可编","官方","scratch","团队","现阶段",".","为","chrome","codelab","游戏","作为","¶","adapter","空间","默认","支持","目前","接入","陆续","阶段","gameshell"],"title":"GameShell","title_tokens":["gameshell"]},{"location":"extension_guide/GameShell/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/GameShell/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/GameShell/#_2","text":"参考 作为游戏机厅的 CodeLab 可编程空间","text_tokens":["的","codelab","游戏","作为","游戏机","可编程","厅","参考","可编"," ","空间","编程"],"title":"使用","title_tokens":["使用"]},{"location":"extension_guide/GameShell/#demo","text":"将 GameShell 接入 CodeLab Adapter 之后， 我们将其用作 CodeLab 可编程空间的控制手柄:","text_tokens":["的",":","其","我们","，","之后","可编程"," ","用作","编程","接入","将","可编","codelab","adapter","空间","手柄","控制","gameshell"],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/HCI/","text":"Tutorial ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：安装依赖 ¶ Windows 和 Mac 用户开箱可用。 Linux需要安装依赖: 参考 PyAutoGUI Install pip3 install codelab_adapter_client --upgrade ps: 使用 Python3 提醒 MacOS 升级到最新版本后，可能会导致部分控制类积木无法使用，使系统安全机制升级造成的（我也是可悲的 Mac 用户，下个计算机一定要使用开源系统。）。详情参考: Pyautogui doesn't seem to work on macOS Mojave 。 相关问题: Catalina does not allow to capture the screen 。这个问题的结局方案似乎是让系统信任Adapter内置的Python: codelab-adapter-3_7_3-mac.app/Contents/Resources/Support/bin/python3 步骤 2：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 3：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 4：加载 HCI 插件 ¶ 在 Web UI 中点击加载 HCI 插件 步骤 5：Scratch3 HCI 插件 ¶ 选择对应的 Scratch3 插件：HCI demo ¶ 尚雅学校目前在使用 CodeLab Adapter，有位老师想使用魔杖激活开场视频，使用 HCI 插件可以轻松做到: 以下是源码: 魔杖播放视频 Windows 10 用户 ¶ Windows10的某些版本，默认会在页面下方闪烁播放器图标，而不是打开。 可以考虑使用网页打开视频链接，如果你的视频在本地，可以托管给 Adapter，具体而言: 在 Adapter Web UI 里 打开扩展目录 将视频放到 扩展目录 下的 src 目录里 现在这个视频可以使用链接打开了! 它的地址为: https://codelab-adapter.codelab.club:12358/static/1608804837247213.mp4 , 注意，最后的 1608804837247213.mp4 是你的视频名字，最好不用中文。 这是一个示例程序: 魔杖开场视频--使用链接 高阶用法 ¶ HCI 插件允许你写 Python 代码， PyAutoGUI 文档中的所有功能你都可以在 Scratch 中使用。 Tips 如果你想使用HCI接管游戏，要注意 press 是瞬间行为（一般无效），一般游戏是在大循环中检测的你是否按下某个按键，所以建议按下一段时间（使用keyDown和keyUp，中间间隔一会儿。）","text_tokens":[",","升级","的","步骤","算机","扩展","用户","安装","可以","一个","所以","最新","上","你","行为","pyautogui","demo","部分","does","内置","大","我","如果","绿色","1","现在","结局","（","可悲","中间","club","一段","tutorial","说明","接管","'","问题","浏览器","正常","这儿","无效","功能","图标","按下","后","相关","scratch","需要","现阶段",".","为","t","启动","codelab","对应","adapter","了","screen","catalina","有位","press","keyup","要","下","会","所有","点击","让","小圆点","-","这是","本地","其设","可能",":","在","机制","https","学校","箭头","install","播放器","mp4","ui","不是","之后","参考","链接","类","效果","和","某些","keydown","pip3","/","将","注意","python","圆点","_","目录","造成","官方","seem","中","想","检测","计算机","名字","考虑","播放","示例","某个","chrome","windows10","游戏","linux","双击","2","支持","提醒","老师","网页","mojave","具体","陆续","最后","呈现","!","是否","用法","capture","方案","浏览","依赖","下个","建议","support","。","：","文档","bin","打开","3","无法","也","firefox","给","，","或者","页面","web","会儿","可用","to","work","scratch3","连接","下方","not","开场","高阶","间隔","激活","信任","开源","加载","放到","多","以下","系统","如下","瞬间","python3","一会","允许","使","¶","allow","似乎","hci","轻松","默认","而","写","client","系统安全","一段时间","upgrade","）","阶段","按键","版本","on","里","程序","魔杖","一般","7","10","4","开箱","一定","详情","导致","托管","而言","一会儿","闪烁","插件","使用","积木","contents","更","12358"," ","循环","时间","resources","视频","src","doesn","它","中文","安全","windows","与","代码","做到","tips","这个","static","1608804837247213","the","都","图中","尚雅","到","是","团队","源码","app","ps","最好","计算","不用","5","mac","scratch3.0","段时间","地址","选择","所指","目前","macos","最佳","控制"],"title":"HCI","title_tokens":["hci"]},{"location":"extension_guide/HCI/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/HCI/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/HCI/#1","text":"Windows 和 Mac 用户开箱可用。 Linux需要安装依赖: 参考 PyAutoGUI Install pip3 install codelab_adapter_client --upgrade ps: 使用 Python3 提醒 MacOS 升级到最新版本后，可能会导致部分控制类积木无法使用，使系统安全机制升级造成的（我也是可悲的 Mac 用户，下个计算机一定要使用开源系统。）。详情参考: Pyautogui doesn't seem to work on macOS Mojave 。 相关问题: Catalina does not allow to capture the screen 。这个问题的结局方案似乎是让系统信任Adapter内置的Python: codelab-adapter-3_7_3-mac.app/Contents/Resources/Support/bin/python3","text_tokens":["升级","的","算机","用户","安装","最新","pyautogui","部分","does","内置","我","结局","（","可悲","'","问题","后","相关","需要","t",".","codelab","adapter","screen","catalina","要","会","让","-","可能",":","机制","install","参考","类","和","pip3","/","python","_","造成","seem","计算机","linux","提醒","mojave","capture","方案","下个","依赖","support","。","bin","3","无法","也","，","可用","to","work","not","信任","开源","系统","python3","使","allow","似乎","client","系统安全","）","upgrade","版本","on","7","开箱","一定","详情","导致","使用","积木","contents"," ","resources","doesn","安全","windows","这个","the","到","是","app","ps","计算","mac","macos","控制"],"title":"步骤 1：安装依赖","title_tokens":["1","步骤","安装","依赖"," ","："]},{"location":"extension_guide/HCI/#2-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 2：打开 Codelab Adapter","title_tokens":["步骤","codelab","adapter","2"," ","：","打开"]},{"location":"extension_guide/HCI/#3-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 3：打开 Codelab Scratch3","title_tokens":["3","步骤","codelab","scratch3"," ","：","打开"]},{"location":"extension_guide/HCI/#4-hci","text":"在 Web UI 中点击加载 HCI 插件","text_tokens":["ui","插件","加载","web","hci","在"," ","中","点击"],"title":"步骤 4：加载 HCI 插件","title_tokens":["插件","步骤","加载","hci"," ","4","："]},{"location":"extension_guide/HCI/#5scratch3-hci","text":"选择对应的 Scratch3 插件：HCI","text_tokens":["对应","的","插件","hci","scratch3"," ","选择","："],"title":"步骤 5：Scratch3 HCI 插件","title_tokens":["插件","步骤","hci","5","scratch3"," ","："]},{"location":"extension_guide/HCI/#demo","text":"尚雅学校目前在使用 CodeLab Adapter，有位老师想使用魔杖激活开场视频，使用 HCI 插件可以轻松做到: 以下是源码: 魔杖播放视频","text_tokens":["可以",":","在","魔杖","学校","插件","使用","，"," ","视频","开场","激活","做到","以下","想","尚雅","是","源码","播放","codelab","adapter","hci","轻松","有位","老师","目前"],"title":"demo","title_tokens":["demo"]},{"location":"extension_guide/HCI/#windows-10","text":"Windows10的某些版本，默认会在页面下方闪烁播放器图标，而不是打开。 可以考虑使用网页打开视频链接，如果你的视频在本地，可以托管给 Adapter，具体而言: 在 Adapter Web UI 里 打开扩展目录 将视频放到 扩展目录 下的 src 目录里 现在这个视频可以使用链接打开了! 它的地址为: https://codelab-adapter.codelab.club:12358/static/1608804837247213.mp4 , 注意，最后的 1608804837247213.mp4 是你的视频名字，最好不用中文。 这是一个示例程序: 魔杖开场视频--使用链接","text_tokens":[",","!","的","-","这是","版本","本地","扩展","可以","一个",":","在","里","程序","魔杖","你","https","。","而言","托管","打开","播放器","如果","mp4","闪烁","不是","给","使用","，","页面","ui","web","现在","12358","club"," ","链接","下方","视频","src","某些","它","中文","开场","/","放到","将","注意","目录","这个","具体","static","1608804837247213","图标","是","名字","考虑","播放",".","为","示例","windows10","codelab","最好","不用","adapter","了","默认","而","网页","地址","下","会","最后"],"title":"Windows 10 用户","title_tokens":["用户","windows","10"," "]},{"location":"extension_guide/HCI/#_2","text":"HCI 插件允许你写 Python 代码， PyAutoGUI 文档中的所有功能你都可以在 Scratch 中使用。 Tips 如果你想使用HCI接管游戏，要注意 press 是瞬间行为（一般无效），一般游戏是在大循环中检测的你是否按下某个按键，所以建议按下一段时间（使用keyDown和keyUp，中间间隔一会儿。）","text_tokens":["按键","是否","的","可以","一般","在","所以","你","行为","建议","pyautogui","文档","。","大","如果","一会儿","插件","会儿","使用","，","（","中间","一段"," ","循环","时间","和","接管","keydown","间隔","注意","代码","无效","python","tips","功能","都","中","想","检测","按下","是","scratch","瞬间","某个","一会","允许","游戏","hci","press","段时间","要","写","所有","一段时间","keyup","）"],"title":"高阶用法","title_tokens":["高阶","用法"]},{"location":"extension_guide/Kano_Wand/","text":"Tutorial ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：Hack Kano Code ¶ 尽管社区有很多针对 Kano 设备的硬件和协议破解（Kano 官方也十分具有 hacker 精神，它们分享了很多 hack 技巧），但我偏好破解 kano 的软件(因其十分优秀，希望基于它的 UI 来编程，而通过 hack 增强它的能力)。 Hack Kano Code ，使其与 CodeLab Adapter 兼容。 目前我对 Mac 和 Windows 的 Kano Code 做了简单 hack，使其能够接入 Adapter，由于是hack过的软件，不便于在互联网分发，如果你需要，请联系我们。 Tips mac系统新版本（13.14之后）安全性提高，如果无法运行hack后的软件(Mac应用已损坏，打不开)，如果可能需要先运行: sudo spctl --master-disable 或者 sudo xattr -rd com.apple.quarantine 空格 软件的路径 Tips 关于魔杖如何与电脑连接参考 官方页面 或者 APP 在 Kano Code 里编程 从 Event 菜单栏中拖出咒语积木；从 Draw 菜单栏中拉出 to adapter 积木，组合出魔法规则: 以上程序的含义是: 当实施图示魔法时，将魔法(id为1)发射到Adapter 。 接下来在 CodeLab Scratch 中对魔法编程（handle）。 步骤 3：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 4：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 5：加载 Kano Code 插件 ¶ 在 Web UI 中点击加载 Kano Code 插件。 开始编程 以上积木的含义: 当魔法(id为1的魔法)触发时，发出猫叫声 Tips 建议把 Scratch 页面和 kano 软件并置在桌面。处于后台的浏览器，可能会休眠(有些系统的默认行为)。 此外，由于蓝牙连接范围有限，挥动魔杖时 尽量别离电脑太远。 Demo ¶ https://adapter.codelab.club/user_guide/gallery/#kano-wand","text_tokens":[",","的","步骤","(","时","安装","应用","wand","上","发射","你","猫叫声","行为","demo","分发","其","接下来","尽管","我","如果","绿色","1","我们","简单","软件","（","精神","club","做","tutorial","说明","破解","浏览器","disable","关于","拉出","社区","这儿","正常","设备","sudo","com","；","拖出","图示","蓝牙","下来","提高","后","scratch","需要","现阶段",".","为","启动","兼容","codelab","中拖出","adapter","了","咒语","规则","新","组合","会","接入","打不开","点击","小圆点","-","其设","基于","可能","以上",":","在","含义","挥动","实施","猫叫","https","event","箭头","ui","处于","硬件","之后","参考","链接","互联网","效果","和",")","菜单栏","太远","增强","/","将","来","便于","圆点","此外","别离","_","官方","从","中","路径","hack","空格","guide","十分","通过","对","chrome","双击","id","并置","联系","支持","当","损坏","陆续","出","联网","呈现","它们","能够","draw","浏览","依赖","已损坏","handle","如何","建议","发出","。","：","很多","打开","3","无法","也","firefox","，","或者","页面","web","希望","to","scratch3","#","中拉出","技巧","连接","接下","开始","分享","13.14","互联","范围","安全性","加载","运行","多","把","系统","如下","xattr","请","kano","有","因","具有","桌面","魔法","code","使","¶","触发","默认","而","）","电脑","阶段","尽量","版本","休眠","里","程序","魔杖","spctl","针对","apple","4","quarantine","叫声","插件","使用","积木","更"," ","由于","后台","它","但","编程","先","安全","master","windows","gallery","与","tips","不","协议","hacker","图中","user","是","到","团队","app","过","有限","5","mac","rd","偏好","不开","scratch3.0","优秀","能力","菜单","所指","目前","有些","最佳"],"title":"Kano Wand","title_tokens":[" ","wand","kano"]},{"location":"extension_guide/Kano_Wand/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/Kano_Wand/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/Kano_Wand/#1hack-kano-code","text":"尽管社区有很多针对 Kano 设备的硬件和协议破解（Kano 官方也十分具有 hacker 精神，它们分享了很多 hack 技巧），但我偏好破解 kano 的软件(因其十分优秀，希望基于它的 UI 来编程，而通过 hack 增强它的能力)。 Hack Kano Code ，使其与 CodeLab Adapter 兼容。 目前我对 Mac 和 Windows 的 Kano Code 做了简单 hack，使其能够接入 Adapter，由于是hack过的软件，不便于在互联网分发，如果你需要，请联系我们。 Tips mac系统新版本（13.14之后）安全性提高，如果无法运行hack后的软件(Mac应用已损坏，打不开)，如果可能需要先运行: sudo spctl --master-disable 或者 sudo xattr -rd com.apple.quarantine 空格 软件的路径 Tips 关于魔杖如何与电脑连接参考 官方页面 或者 APP 在 Kano Code 里编程 从 Event 菜单栏中拖出咒语积木；从 Draw 菜单栏中拉出 to adapter 积木，组合出魔法规则: 以上程序的含义是: 当实施图示魔法时，将魔法(id为1)发射到Adapter 。 接下来在 CodeLab Scratch 中对魔法编程（handle）。","text_tokens":["的","(","时","应用","发射","你","分发","其","接下来","尽管","我","如果","1","我们","简单","软件","（","精神","做","破解","disable","关于","拉出","社区","设备","sudo","com","；","拖出","图示","下来","提高","后","需要","scratch",".","为","兼容","codelab","中拖出","了","adapter","咒语","规则","新","组合","接入","打不开","-","基于","可能","以上",":","在","含义","实施","event","ui","硬件","之后","参考","互联网","和","菜单栏",")","增强","便于","来","将","官方","从","中","路径","hack","空格","对","十分","通过","id","联系","当","损坏","出","联网","它们","能够","draw","handle","已损坏","如何","。","很多","无法","也","，","或者","页面","希望","to","中拉出","技巧","连接","接下","分享","13.14","互联","安全性","运行","系统","xattr","请","kano","有","因","具有","魔法","code","使","而","）","电脑","版本","里","程序","魔杖","spctl","针对","apple","quarantine","积木"," ","由于","它","但","编程","先","安全","master","windows","与","tips","不","协议","hacker","是","到","app","过","mac","rd","偏好","不开","优秀","能力","菜单","目前"],"title":"步骤 1：Hack Kano Code","title_tokens":["1","步骤","code"," ","hack","：","kano"]},{"location":"extension_guide/Kano_Wand/#3-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 3：打开 Codelab Adapter","title_tokens":["3","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/Kano_Wand/#4-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 4：打开 Codelab Scratch3","title_tokens":["步骤","codelab","scratch3"," ","4","：","打开"]},{"location":"extension_guide/Kano_Wand/#5-kano-code","text":"在 Web UI 中点击加载 Kano Code 插件。 开始编程 以上积木的含义: 当魔法(id为1的魔法)触发时，发出猫叫声 Tips 建议把 Scratch 页面和 kano 软件并置在桌面。处于后台的浏览器，可能会休眠(有些系统的默认行为)。 此外，由于蓝牙连接范围有限，挥动魔杖时 尽量别离电脑太远。","text_tokens":["的","(","时","以上","可能","休眠",":","在","含义","浏览","挥动","猫叫","魔杖","猫叫声","建议","行为","发出","。","叫声","1","ui","插件","有些","，","积木","页面","web","软件","处于"," ","由于","连接","后台","和",")","编程","开始","浏览器","太远","范围","加载","tips","此外","别离","蓝牙","中","把","系统","scratch","kano","桌面","为","魔法","code","有限","触发","id","并置","默认","当","会","点击","尽量","电脑"],"title":"步骤 5：加载 Kano Code 插件","title_tokens":["插件","步骤","code","加载","5"," ","：","kano"]},{"location":"extension_guide/Kano_Wand/#demo","text":"https://adapter.codelab.club/user_guide/gallery/#kano-wand","text_tokens":[".","-","codelab","/","adapter","gallery",":","wand","_","#","https","club","guide","user","kano"],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/MQTT_Broker/","text":"提醒 基于 hbmqtt ，该项目作者似乎不维护了， 目前存在一个bug 可能无法工作。 可以使用 CodeLab 公共的mqtt broker: mqtt://guest:test@iot.codelab.club . 建议到插件市场里下载最新插件。 插件说明 ¶ 使用方式: 到 插件市场 下载插件, 搜索 mqtt 插件类型: Adapter Extension 插件源码: extension_mqtt_broker.py 使用场景 ¶ extension_mqtt_broker.py 插件允许你轻松在本地启动一个轻量级 MQTT Broker。 一个典型的使用场景是将各类支持 mqtt client 的硬件，接入 Adapter（当然你需要写一个 extension, 我们已经构建了一个: MQTT_adapter ），这样方便你将 esp32、esp8266、掌控板等设备接入 Adapter 。 Demo ¶ hbmqtt_pub --url mqtt://127.0.0.1 -t /test -m some_data hbmqtt_sub --url mqtt://127.0.0.1 -t /test 当然你可以使用任何mqtt client 高性能 ¶ 基于高性能的 hbmqtt 。 基于协程的并发能力，足以让你在树莓派上支撑起整个学校的物联网。 进阶 ¶ 你可以修改 broker 配置项，为其增加 auth 之类的功能, 详情参考 hbmqtt 文档。 参考 ¶ hbmqtt","text_tokens":[",","的","可以","一个","最新","上","你","data","典型","demo","其","some","我们","（","club","说明","设备","功能","需要","t",".","启动","公共","为","codelab","了","adapter","让你在","性能","接入","已经","-","本地","基于","可能","py",":","在","之类","mqtt","物","市场","学校","hbmqtt","下载","@","硬件","extension","派","pub","参考","bug","0.1","esp32","搜索","板","m","/","任何","将","作者","存在","guest","_","增加","项","足以","、","当然","整个","配置","支持","提醒","进阶","场景","esp8266","工作","联网","方式","协程","建议","。","文档","并发","无法","树莓","，","构建","iot","等","该","允许","高性","¶","似乎","轻松","高性能","127.0","轻量","写","client","项目","url","）","类型","轻量级","里","方便","详情","插件","起","使用"," ","维护","量级","sub","掌控","不","修改","各类","到","源码","是","auth","支撑","能力","broker","目前","test","这样"],"title":"MQTT Broker","title_tokens":["mqtt"," ","broker"]},{"location":"extension_guide/MQTT_Broker/#_1","text":"使用方式: 到 插件市场 下载插件, 搜索 mqtt 插件类型: Adapter Extension 插件源码: extension_mqtt_broker.py","text_tokens":[",","方式","py",":","mqtt","市场","插件","使用","下载","extension"," ","搜索","_","源码","到",".","adapter","broker","类型"],"title":"插件说明","title_tokens":["插件","说明"]},{"location":"extension_guide/MQTT_Broker/#_2","text":"extension_mqtt_broker.py 插件允许你轻松在本地启动一个轻量级 MQTT Broker。 一个典型的使用场景是将各类支持 mqtt client 的硬件，接入 Adapter（当然你需要写一个 extension, 我们已经构建了一个: MQTT_adapter ），这样方便你将 esp32、esp8266、掌控板等设备接入 Adapter 。","text_tokens":[",","的","本地","py","一个",":","在","mqtt","你","方便","典型","。","插件","我们","使用","，","硬件","extension","（","client","已经"," ","构建","esp32","板","量级","设备","将","_","掌控","等","各类","场景","是","需要",".","允许","启动","、","当然","adapter","了","轻松","支持","轻量","写","broker","esp8266","接入","）","这样","轻量级"],"title":"使用场景","title_tokens":["使用","场景"]},{"location":"extension_guide/MQTT_Broker/#demo","text":"hbmqtt_pub --url mqtt://127.0.0.1 -t /test -m some_data hbmqtt_sub --url mqtt://127.0.0.1 -t /test 当然你可以使用任何mqtt client","text_tokens":["-","可以",":","mqtt","你","data","hbmqtt","some","使用","pub"," ","0.1","m","/","sub","任何","_","t",".","当然","127.0","client","url","test"],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/MQTT_Broker/#_3","text":"基于高性能的 hbmqtt 。 基于协程的并发能力，足以让你在树莓派上支撑起整个学校的物联网。","text_tokens":["联网","的","协程","基于","上","物","学校","。","hbmqtt","并发","起","树莓","，","派"," ","足以","高性","整个","支撑","让你在","高性能","性能","能力"],"title":"高性能","title_tokens":["性能","高性","高性能"]},{"location":"extension_guide/MQTT_Broker/#_4","text":"你可以修改 broker 配置项，为其增加 auth 之类的功能, 详情参考 hbmqtt 文档。","text_tokens":[",","的","可以","之类","你","文档","其","hbmqtt","。","详情","，","参考"," ","功能","修改","增加","项","为","auth","配置","broker"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/MQTT_Broker/#_5","text":"hbmqtt","text_tokens":["hbmqtt"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/MQTT_adapter/","text":"Tutorial ¶ 插件说明 ¶ 使用方式: 到 插件市场 下载插件, 搜索 mqtt 插件类型: Adapter Extension 插件源码: extension_mqtt_adapter.py 使用场景 ¶ extension_mqtt_adapter.py 插件桥接 mqtt 与 Scratch。 原理很简单，它将来自mqtt的消息(mqtt topic: to_scratch )，转发到 eim 中，将eim中的消息转发到mqtt(mqtt topic: from_scratch ). （下文有例子） 提醒 你需要首先选择一个mqtt broker， extension_mqtt_adapter.py 假设你在本地运行了一个mqtt broker(mqtt 127.0.0.1 1883)。你可以使用任何mqtt broker。在 Adapter 3.2 中，将自带一个轻量级高性能的 mqtt broker: MQTT Broker 将消息从mqtt client 发往Scratch: hbmqtt_pub --url mqtt://127.0.0.1 -t to_scratch -m \"mqtt message\" 当然你可以使用任何 mqtt client代替 hbmqtt_pub Scratch -> mqtt ¶ 将消息从Scratch 发往 mqtt client 先启动 mqtt client 的消息订阅。当然你可以使用任何 mqtt client代替 hbmqtt_sub hbmqtt_sub --url mqtt://127.0.0.1 -t from_scratch Scratch 相关源码 ¶ Scratch-mqtt-adapter","text_tokens":[",","的","(","可以","一个","你","简单",">","（","说明","tutorial","往","转发","相关","发","scratch","需要","发往","订阅","t",".","启动","adapter","了","性能","-","本地","py",":","下文","在","代替","mqtt","市场","\"","hbmqtt","下载","来自","extension","pub","0.1",")","搜索","m","/","任何","将","_","from","中","从","首先","当然","3.2","提醒","eim","场景","假设","方式","topic","例子","。","，","to","message","运行","有","很","1883","高性","¶","高性能","127.0","轻量","client","url","）","类型","轻量级","插件","使用"," ","桥接","它","先","量级","sub","与","自带","源码","到","消息","原理","选择","broker"],"title":"MQTT Adapter","title_tokens":["mqtt"," ","adapter"]},{"location":"extension_guide/MQTT_adapter/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/MQTT_adapter/#_1","text":"使用方式: 到 插件市场 下载插件, 搜索 mqtt 插件类型: Adapter Extension 插件源码: extension_mqtt_adapter.py","text_tokens":[",",".","搜索","插件","使用","方式","下载","adapter","py",":","extension","_","mqtt"," ","市场","源码","到","类型"],"title":"插件说明","title_tokens":["插件","说明"]},{"location":"extension_guide/MQTT_adapter/#_2","text":"extension_mqtt_adapter.py 插件桥接 mqtt 与 Scratch。 原理很简单，它将来自mqtt的消息(mqtt topic: to_scratch )，转发到 eim 中，将eim中的消息转发到mqtt(mqtt topic: from_scratch ). （下文有例子） 提醒 你需要首先选择一个mqtt broker， extension_mqtt_adapter.py 假设你在本地运行了一个mqtt broker(mqtt 127.0.0.1 1883)。你可以使用任何mqtt broker。在 Adapter 3.2 中，将自带一个轻量级高性能的 mqtt broker: MQTT Broker 将消息从mqtt client 发往Scratch: hbmqtt_pub --url mqtt://127.0.0.1 -t to_scratch -m \"mqtt message\" 当然你可以使用任何 mqtt client代替 hbmqtt_pub","text_tokens":["假设","的","-","(","本地","py","一个",":","下文","topic","在","可以","代替","mqtt","你","例子","\"","。","hbmqtt","插件","简单","使用","，","来自","extension","（","client","to","pub"," ","桥接","0.1","它",")","message","量级","m","/","任何","将","与","转发","运行","_","from","自带","broker","中","从","到","scratch","需要","发往","有","很",".","t","1883","高性","首先","adapter","消息","了","3.2","当然","高性能","127.0","原理","提醒","轻量","eim","选择","性能","url","）","轻量级"],"title":"使用场景","title_tokens":["使用","场景"]},{"location":"extension_guide/MQTT_adapter/#scratch-mqtt","text":"将消息从Scratch 发往 mqtt client 先启动 mqtt client 的消息订阅。当然你可以使用任何 mqtt client代替 hbmqtt_sub hbmqtt_sub --url mqtt://127.0.0.1 -t from_scratch","text_tokens":["的","-","可以",":","代替","mqtt","你","。","hbmqtt","使用"," ","0.1","往","先","sub","任何","/","将","_","from","从","发","scratch","订阅","t",".","启动","当然","消息","127.0","client","url"],"title":"Scratch -&gt; mqtt","title_tokens":[";","-","&","mqtt"," ","gt","scratch"]},{"location":"extension_guide/MQTT_adapter/#scratch","text":"Scratch-mqtt-adapter","text_tokens":["-","mqtt","scratch","adapter"],"title":"Scratch 相关源码","title_tokens":["相关"," ","scratch","源码"]},{"location":"extension_guide/NetworkZero/","text":"Tutorial ¶ NetworkZero 的目标是让局域网通信变得简单。 基于 networkzero 包装，保留与其一致的接口 注意 如果你无法在两台局域网电脑之间通信，可能需要关闭电脑的系统防火墙 demo ¶ 收信人: 地址 (地址名)，并 接收 来自这个地址的消息。 寄信人: 往 目标地址 发送 信息 允许任何人公布通信地址，所以可以轻松构建网状结构。 典型应用场景 ¶ 局域网联机游戏 局域网聊天 多人联机控制机器人 与Python程序(诸如树莓派机器人)互动 可与 基于 networkzero 的程序互操作。","text_tokens":["的","接收","(","可以","应用","所以","目标","你","多人","demo","典型","如果","防火墙","简单","之间","通信地址","tutorial","往","网状","结构","需要","通信","保留","火墙","机器","让","基于","可能","接口","在","机器人",":","局域","与其","两台","来自","派","诸如","寄信",")","任何","注意","python","局域网","寄信人","游戏","发送","场景","并","包装","。","防火","公布","networkzero","无法","树莓","，","构建","可","一致","任何人","网状结构","系统","允许","联机","变得","¶","轻松","电脑","互操作","收信","程序","信息","关闭","互动","操作","名","聊天"," ","收信人","与","这个","是","何人","消息","地址","控制"],"title":"NetworkZero","title_tokens":["networkzero"]},{"location":"extension_guide/NetworkZero/#tutorial","text":"NetworkZero 的目标是让局域网通信变得简单。 基于 networkzero 包装，保留与其一致的接口 注意 如果你无法在两台局域网电脑之间通信，可能需要关闭电脑的系统防火墙","text_tokens":["让","的","基于","可能","接口","在","目标","包装","局域","你","。","关闭","防火","与其","如果","两台","防火墙","networkzero","无法","简单","，","之间"," ","一致","注意","系统","局域网","是","需要","通信","变得","保留","火墙","电脑"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/NetworkZero/#demo","text":"收信人: 地址 (地址名)，并 接收 来自这个地址的消息。 寄信人: 往 目标地址 发送 信息 允许任何人公布通信地址，所以可以轻松构建网状结构。","text_tokens":["的","接收","(","可以","并",":","收信","所以","目标","信息","。","公布","名","，","来自"," ","通信地址","构建","寄信",")","收信人","往","网状","任何人","网状结构","任何","结构","这个","寄信人","通信","允许","何人","消息","轻松","地址","发送"],"title":"demo","title_tokens":["demo"]},{"location":"extension_guide/NetworkZero/#_1","text":"局域网联机游戏 局域网聊天 多人联机控制机器人 与Python程序(诸如树莓派机器人)互动 可与 基于 networkzero 的程序互操作。","text_tokens":["的","(","基于","互操作","机器人","程序","局域","多人","互动","。","操作","networkzero","树莓","聊天","派"," ","诸如",")","可","与","python","局域网","联机","游戏","机器","控制"],"title":"典型应用场景","title_tokens":["应用","场景","典型"]},{"location":"extension_guide/Pando/","text":"Pando ¶ 文档参考: 当遇到 Scratch3-Codelab，Pando 觉醒了！","text_tokens":["-","codelab","，","遇到","¶","觉醒",":","了","scratch3","参考"," ","当","pando","！","文档"],"title":"Pando Robot(正在迁移中)","title_tokens":["正在","robot","(","迁移"," ","中","pando",")"]},{"location":"extension_guide/Pando/#pando","text":"文档参考: 当遇到 Scratch3-Codelab，Pando 觉醒了！","text_tokens":["-","codelab","，","遇到","觉醒","了",":","scratch3","参考"," ","当","pando","！","文档"],"title":"Pando","title_tokens":["pando"]},{"location":"extension_guide/ROS/","text":"ROS ¶ 步骤 1：打开 CodeLab Scratch ¶ 下载 CodeLab Scratch Desktop（离线版） ，并运行它。 ps: 要求 CodeLab Scratch Desktop >= 1.2.1 步骤 2：运行 ROS ¶ 运行 ROS。 步骤 3：运行桥接程序 ¶ 运行桥接程序。 步骤 4：开始使用 ¶ 选择 scratch3 中的 ROS 插件： 开始使用。","text_tokens":["的","步骤","并",":","版","1.2","程序","4","。","：","打开","要求","1","3","插件","下载","，","使用",">","=","（","scratch3"," ","桥接","它","开始","离线","运行","中","ros","scratch",".","codelab","ps","¶","desktop","2","选择","）"],"title":"ROS(正在迁移中)","title_tokens":["正在","(","迁移","中","ros",")"]},{"location":"extension_guide/ROS/#ros","text":"","text_tokens":[],"title":"ROS","title_tokens":["ros"]},{"location":"extension_guide/ROS/#1-codelab-scratch","text":"下载 CodeLab Scratch Desktop（离线版） ，并运行它。 ps: 要求 CodeLab Scratch Desktop >= 1.2.1","text_tokens":["并",":","版","1.2","。","要求","1","下载","，",">","=","（"," ","它","离线","运行","scratch",".","codelab","ps","desktop","）"],"title":"步骤 1：打开 CodeLab Scratch","title_tokens":["1","步骤","codelab"," ","：","scratch","打开"]},{"location":"extension_guide/ROS/#2-ros","text":"运行 ROS。","text_tokens":["。"," ","运行","ros"],"title":"步骤 2：运行 ROS","title_tokens":["步骤","2","运行"," ","ros","："]},{"location":"extension_guide/ROS/#3","text":"运行桥接程序。","text_tokens":["。","桥接","程序","运行"],"title":"步骤 3：运行桥接程序","title_tokens":["3","步骤","程序","运行"," ","桥接","："]},{"location":"extension_guide/ROS/#4","text":"选择 scratch3 中的 ROS 插件： 开始使用。","text_tokens":["开始","的","插件","使用","scratch3"," ","中","选择","ros","。","："],"title":"步骤 4：开始使用","title_tokens":["开始","步骤","使用"," ","4","："]},{"location":"extension_guide/RoboMaster/","text":"RoboMaster ¶ RoboMaster EP 提醒 目前只支持RoboMaster EP(暂不支持S1)，受限于大疆的开放接口: RoboMaster SDK 新手入门 - EP 篇 Tutorial ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：将 RoboMaster 接入局域网里 ¶ 开启 RoboMaster ， 将其接入局域网里 步骤 4：hello world ¶ 现在让我们利用 Scratch3 控制 RoboMaster: 使用键盘的上下左右/空格来控制机器人移动和发射水弹。 更多 ¶ 协议细节参考 robomaster-dev 协议内容 提醒 如果你希望做一些更复杂的事，建议直接使用社区里的 Python SDK与 设备交互，之后使用 Adapter Node 将其接入Adapter环境中。","text_tokens":[",","的","步骤","(","安装","上","发射","你","其","如果","绿色","1","现在","我们","利用","做","tutorial","说明","新手","浏览器","正常","这儿","社区","sdk","设备","scratch","现阶段",".","为","启动","codelab","键盘","adapter","机器","点击","接入","小圆点","让","-","其设","内容","接口",":","在","机器人","局域","开放","入门","箭头","ui","水弹","之后","篇","参考","链接","大疆","效果","和",")","/","world","将","来","圆点","python","官方","中","局域网","空格","dev","chrome","双击","2","复杂","只","支持","提醒","陆续","呈现","浏览","依赖","建议","ep","。","：","打开","3","firefox","，","或者","页面","web","希望","hello","scratch3","细节","连接","上下","直接","多","如下","新手入门","¶","默认","交互","限于","阶段","版本","robomaster","s1","里","4","受限","使用","更","node"," ","事","左右","暂","与","受限于","不","一些","协议","图中","团队","环境","上下左右","开启","scratch3.0","所指","目前","最佳","控制","移动"],"title":"RoboMaster","title_tokens":["robomaster"]},{"location":"extension_guide/RoboMaster/#robomaster","text":"RoboMaster EP 提醒 目前只支持RoboMaster EP(暂不支持S1)，受限于大疆的开放接口: RoboMaster SDK 新手入门 - EP 篇","text_tokens":["的","-","(","robomaster","s1","接口",":","ep","开放","入门","受限","，","篇"," ","大疆",")","新手","sdk","暂","受限于","不","新手入门","只","支持","提醒","限于","目前"],"title":"RoboMaster","title_tokens":["robomaster"]},{"location":"extension_guide/RoboMaster/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/RoboMaster/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/RoboMaster/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/RoboMaster/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"extension_guide/RoboMaster/#3-robomaster","text":"开启 RoboMaster ， 将其接入局域网里","text_tokens":["开启","，","将","robomaster","里","局域"," ","局域网","其","接入"],"title":"步骤 3：将 RoboMaster 接入局域网里","title_tokens":["3","步骤","将","robomaster","里","局域"," ","局域网","：","接入"]},{"location":"extension_guide/RoboMaster/#4hello-world","text":"现在让我们利用 Scratch3 控制 RoboMaster: 使用键盘的上下左右/空格来控制机器人移动和发射水弹。","text_tokens":["让","的","robomaster",":","机器人","发射","。","现在","我们","利用","使用","水弹","scratch3"," ","和","上下","左右","/","来","空格","上下左右","键盘","机器","控制","移动"],"title":"步骤 4：hello world","title_tokens":["步骤","world","hello"," ","4","："]},{"location":"extension_guide/RoboMaster/#_2","text":"协议细节参考 robomaster-dev 协议内容 提醒 如果你希望做一些更复杂的事，建议直接使用社区里的 Python SDK与 设备交互，之后使用 Adapter Node 将其接入Adapter环境中。","text_tokens":["的","-","内容","robomaster","里","你","建议","。","其","如果","使用","，","更","之后","node","希望","参考","细节"," ","事","做","直接","社区","sdk","设备","将","与","python","一些","协议","中","dev","环境","adapter","复杂","交互","提醒","接入"],"title":"更多","title_tokens":["更","多"]},{"location":"extension_guide/SimplePyboard/","text":"Tutorial ¶ 支持大多数的 pyboard (烧录 micropython 的 board)， 诸如 esp32、esp8266、micro:bit、 掌控板、bpi:bit... 采用的是 micropyhton 的 REPL 机制（串口）","text_tokens":["repl","的","烧录","(",":","机制","micropyhton","micro","大多","，","（","采用"," ","tutorial","诸如","bpi",")","bit","esp32","板","pyboard","掌控","串口","大多数","是","board","micropython","、","¶","...","支持","esp8266","多数","）"],"title":"SimplePyboard","title_tokens":["simplepyboard"]},{"location":"extension_guide/SimplePyboard/#tutorial","text":"支持大多数的 pyboard (烧录 micropython 的 board)， 诸如 esp32、esp8266、micro:bit、 掌控板、bpi:bit... 采用的是 micropyhton 的 REPL 机制（串口）","text_tokens":["repl","的","烧录","(",":","机制","micropyhton","micro","大多","，","（","采用"," ","诸如","bpi",")","bit","esp32","板","pyboard","掌控","串口","大多数","是","board","micropython","、","...","支持","esp8266","多数","）"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/Squeak/","text":"Squeak/Smalltalk ¶ 介绍 ¶ Squeak 是 Smalltalk 的现代实现. 有几位 Smalltalk-80 的实现者(他们之前在施乐实验室创造了 Smalltalk)都参与到了 Squeak 中，包括 Alan Kay 和 Daniel Ingall，这个项目依然在持续演进，他们抱有跟今天计算机整个领域不同的愿景。 MIT媒体实验室推动的OLPC计划，采用Squeak作为开发环境。 Etoys、Croquet、第一代的Scratch都是用 Squeak 实现的。 关于 Squeak 入门，可参考 Smalltalk 入门导览 接入 Adapter ¶ 有很多种方式将 Squeak 和 Adapter连在一起，诸如HTTP、Websocket、ZeroMQ，系统调用(Adapter python client提供系统命令)，你也可以自己写一个Adapter插件来连接两者。 目前我最喜欢的一种方式是使用 OSC , 由于最新的Adapter内置了 OSC server，所以我们可以轻松将Squeak用作 osc cleint， 消息流向是 Squeak->Adapter 。 demo ¶ 在Squeak中, 下载 OSC : OSC-SimonHolland , 之后拖到 Squeak 桌面，加载使用即可。 ( OSCMessage for: { '/eim/osc' . 1 }) sendTo: # [ 127 0 0 1 ] port: 12361 . \"turn right\" ( OSCMessage for: { '/eim/osc' . 0 }) sendTo: # [ 127 0 0 1 ] port: 12361 . \"forward\" ( OSCMessage for: { '/eim/osc' . -1 }) sendTo: # [ 127 0 0 1 ] port: 12361 . \"turn right\" 以上的代码将控制Scratch里的飞行器: squeak-scratch-demo 进阶 ¶ 你也可以在Squeak中运行 OSC server，此时消息流向是 Adapter -> Squeak 以上代码也可以运行在其他smalltalk方言中，诸如 Pharo。 参考 ¶ squeak osc","text_tokens":[",","croquet","飞行","的","算机","(","osc","可以","一个","所以","最新","你","cleint","开发","demo","内置","今天","127","我","1","我们",">","最","用作","simonholland","port","'","连在一起","用","跟","一起","kay","关于","websocket","forward","多种","媒体","]","scratch","他们",".","作为","adapter","介绍","了","调用","for","接入","领域","即可","-","以上",":","实现","在","\"","计划","入门","实验","几位","下载","12361","之后","一种","参考","第一","turn","诸如","和",")","alan","/","此时","squeak","将","自己","来","python","飞行器","中","oscmessage","计算机","server","、","导览","整个","一代","进阶","eim","olpc","right","方式","}","愿景","施乐","。","0","也","实验室","，","#","流向","不同","连接","创造","可","80","加载","运行","参与","推动","方言","系统","命令","有","很","桌面","¶","依然","轻松","其他","现代","写","client","项目","{","提供","里","之前","[","zeromq","喜欢","插件","使用","smalltalk","mit","连在","采用","者","两者","持续"," ","由于","http","etoys","代码","sendto","这个","都","ingall","演进","抱","是","到","环境","系统命令","pharo","计算","包括","消息","第一代","拖","daniel","目前","控制"],"title":"Squeak/Smalltalk","title_tokens":["smalltalk","squeak","/"]},{"location":"extension_guide/Squeak/#squeaksmalltalk","text":"","text_tokens":[],"title":"Squeak/Smalltalk","title_tokens":["smalltalk","squeak","/"]},{"location":"extension_guide/Squeak/#_1","text":"Squeak 是 Smalltalk 的现代实现. 有几位 Smalltalk-80 的实现者(他们之前在施乐实验室创造了 Smalltalk)都参与到了 Squeak 中，包括 Alan Kay 和 Daniel Ingall，这个项目依然在持续演进，他们抱有跟今天计算机整个领域不同的愿景。 MIT媒体实验室推动的OLPC计划，采用Squeak作为开发环境。 Etoys、Croquet、第一代的Scratch都是用 Squeak 实现的。 关于 Squeak 入门，可参考 Smalltalk 入门导览","text_tokens":["croquet","的","-","算机","(","实现","在","施乐","愿景","开发","。","计划","入门","之前","今天","实验","几位","实验室","smalltalk","，","mit","采用","者","参考","持续"," ","第一","不同","和","创造",")","用","跟","可","80","kay","关于","alan","olpc","etoys","squeak","这个","参与","媒体","都","推动","中","ingall","演进","抱","计算机","是","到","环境","scratch","他们","有",".","、","计算","了","包括","依然","整个","作为","第一代","导览","一代","现代","daniel","项目","领域"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/Squeak/#adapter","text":"有很多种方式将 Squeak 和 Adapter连在一起，诸如HTTP、Websocket、ZeroMQ，系统调用(Adapter python client提供系统命令)，你也可以自己写一个Adapter插件来连接两者。 目前我最喜欢的一种方式是使用 OSC , 由于最新的Adapter内置了 OSC server，所以我们可以轻松将Squeak用作 osc cleint， 消息流向是 Squeak->Adapter 。","text_tokens":[",","的","-","提供","方式","(","osc","可以","一个","所以","最新","你","cleint","。","内置","我","zeromq","喜欢","也","插件","使用","，","我们",">","连在","两者","一种","最"," ","用作","流向","诸如","连接","由于","和",")","连在一起","一起","http","websocket","将","squeak","自己","来","多种","python","系统","是","命令","有","很","server","系统命令","、","adapter","调用","了","轻松","消息","写","client","目前"],"title":"接入 Adapter","title_tokens":["adapter","接入"," "]},{"location":"extension_guide/Squeak/#demo","text":"在Squeak中, 下载 OSC : OSC-SimonHolland , 之后拖到 Squeak 桌面，加载使用即可。 ( OSCMessage for: { '/eim/osc' . 1 }) sendTo: # [ 127 0 0 1 ] port: 12361 . \"turn right\" ( OSCMessage for: { '/eim/osc' . 0 }) sendTo: # [ 127 0 0 1 ] port: 12361 . \"forward\" ( OSCMessage for: { '/eim/osc' . -1 }) sendTo: # [ 127 0 0 1 ] port: 12361 . \"turn right\" 以上的代码将控制Scratch里的飞行器: squeak-scratch-demo","text_tokens":[",","即可","飞行","的","-","(","}","以上",":","在","里","控制","\"","。","demo","0","127","[","1","下载","，","使用","12361","之后","#","simonholland"," ","port","turn","'",")","/","forward","加载","squeak","将","代码","sendto","飞行器","中","oscmessage","]","到","scratch","桌面",".","for","拖","eim","osc","{","right"],"title":"demo","title_tokens":["demo"]},{"location":"extension_guide/Squeak/#_2","text":"你也可以在Squeak中运行 OSC server，此时消息流向是 Adapter -> Squeak 以上代码也可以运行在其他smalltalk方言中，诸如 Pharo。","text_tokens":["-","以上","可以","在","你","。","也","，","smalltalk",">"," ","流向","诸如","此时","squeak","代码","运行","中","方言","是","server","pharo","adapter","消息","其他","osc"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/Squeak/#_3","text":"squeak osc","text_tokens":["osc","squeak"," "],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/Wekinator/","text":"Wekinator ¶ Wekinator 允许任何人使用机器学习来构建新的乐器、手势游戏控制器、计算机视觉或计算机听觉系统等。 Wekinator允许用户通过演示人类的动作和计算机的反应来构建新的交互系统，无需编写代码。 你可以使用 OSC 插件，与 Wekinator 互操作。 提醒 Teachable Machine 可视为Wekinator的后继者，在功能、可理解性和易用性上都做得更好，推荐大家使用。","text_tokens":["的","算机","用户","动作","乐器","可以","互操作","在","上","你","易用性","。","或","性","手势","操作","插件","teachable","使用","，","视觉","理解","得","推荐","大家","人类","无需","视为","wekinator"," ","做","构建","和","可","编写","任何人","任何","更好","来","控制器","代码","与","易用","反应","功能","等","后继者","都","系统","计算机","通过","允许","何人","演示","、","游戏","机器","¶","计算","听觉","交互","后继","学习","提醒","machine","新","osc","控制"],"title":"Wekinator","title_tokens":["wekinator"]},{"location":"extension_guide/Wekinator/#wekinator","text":"Wekinator 允许任何人使用机器学习来构建新的乐器、手势游戏控制器、计算机视觉或计算机听觉系统等。 Wekinator允许用户通过演示人类的动作和计算机的反应来构建新的交互系统，无需编写代码。 你可以使用 OSC 插件，与 Wekinator 互操作。 提醒 Teachable Machine 可视为Wekinator的后继者，在功能、可理解性和易用性上都做得更好，推荐大家使用。","text_tokens":["的","算机","用户","动作","乐器","可以","互操作","在","上","你","易用性","。","或","性","手势","操作","插件","teachable","使用","，","视觉","理解","得","推荐","大家","人类","无需","视为","wekinator"," ","做","构建","和","可","编写","任何人","任何","更好","来","控制器","代码","与","易用","反应","功能","等","后继者","都","系统","计算机","通过","允许","何人","演示","、","游戏","机器","计算","听觉","交互","后继","学习","提醒","machine","新","osc","控制"],"title":"Wekinator","title_tokens":["wekinator"]},{"location":"extension_guide/alphamini/","text":"悟空机器人(教育版) ¶ 使用说明 ¶ 目前该插件并未内置到 Adapter 中。 我们目前将插件构建为 Adapter Node ，可以在Adapter外部以普通Python文件运行，一旦运行起来，与普通Adapter插件是一样的，能够与Adapter体系的所有事物交互。 Python环境 ¶ 首先你本地需要有 Python 环境（ Python>=3.6 ） 你可以到 Python 官方 下载，也可以使用 CodeLab放在 国内的版本(Python3.7) 提醒 Mac 用户和 Linux 本地很可能内置了 Python3 安装依赖 ¶ pip install alphamini codelab_adapter_client --upgrade 开始！ ¶ 步骤 1：打开 CodeLab Scratch ¶ 运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。 步骤 1：运行 node_alphamini.py ¶ 将 node_alphamini.py 插件下载到本地（随便放在一个文件夹里），在命令行中进入到这个文件夹，使用 python node_alphamini.py 运行它。 步骤 2：为 悟空机器人 配网 ¶ 将 悟空机器人 连上网络。（操作细节可以参考 悟空机器人 说明书） 步骤 3: 编程 ¶ 选择 scratch3 中的 EIM 插件. alphamini-demo2 以上 Demo 运行结果为: 进阶 ¶ 更多API参考文档: mini-python-sdk 悟空的 内置行为 ¶ 内置舞蹈 ¶ robot . play_behavior ( name = 'custom_0035' ) # 生日快乐 内置动作 ¶ robot . play_action ( action_name = '010' ) # 打招呼 内置表情 ¶ robot . play_expression ( express_name = 'codemao13' ) # 疑问 提醒 悟空内部运行一个安卓系统，带有内嵌 Python 环境 FAQ ¶ 有些网络无法扫描到悟空 ¶ 似乎和局域网内的设备发现机制（mdns？）有关。 通过以下脚本排查问题。如果以下脚本无法扫描到设备，请联系优必选客服人员。 注意将 00447 替换成你自己的设备号 # pip install alphamini # https://github.com/marklogg/mini_demo/blob/master/test/test_connect.py import asyncio import logging import mini.mini_sdk as MiniSdk from mini.dns.dns_browser import WiFiDevice \"\"\"根据机器人序列号后缀搜索设备 搜索指定序列号(在机器人屁股后面)的机器人, 可以只输入序列号尾部字符即可,长度任意, 建议5个字符以上可以准确匹配 \"\"\" device_name = \"00447\" async def test_get_device_by_name (): ''' 10秒超时 Returns: WiFiDevice: 包含机器人名称,ip,port等信息 ''' result : WiFiDevice = await MiniSdk . get_device_by_name ( device_name , 10 ) print ( f \"test_get_device_by_name result:{result}\" ) return result async def main (): device : WiFiDevice = await test_get_device_by_name () if device : print ( \"已发现设备\" ) else : print ( \"无法发现设备\" ) if __name__ == '__main__' : asyncio . run ( main ())","text_tokens":[",","必选","的","步骤","(","用户","可以","安装","一个","动作","替换","看到","上","内","你","后缀","并未","行为","输入","超时","demo","test","内置","如果","pip","绿色","1","f","我们",">","配网","（","returns","port","事物","说明","async","'","问题","说明书","正常","as","print","sdk","设备","内部","com","屁股","import","长度","内嵌","else","平台","需要","scratch",".","为","随便","codelab","adapter","了","有关","3.6","一样","minisdk","以","所有","机器","悟空","即可","-","本地","一旦","以上","可能","py",":","在","机器人","版","安卓","机制","序列","局域","https","带有","后面","\"","install","根据","run","生日","expression","by","下载","发现","ip","参考","成功","文件","和","任意",")","get","普通","搜索","舞蹈","网络","__","/","将","注意","自己","招呼","python","0035","_","mini","codemao13","换成","from","中","官方","play","局域网","mdns","号","通过","件夹","首先","linux","2","dns","联系","只","blob","提醒","进阶","eim","express","名称","能够","}","人员","依赖","外部","秒","建议","个字符","。","：","文档","教育","体系","打开","优","3","无法","也","，","faq","logging","指定","scratch3","#","细节","构建","确保","连接","action","放在","脚本","序列号","匹配","开始","起来","打招呼","生日快乐","？","运行","进入","多","await","以下","等","！","系统","该","010","快乐","命令","python3","疑问","有","很","请","github","custom","¶","尾部","似乎","交互","alphamini","在线","国内","指示","字符","api","client","main","已","）","upgrade","{","代表","版本","behavior","排查","marklogg","文件夹","里","结果","10","connect","信息","00447","指示灯","操作","插件","使用","python3.7","=","node","更","准确"," ","它","显示","编程","def","return","命令行","master","与","这个","wifidevice","连","adapte","到","是","环境","替换成","device","if","result","robot","扫描","name","mac","表情","5","asyncio","demo2","选择","browser","目前","有些","客服","包含"],"title":"悟空机器人(教育版)","title_tokens":["悟空","(","机器人","版","机器",")","教育"]},{"location":"extension_guide/alphamini/#_1","text":"","text_tokens":[],"title":"悟空机器人(教育版)","title_tokens":["悟空","(","机器人","版","机器",")","教育"]},{"location":"extension_guide/alphamini/#_2","text":"目前该插件并未内置到 Adapter 中。 我们目前将插件构建为 Adapter Node ，可以在Adapter外部以普通Python文件运行，一旦运行起来，与普通Adapter插件是一样的，能够与Adapter体系的所有事物交互。","text_tokens":["的","能够","一旦","可以","在","外部","并未","。","内置","体系","插件","我们","，","node"," ","事物","文件","构建","起来","普通","将","与","python","运行","中","该","到","是","为","adapter","一样","交互","以","所有","目前"],"title":"使用说明","title_tokens":["说明","使用"]},{"location":"extension_guide/alphamini/#python","text":"首先你本地需要有 Python 环境（ Python>=3.6 ） 你可以到 Python 官方 下载，也可以使用 CodeLab放在 国内的版本(Python3.7) 提醒 Mac 用户和 Linux 本地很可能内置了 Python3","text_tokens":["的","本地","版本","(","可以","用户","可能","你","内置","也","下载","，","使用",">","=","（","python3.7"," ","和","放在",")","python","官方","到","需要","环境","python3","有","很","codelab","首先","linux","了","mac","3.6","国内","提醒","）"],"title":"Python环境","title_tokens":["环境","python"]},{"location":"extension_guide/alphamini/#_3","text":"pip install alphamini codelab_adapter_client --upgrade","text_tokens":["pip","-","codelab","adapter","_","alphamini"," ","client","install","upgrade"],"title":"安装依赖","title_tokens":["安装","依赖"]},{"location":"extension_guide/alphamini/#_4","text":"","text_tokens":[],"title":"开始！","title_tokens":["开始","！"]},{"location":"extension_guide/alphamini/#1-codelab-scratch","text":"运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。","text_tokens":["代表","看到","。","指示灯","绿色","，"," ","成功","连接","确保","显示","正常","与","运行","adapte","平台","scratch","codelab","adapter","指示","在线"],"title":"步骤 1：打开 CodeLab Scratch","title_tokens":["1","步骤","codelab"," ","：","scratch","打开"]},{"location":"extension_guide/alphamini/#1-node_alphaminipy","text":"将 node_alphamini.py 插件下载到本地（随便放在一个文件夹里），在命令行中进入到这个文件夹，使用 python node_alphamini.py 运行它。","text_tokens":["本地","py","一个","文件夹","里","在","。","插件","下载","，","使用","node","（"," ","文件","放在","它","命令行","将","python","进入","_","这个","运行","中","到","命令",".","件夹","随便","alphamini","）"],"title":"步骤 1：运行 node_alphamini.py","title_tokens":[".","1","步骤","py","node","运行","_","alphamini"," ","："]},{"location":"extension_guide/alphamini/#2","text":"将 悟空机器人 连上网络。（操作细节可以参考 悟空机器人 说明书）","text_tokens":["说明书","操作","网络","可以","将","（","机器人","上","参考","细节"," ","连","机器","。","说明","）","悟空"],"title":"步骤 2：为 悟空机器人 配网","title_tokens":["为","步骤","配网","2","机器人"," ","机器","：","悟空"]},{"location":"extension_guide/alphamini/#3","text":"选择 scratch3 中的 EIM 插件. alphamini-demo2 以上 Demo 运行结果为:","text_tokens":[".","为","的","插件","-","以上",":","结果","运行","scratch3","alphamini","demo2"," ","demo","中","选择","eim"],"title":"步骤 3: 编程","title_tokens":["3","步骤",":"," ","编程"]},{"location":"extension_guide/alphamini/#_5","text":"更多API参考文档: mini-python-sdk","text_tokens":["-","sdk","更",":","python","多","参考","mini"," ","api","文档"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/alphamini/#_6","text":"","text_tokens":[],"title":"悟空的内置行为","title_tokens":["内置","的","行为","悟空"]},{"location":"extension_guide/alphamini/#_7","text":"robot . play_behavior ( name = 'custom_0035' ) # 生日快乐","text_tokens":[".","robot","快乐","custom","behavior","(","name","=","生日快乐","0035","_","#"," ","play","'",")","生日"],"title":"内置舞蹈","title_tokens":["内置","舞蹈"]},{"location":"extension_guide/alphamini/#_8","text":"robot . play_action ( action_name = '010' ) # 打招呼","text_tokens":[".","robot","(","name","=","打招呼","action","招呼","_","#"," ","play","010","'",")"],"title":"内置动作","title_tokens":["动作","内置"]},{"location":"extension_guide/alphamini/#_9","text":"robot . play_expression ( express_name = 'codemao13' ) # 疑问 提醒 悟空内部运行一个安卓系统，带有内嵌 Python 环境","text_tokens":["(","一个","安卓","带有","expression","，","=","#"," ","'",")","内部","运行","codemao13","_","python","内嵌","系统","play","疑问","环境",".","robot","name","提醒","express","悟空"],"title":"内置表情","title_tokens":["表情","内置"]},{"location":"extension_guide/alphamini/#faq","text":"","text_tokens":[],"title":"FAQ","title_tokens":["faq"]},{"location":"extension_guide/alphamini/#_10","text":"似乎和局域网内的设备发现机制（mdns？）有关。 通过以下脚本排查问题。如果以下脚本无法扫描到设备，请联系优必选客服人员。 注意将 00447 替换成你自己的设备号 # pip install alphamini # https://github.com/marklogg/mini_demo/blob/master/test/test_connect.py import asyncio import logging import mini.mini_sdk as MiniSdk from mini.dns.dns_browser import WiFiDevice \"\"\"根据机器人序列号后缀搜索设备 搜索指定序列号(在机器人屁股后面)的机器人, 可以只输入序列号尾部字符即可,长度任意, 建议5个字符以上可以准确匹配 \"\"\" device_name = \"00447\" async def test_get_device_by_name (): ''' 10秒超时 Returns: WiFiDevice: 包含机器人名称,ip,port等信息 ''' result : WiFiDevice = await MiniSdk . get_device_by_name ( device_name , 10 ) print ( f \"test_get_device_by_name result:{result}\" ) return result async def main (): device : WiFiDevice = await test_get_device_by_name () if device : print ( \"已发现设备\" ) else : print ( \"无法发现设备\" ) if __name__ == '__main__' : asyncio . run ( main ())","text_tokens":[",","必选","的","(","可以","替换","内","后缀","输入","你","超时","demo","如果","pip","f","（","returns","port","async","'","问题","as","print","sdk","设备","com","import","长度","客服","else",".","有关","minisdk","机器","即可","以上","py",":","在","机制","机器人","序列","局域","https","后面","\"","install","根据","run","by","发现","ip","和","任意",")","get","__","搜索","/","将","注意","自己","包含","屁股","_","mini","换成","from","号","mdns","局域网","通过","dns","联系","只","blob","名称","}","人员","秒","建议","个字符","。","优","无法","，","logging","指定","#","序列号","脚本","匹配","？","await","以下","等","请","github","尾部","似乎","alphamini","已","字符","main","）","{","排查","marklogg","10","connect","信息","00447","=","准确"," ","return","def","master","wifidevice","替换成","到","device","if","result","扫描","5","name","asyncio","browser","test"],"title":"有些网络无法扫描到悟空","title_tokens":["无法","扫描","网络","有些","到","悟空"]},{"location":"extension_guide/android/","text":"","text_tokens":[],"title":"Android","title_tokens":["android"]},{"location":"extension_guide/arduino_UNO/","text":"Tutorial ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：连接设备，加载插件 ¶ 步骤 3.1：为 Arduino UNO 烧入固件：FirmataExpress ¶ 安装 Arduino IDE 将 FirmataExpress 安装到 IDE 中 打开 Arduino IDE 并选择工具/管理库（Tools/Manage）。当出现库管理器时，在搜索框中输入 FirmataExpress ，然后单击安装。 安装超声波库：FirmataExpress 还依赖 Erick Simões 的超声库。再次使用 Arduino 库管理器搜索超声波，选择 Erick Simoes 的版本。 将 FirmataPlus 编译并上传到 Arduino： 选择文件/示例（File/Examples），然后从下拉列表中选择 FirmataExpress。 上传到 Arduino。 至此，我们就完成了 Arduino 相关的工作。 步骤 3.2：重置 Arduino ¶ 每次使用前，按下 Arduino 的重置按钮。 步骤 3.3：加载插件 ¶ 在 CodeLab Adapter 中点击加载 Arduino UNO 插件： 点击加载插件之后，你应该会看到板子上的 LED 闪烁。如果一切正常，大约 5 秒钟之后（连接时间由 pymata_express 决定），你将看到连接 Arduino UNO 成功的提醒。现在你可以开始在 Scratch 里编程了。 ps: Linux 用户注意，scratch3_adapter 使用 USB 串口与 Arduino 连接，Linux 下，使用 USB 串口需要做权限设置： sudo chmod 666 /dev/ttyACM0 步骤 4：hello world ¶ 现在让我们利用 CodeLab Scratch3 控制 Arduino。 选择对应的 Scratch3 插件：Arduino UNO。 选择对应拓展积木，点击运行。 提醒 引脚在设置具体值之前，不允许读取，否则会出现tx/rx持续轮询被占用(你可以观察到板子上的灯常亮)，这是 pymata_express 的机制决定的。遇到这种情况，请按下重置按钮重新连接。 感谢 ¶ 感谢 mryslab 在硬件驱动上的工作，该插件从他的工作中移植过来。 结语 ¶ 这个例子完整展示了 CodeLab Adapter 的使用流程 打开 CodeLab Adapter 打开 CodeLab Scratch3 接入你的设备（可以是任何开源硬件） 打开对应插件 选择对应拓展积木，在 Scratch 3.0 中与设备交互 如果你想接入的设备目前没有默认插件支持它（诸如 Arduino 的其他版本：Nano 之类的），你可以自己来写，CodeLab Adapter 允许你将任何硬件接入 Scratch 3.0 中，别害怕，需要的代码很少也很简单，详情参见 开发手册 。我们支持使用任何编程语言来写拓展，目前我们自己主要使用 Python。 我们也将在 extension guide 中介绍各种社区插件的使用方法。","text_tokens":[",","的","步骤","管理器","时","用户","安装","可以","(","大约","输入","上","看到","拉","你","别","引脚","开发","这种","如果","绿色","1","现在","编译","我们","就","利用","观察","简单","（","一切正常","es","他","读取","做","tutorial","说明","uno","浏览器","正常","这儿","manage","社区","工具","设备","单击","sudo","固件","应该","传到","害怕","按下","相关","scratch","需要","现阶段",".","为","启动","对应","codelab","否则","adapter","了","usb","轮询","参见","介绍","设置","下","会","点击","simoes","接入","小圆点","让","值","这是","其设",":","在","led","机制","之类","主要","没有","箭头","ttyacm0","mryslab","还","ui","各种","语言","硬件","之后","编程语言","file","声波","extension","成功","链接","文件","诸如","效果","被",")","手册","搜索","/","world","任何","将","注意","按","自己","圆点","nano","按钮","_","过来","来","python","官方","中","从","想","管理","dev","guide","再次","示例","chrome","秒钟","双击","linux","3.2","2","erick","然后","tools","理器","支持","õ","当","接时","express","提醒","前","具体","arduino","陆续","工作","呈现","框中","展示","移植","遇到","并","浏览","依赖","列表","建议","3.3","例子","。","：","灯常亮","pymata","打开","3","库","firefox","一切","，","或者","页面","web","也","完成","由","scratch3","烧入","hello","感谢","连接","开始","方法","开源","加载","firmataplus","运行","多","串口","如下","该","tx","请","驱动","重置","权限","允许","流程","很","¶","结语","其他","默认","交互","超声","examples","sim","写","firmataexpress","）","阶段","版本","里","占用","超声波","板子","4","决定","chmod","之前","详情","3.1","出现","闪烁","插件","使用","很少","积木","更","持续"," ","时间","情况","它","编程","rx","每次","666","与","代码","这个","连接时间","不","完整","图中","ide","到","团队","拓展","是","ps","5","重新","scratch3.0","至此","3.0","选择","所指","目前","最佳","控制"],"title":"arduino UNO","title_tokens":[" ","arduino","uno"]},{"location":"extension_guide/arduino_UNO/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/arduino_UNO/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/arduino_UNO/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/arduino_UNO/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"extension_guide/arduino_UNO/#3","text":"","text_tokens":[],"title":"步骤 3：连接设备，加载插件","title_tokens":["3","插件","步骤","，","设备","加载"," ","连接","："]},{"location":"extension_guide/arduino_UNO/#31-arduino-uno-firmataexpress","text":"安装 Arduino IDE 将 FirmataExpress 安装到 IDE 中 打开 Arduino IDE 并选择工具/管理库（Tools/Manage）。当出现库管理器时，在搜索框中输入 FirmataExpress ，然后单击安装。 安装超声波库：FirmataExpress 还依赖 Erick Simões 的超声库。再次使用 Arduino 库管理器搜索超声波，选择 Erick Simoes 的版本。 将 FirmataPlus 编译并上传到 Arduino： 选择文件/示例（File/Examples），然后从下拉列表中选择 FirmataExpress。 上传到 Arduino。 至此，我们就完成了 Arduino 相关的工作。","text_tokens":["框中","的","管理器","版本","时","安装","并","在","输入","依赖","上","拉","超声波","列表","。","：","下","打开","还","出现","库","编译","使用","，","我们","就","（","file","声波","完成","es"," ","文件","manage","搜索","/","工具","firmataplus","将","单击","firmataexpress","传到","中","从","管理","相关","到","ide","再次","示例","了","erick","然后","至此","tools","理器","超声","õ","当","选择","sim","examples","simoes","）","arduino","工作"],"title":"步骤 3.1：为 Arduino UNO 烧入固件：FirmataExpress","title_tokens":["为","步骤","固件","烧入"," ","uno","：","firmataexpress","arduino","3.1"]},{"location":"extension_guide/arduino_UNO/#32-arduino","text":"每次使用前，按下 Arduino 的重置按钮。","text_tokens":["的","每次","使用","，","按钮","。"," ","按下","前","arduino","重置"],"title":"步骤 3.2：重置 Arduino","title_tokens":["步骤","3.2"," ","：","arduino","重置"]},{"location":"extension_guide/arduino_UNO/#33","text":"在 CodeLab Adapter 中点击加载 Arduino UNO 插件： 点击加载插件之后，你应该会看到板子上的 LED 闪烁。如果一切正常，大约 5 秒钟之后（连接时间由 pymata_express 决定），你将看到连接 Arduino UNO 成功的提醒。现在你可以开始在 Scratch 里编程了。 ps: Linux 用户注意，scratch3_adapter 使用 USB 串口与 Arduino 连接，Linux 下，使用 USB 串口需要做权限设置： sudo chmod 666 /dev/ttyACM0","text_tokens":["的","用户","可以","led","在","大约","看到","上","里","你",":","板子","。","：","决定","chmod","pymata","ttyacm0","如果","闪烁","插件","一切","现在","，","使用","之后","（","一切正常","由","scratch3"," ","成功","时间","做","uno","连接","编程","开始","正常","666","/","加载","将","注意","与","sudo","_","串口","应该","连接时间","中","dev","scratch","需要","权限","codelab","秒钟","ps","linux","adapter","5","了","usb","接时","设置","提醒","express","下","会","点击","）","arduino"],"title":"步骤 3.3：加载插件","title_tokens":["插件","步骤","加载"," ","3.3","："]},{"location":"extension_guide/arduino_UNO/#4hello-world","text":"现在让我们利用 CodeLab Scratch3 控制 Arduino。 选择对应的 Scratch3 插件：Arduino UNO。 选择对应拓展积木，点击运行。 提醒 引脚在设置具体值之前，不允许读取，否则会出现tx/rx持续轮询被占用(你可以观察到板子上的灯常亮)，这是 pymata_express 的机制决定的。遇到这种情况，请按下重置按钮重新连接。","text_tokens":["让","值","的","这是","(","遇到","可以","在","会","上","机制","占用","你","引脚","板子","。","：","灯常亮","决定","之前","pymata","这种","下","出现","现在","我们","利用","插件","，","积木","观察","scratch3","持续"," ","读取","情况","uno","连接","被",")","rx","/","按","运行","_","按钮","不","到","tx","请","拓展","重置","对应","允许","codelab","否则","轮询","重新","设置","提醒","选择","express","具体","点击","arduino","控制"],"title":"步骤 4：hello world","title_tokens":["步骤","world","hello"," ","4","："]},{"location":"extension_guide/arduino_UNO/#_2","text":"感谢 mryslab 在硬件驱动上的工作，该插件从他的工作中移植过来。","text_tokens":["的","插件","移植","，","硬件","在","上","他","过来","。"," ","从","感谢","中","该","驱动","mryslab","工作"],"title":"感谢","title_tokens":["感谢"]},{"location":"extension_guide/arduino_UNO/#_3","text":"这个例子完整展示了 CodeLab Adapter 的使用流程 打开 CodeLab Adapter 打开 CodeLab Scratch3 接入你的设备（可以是任何开源硬件） 打开对应插件 选择对应拓展积木，在 Scratch 3.0 中与设备交互 如果你想接入的设备目前没有默认插件支持它（诸如 Arduino 的其他版本：Nano 之类的），你可以自己来写，CodeLab Adapter 允许你将任何硬件接入 Scratch 3.0 中，别害怕，需要的代码很少也很简单，详情参见 开发手册 。我们支持使用任何编程语言来写拓展，目前我们自己主要使用 Python。 我们也将在 extension guide 中介绍各种社区插件的使用方法。","text_tokens":["的","可以","别","你","开发","如果","我们","简单","（","社区","设备","害怕","scratch","需要","对应","codelab","了","adapter","参见","介绍","接入","在","之类","主要","没有","各种","语言","硬件","编程语言","extension","诸如","手册","任何","将","自己","来","python","nano","中","想","guide","支持","arduino","展示","例子","。","：","打开","也","，","scratch3","方法","开源","流程","很","允许","其他","默认","交互","写","）","版本","详情","插件","使用","很少","积木"," ","它","编程","与","代码","这个","完整","是","拓展","3.0","选择","目前"],"title":"结语","title_tokens":["结语"]},{"location":"extension_guide/bitbot/","text":"","text_tokens":[],"title":"Bitbot","title_tokens":["bitbot"]},{"location":"extension_guide/blender/","text":"Tutorial ¶ 系统依赖参考 EIM 教程 。 安装依赖 ¶ 我的环境是： MacOS blender 2.8 cd /Applications/blender.app/Contents/Resources/2.80/python/bin wget https://bootstrap.pypa.io/get-pip.py ./python3.7m ./get-pip.py --prefix /Applications/blender.app/Contents/Resources/2.80/python ./python3.7m pip3 install codelab_adapter_client --upgrade 在 blender 中运行 node_blender ¶ 在 blender 中运行 node_blender.py ，我们在 blender 2.79 和 2.80 两个版本中都做了测试。 在 blender 2.79b 中， 打开 Text Editor ，运行 node_blender.py ： 在 blender 2.80 中，我喜欢打开 Scripting 标签页（使用 Text Editor 也可以），运行 node_blender.py ： 提醒 如果你希望看到调试信息(log) 在命令行里启动blender， /Applications/blender.app/Contents/MacOS/blender （MacOS） 运行 CodeLab Adapter (作为消息中心) ¶ 开始使用 ¶ 打开 CodeLab Scratch3 ，开始使用。 如果遇到问题，请尝试刷新浏览器缓存。 Demo ¶ Scratch blender todo ¶ 将 node_blender (v2)写成 blender 插件。","text_tokens":["的","(","安装","可以","看到","你","applications","demo","如果","我","pip","我们","（","做","tutorial","问题","浏览器","pypa","blender","scratch",".","测试","启动","codelab","作为","adapter","了","页","-","py",":","在","https","两个","install","b","参考","和",")","2.79","get","pip3","m","/","2.80","将","python","_","中","缓存","提醒","eim","遇到","浏览","依赖","尝试","标签","。","：","bin","打开","也","，","2.8","希望","scratch3","刷新","调试","开始","教程","写成","运行","系统","命令","请","¶","client","）","upgrade","text","wget","io","editor","版本","里","调试信息","信息","喜欢","插件","python3.7","使用","log","contents","prefix","node","cd","scripting"," ","resources","命令行","中心","都","todo","是","环境","v2","app","bootstrap","消息","macos"],"title":"blender","title_tokens":["blender"]},{"location":"extension_guide/blender/#tutorial","text":"系统依赖参考 EIM 教程 。","text_tokens":["教程","依赖","参考"," ","系统","eim","。"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/blender/#_1","text":"我的环境是： MacOS blender 2.8 cd /Applications/blender.app/Contents/Resources/2.80/python/bin wget https://bootstrap.pypa.io/get-pip.py ./python3.7m ./get-pip.py --prefix /Applications/blender.app/Contents/Resources/2.80/python ./python3.7m pip3 install codelab_adapter_client --upgrade","text_tokens":["wget","io","的","-","py",":","applications","https","：","install","bin","我","pip","python3.7","contents","prefix","2.8","cd"," ","resources","get","pip3","m","/","2.80","python","pypa","_","blender","upgrade","是","环境","app",".","codelab","bootstrap","adapter","client","macos"],"title":"安装依赖","title_tokens":["安装","依赖"]},{"location":"extension_guide/blender/#blender-node_blender","text":"在 blender 中运行 node_blender.py ，我们在 blender 2.79 和 2.80 两个版本中都做了测试。 在 blender 2.79b 中， 打开 Text Editor ，运行 node_blender.py ： 在 blender 2.80 中，我喜欢打开 Scripting 标签页（使用 Text Editor 也可以），运行 node_blender.py ： 提醒 如果你希望看到调试信息(log) 在命令行里启动blender， /Applications/blender.app/Contents/MacOS/blender （MacOS）","text_tokens":["editor","版本","(","py","可以","里","在","调试信息","看到","你","applications","标签","信息","。","两个","：","b","打开","我","喜欢","如果","我们","也","使用","，","log","contents","node","（","希望","scripting"," ","做","和","调试",")","2.79","命令行","/","2.80","运行","_","blender","都","中","macos","命令","app",".","测试","启动","了","提醒","页","）","text"],"title":"在 blender 中运行 node_blender","title_tokens":["node","在","运行","_","blender"," ","中"]},{"location":"extension_guide/blender/#codelab-adapter","text":"","text_tokens":[],"title":"运行  CodeLab Adapter (作为消息中心)","title_tokens":["codelab","(","作为","adapter","消息","运行","中心"," ",")"]},{"location":"extension_guide/blender/#_2","text":"打开 CodeLab Scratch3 ，开始使用。 如果遇到问题，请尝试刷新浏览器缓存。","text_tokens":["开始","浏览器","codelab","使用","，","遇到","缓存","请","浏览","尝试","scratch3","刷新"," ","。","如果","问题","打开"],"title":"开始使用","title_tokens":["开始","使用"]},{"location":"extension_guide/blender/#demo","text":"Scratch blender","text_tokens":["blender"," ","scratch"],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/blender/#todo","text":"将 node_blender (v2)写成 blender 插件。","text_tokens":["插件","(","将","node","写成","_","blender"," ","。",")","v2"],"title":"todo","title_tokens":["todo"]},{"location":"extension_guide/cozmo/","text":"Cozmo ¶ Windows MacOS Linux iOS 需要安装iTunes 开箱可用 手动安装 Android 开箱可用 开箱可用 手动安装 运行 SDK 模式 ¶ 将 Cozmo 接入移动设备（手机/平板），并进入SDK模式。 使用数据线将手机/平板接入电脑。 详情参考: 官方文档 Download Codelab Adapter ¶ Download Codelab Adapter run it Open Scratch 3.0 ¶ open CodeLab Scratch3 Open extension_cozmo ¶ open extension_cozmo in CodeLab Adapter Enjoy it :) Tip Cozmo 有数百种动作/行为（它们只是字符串），可以使用 运行 和 执行 积木触发。浏览这些丰富的行为可以使用这个工具： Cozmo-Explorer-Tool 。 Advanced ¶ You can create your own custom blocks based on the exec block . Almost all Cozmo SDK API work. linux user ¶ install codelab_adapter_client ¶ Python >= 3.6 Linux/MacOS user: python3 -m pip install codelab_adapter_client --upgrade --user Install the SDK on your system ¶ Follow Cozmo official tutorial: Initial Setup If the following code ( hello_world.py ) runs smoothly, go to the next step. ''' linux: /usr/bin/python3 hello_world.py ''' import cozmo from codelab_adapter_client import AdapterNode def cozmo_program ( robot : cozmo . robot . Robot ): robot . say_text ( \"Hello World\" ) . wait_for_completed () cozmo . run_program ( cozmo_program ) 进阶 ¶ 参考 Cozmo API ，建议在 jupyterlab 中做实验(已经内置好了Cozmo环境) 提醒 如果你希望做一些更复杂的事，建议直接使用社区里的 Python SDK与 设备交互，之后使用 Adapter Node 将其接入Adapter环境中。","text_tokens":[",","的","(","go","安装","动作","可以","step","next","你","行为","wait","其","内置","执行","如果","pip",">","（","system","enjoy","数据","做","tutorial","'","社区","sdk","工具","设备","setup","import","tool","这些","需要","scratch","can","模式",".","codelab","android","只是","for","adapter","了","3.6","接入","已经","-","usr","py",":","在","exec","\"","cozmo","install","run","completed","it","almost","实验","tip","smoothly","extension","之后","create","参考","your","和","advanced",")","百种","m","/","world","follow","将","initial","python","_","from","官方","中","linux","复杂","提醒","数百种","进阶","program","它们","并","浏览","official","建议","好","own","。","文档","：","bin","，","数据线","可用","hello","希望","scratch3","work","to","直接","运行","进入","jupyterlab","runs","python3","有","say","custom","code","¶","触发","交互","字符","api","client","）","download","电脑","手机","upgrade","text","on","里","字符串","based","平板","开箱","详情","数百","explorer","使用","itunes","in","积木","=","更","node"," ","事","following","blocks","open","def","手动","all","adapternode","windows","与","这个","you","the","丰富","一些","user","环境","if","block","robot","ios","3.0","macos","移动"],"title":"Cozmo","title_tokens":["cozmo"]},{"location":"extension_guide/cozmo/#cozmo","text":"Windows MacOS Linux iOS 需要安装iTunes 开箱可用 手动安装 Android 开箱可用 开箱可用 手动安装","text_tokens":["开箱","ios","手动","linux","windows","安装","itunes","android","可用"," ","macos","需要"],"title":"Cozmo","title_tokens":["cozmo"]},{"location":"extension_guide/cozmo/#sdk","text":"将 Cozmo 接入移动设备（手机/平板），并进入SDK模式。 使用数据线将手机/平板接入电脑。 详情参考: 官方文档","text_tokens":["并",":","。","cozmo","平板","文档","详情","使用","，","数据线","（","数据","参考"," ","/","sdk","设备","将","进入","官方","模式","移动","接入","）","电脑","手机"],"title":"运行 SDK 模式","title_tokens":["模式"," ","运行","sdk"]},{"location":"extension_guide/cozmo/#download-codelab-adapter","text":"Download Codelab Adapter run it","text_tokens":["it","codelab","adapter"," ","download","run"],"title":"Download Codelab Adapter","title_tokens":["adapter"," ","download","codelab"]},{"location":"extension_guide/cozmo/#open-scratch-30","text":"open CodeLab Scratch3","text_tokens":["scratch3","codelab"," ","open"],"title":"Open Scratch 3.0","title_tokens":["3.0"," ","scratch","open"]},{"location":"extension_guide/cozmo/#open-extension_cozmo","text":"open extension_cozmo in CodeLab Adapter Enjoy it :) Tip Cozmo 有数百种动作/行为（它们只是字符串），可以使用 运行 和 执行 积木触发。浏览这些丰富的行为可以使用这个工具： Cozmo-Explorer-Tool 。","text_tokens":["的","-","它们","动作","可以",":","浏览","字符串","行为","。","cozmo","：","执行","数百","it","explorer","使用","，","积木","in","tip","extension","（","enjoy"," ","和",")","open","百种","/","工具","运行","这个","_","tool","丰富","这些","有","codelab","只是","adapter","触发","字符","数百种","）"],"title":"Open extension_cozmo","title_tokens":["extension","_"," ","cozmo","open"]},{"location":"extension_guide/cozmo/#advanced","text":"You can create your own custom blocks based on the exec block . Almost all Cozmo SDK API work.","text_tokens":["on","exec","own","based","cozmo","almost","create","work","your"," ","blocks","all","sdk","you","the","can","block",".","custom","api"],"title":"Advanced","title_tokens":["advanced"]},{"location":"extension_guide/cozmo/#linux-user","text":"","text_tokens":[],"title":"linux user","title_tokens":["linux","user"," "]},{"location":"extension_guide/cozmo/#install-codelab_adapter_client","text":"Python >= 3.6 Linux/MacOS user: python3 -m pip install codelab_adapter_client --upgrade --user","text_tokens":["-",":","install","pip",">","="," ","m","/","python","_","upgrade","user","python3","codelab","linux","adapter","3.6","client","macos"],"title":"install codelab_adapter_client","title_tokens":["codelab","adapter","_"," ","client","install"]},{"location":"extension_guide/cozmo/#install-the-sdk-on-your-system","text":"Follow Cozmo official tutorial: Initial Setup If the following code ( hello_world.py ) runs smoothly, go to the next step. ''' linux: /usr/bin/python3 hello_world.py ''' import cozmo from codelab_adapter_client import AdapterNode def cozmo_program ( robot : cozmo . robot . Robot ): robot . say_text ( \"Hello World\" ) . wait_for_completed () cozmo . run_program ( cozmo_program )","text_tokens":[",","(","usr","go","py","text",":","step","next","official","wait","\"","cozmo","bin","completed","run","smoothly","hello","to"," ","tutorial","following",")","'","def","/","world","follow","setup","initial","adapternode","_","import","from","the","runs","python3","if",".","robot","say","codelab","code","linux","adapter","for","client","program"],"title":"Install the SDK on your system","title_tokens":["sdk","on","system","your"," ","the","install"]},{"location":"extension_guide/cozmo/#_1","text":"参考 Cozmo API ，建议在 jupyterlab 中做实验(已经内置好了Cozmo环境) 提醒 如果你希望做一些更复杂的事，建议直接使用社区里的 Python SDK与 设备交互，之后使用 Adapter Node 将其接入Adapter环境中。","text_tokens":["的","(","里","在","你","建议","好","。","cozmo","其","内置","如果","实验","使用","，","更","之后","node","希望","参考"," ","事","做",")","直接","社区","sdk","设备","将","与","python","jupyterlab","中","一些","环境","了","adapter","复杂","交互","提醒","api","接入","已经"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/creating-coding/","text":"创意编程(creative-coding) ¶ If I can't picture it, I can't understand it. -- Albert Einstein 创意编程(creative-coding)社区将计算机视为一种表达媒介，这是我们关注该领域的原因。 创意编程(creative-coding)社区有许多流行项目， 我们尤其关注以下几个: mosaic openFrameworks openprocessing Processing oscP5 p5js p5js-osc Sonic Pi ptsjs nannou 这些项目大多数都内置 OSC 支持。 由于 Adapter 内置了 OSC Server 和 Client , 所以可以轻松与创意编程(creative-coding)生态的设施互操作！ 参考 ¶ awesome-creative-coding","text_tokens":[",","的","算机","(","可以","所以","oscp5","原因","内置","大多","albert","我们","媒介","creative","'","社区","大多数","processing","这些","can","t",".","adapter","了","p5js","领域","-","这是","生态",":","it","创意","一种","参考","picture","视为","pi","和","i",")","设施","将","awesome","计算机","server","einstein","支持","多数","许多","ptsjs","。","关注","，","understand","openframeworks","以下","nannou","！","该","有","¶","轻松","mosaic","client","项目","互操作","几个","openprocessing","操作"," ","由于","流行","编程","尤其","与","都","if","计算","sonic","osc","表达","coding"],"title":"创意编程","title_tokens":["创意","编程"]},{"location":"extension_guide/creating-coding/#creative-coding","text":"If I can't picture it, I can't understand it. -- Albert Einstein 创意编程(creative-coding)社区将计算机视为一种表达媒介，这是我们关注该领域的原因。 创意编程(creative-coding)社区有许多流行项目， 我们尤其关注以下几个: mosaic openFrameworks openprocessing Processing oscP5 p5js p5js-osc Sonic Pi ptsjs nannou 这些项目大多数都内置 OSC 支持。 由于 Adapter 内置了 OSC Server 和 Client , 所以可以轻松与创意编程(creative-coding)生态的设施互操作！","text_tokens":[",","的","算机","(","可以","所以","oscp5","原因","内置","大多","albert","我们","媒介","creative","'","社区","大多数","processing","这些","can","t",".","adapter","了","p5js","领域","-","这是","生态",":","it","创意","一种","picture","视为","pi","和","i",")","设施","将","计算机","server","einstein","支持","多数","许多","ptsjs","。","关注","，","understand","openframeworks","以下","nannou","！","该","有","轻松","mosaic","client","项目","互操作","几个","openprocessing","操作"," ","由于","流行","编程","尤其","与","都","if","计算","sonic","osc","表达","coding"],"title":"创意编程(creative-coding)","title_tokens":["创意","-","(","creative",")","coding","编程"]},{"location":"extension_guide/creating-coding/#_1","text":"awesome-creative-coding","text_tokens":["creative","awesome","-","coding"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/digimon/","text":"digimon ¶ 插件介绍: Neverland2.0原型之 兴趣的【指向】 插件源码: node_digimon.py . digimon 插件本质上是webserver（改编(remix)自 node_webserver_flask.py ），将 web 请求转化为 EIM message。 Scratch Demo ¶ Scratch digimon demo","text_tokens":["的","flask","(","之","改编","py","webserver",":","转化","兴趣","上","请求","demo","。","remix","自","插件","，","web","node","（"," ",")","）","message","指向","将","原型","_","neverland2.0","源码","是","scratch",".","为","【","¶","介绍","digimon","】","eim","本质"],"title":"digimon","title_tokens":["digimon"]},{"location":"extension_guide/digimon/#digimon","text":"插件介绍: Neverland2.0原型之 兴趣的【指向】 插件源码: node_digimon.py . digimon 插件本质上是webserver（改编(remix)自 node_webserver_flask.py ），将 web 请求转化为 EIM message。","text_tokens":["的","flask","(","之","改编","py","webserver",":","转化","兴趣","上","请求","。","remix","自","插件","，","web","node","（"," ",")","）","message","指向","将","原型","_","neverland2.0","源码","是",".","为","【","介绍","digimon","】","eim","本质"],"title":"digimon","title_tokens":["digimon"]},{"location":"extension_guide/digimon/#scratch-demo","text":"Scratch digimon demo","text_tokens":[" ","scratch","digimon","demo"],"title":"Scratch Demo","title_tokens":[" ","scratch","demo"]},{"location":"extension_guide/eim/","text":"Tutorial ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：加载 EIM 插件 ¶ 在 Web UI 中点击加载 EIM 插件: eim 每秒钟更新一次数值，将数值报告给 Scratch3。 步骤 4：hello world ¶ 选择对应的 Scratch3 插件：EIM 我们可以让 Scratch3 的角色读出 EIM 每秒更新一次的数值：","text_tokens":[",","的","步骤","安装","可以","上","绿色","1","我们","tutorial","说明","浏览器","正常","这儿","scratch","现阶段",".","为","启动","对应","codelab","adapter","点击","小圆点","让","其设",":","在","箭头","每秒","ui","之后","链接","效果","更新","/","world","将","读出","圆点","官方","中","chrome","秒钟","双击","2","支持","eim","陆续","呈现","浏览","依赖","建议","。","：","打开","3","firefox","给","，","或者","页面","web","hello","scratch3","数值","连接","加载","多","如下","¶","默认","阶段","版本","4","一次","插件","使用","更"," ","每秒钟","与","报告","图中","团队","角色","scratch3.0","选择","所指","目前","最佳"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/eim/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/eim/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/eim/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/eim/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"extension_guide/eim/#3-eim","text":"在 Web UI 中点击加载 EIM 插件: eim 每秒钟更新一次数值，将数值报告给 Scratch3。","text_tokens":[":","在","。","一次","每秒","ui","插件","给","，","web","scratch3"," ","数值","每秒钟","更新","加载","将","中","报告","秒钟","eim","点击"],"title":"步骤 3：加载 EIM 插件","title_tokens":["3","插件","步骤","加载"," ","eim","："]},{"location":"extension_guide/eim/#4hello-world","text":"选择对应的 Scratch3 插件：EIM 我们可以让 Scratch3 的角色读出 EIM 每秒更新一次的数值：","text_tokens":["对应","让","角色","的","插件","我们","可以","读出","scratch3"," ","数值","选择","eim","：","一次","每秒","更新"],"title":"步骤 4：hello world","title_tokens":["步骤","world","hello"," ","4","："]},{"location":"extension_guide/eim_monitor/","text":"EIM Monitor ¶ 插件介绍 ¶ 通过 extension_eim_monitor 插件， Scratcher 可以轻松使用 Python 拓展 Scratch 的能力。 当 extension_eim_monitor 启用时， 来自 Scratch EIM 插件的消息将被 ~/codelab_adapter/extensions/eim_monitor.py 脚本处理， 处理结果返回给 Scratch。 我们将这种对 Scratch 消息的响应机制称为 monitor 。 默认的脚本，会在Scratch的消息结尾加上 from monitor 并返回。 脚本源码 （简单的 Python 代码）为： def monitor ( content , logger ): return content + ' from monitor' 你可以随意修改 monitor 脚本代码，改变处理规则。 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：加载 extension_eim_monitor 插件 ¶ 在 Web UI 中点击加载 extension_eim_monitor 插件 步骤 4：hello world ¶ 选择对应的 Scratch3 插件：EIM 往 CodeLab Adapter 发送消息，观看 Python 对其的处理结果： 步骤 5：自定义 eim_monitor 逻辑 ¶ 修改 eim_monitor.py 代码后，需要重启勾选 extension_eim_monitor 插件。 运行 extension_eim_monitor 插件后， monitor 函数会被重复调用，通过修改 monitor 函数的返回值，可以让 Scratch 中发送任意数据。 Help 如何找到 eim_monitor.py 文件? ~/codelab_adapter/extensions/eim_monitor.py 其他用例 ¶ import webbrowser def monitor ( content , logger ): ''' 打开网页 ''' webbrowser . open ( content ) return \"ok\" 在 Scratch EIM 中传递消息 https://www.codelab.club 试试。 提醒 如果你想引入第三方库，请使用 node_eim_monitor. 参考 ¶ 使用 Python 拓展 Scratch 的能力","text_tokens":[",","的","步骤","(","时","可以","安装","上","你","其","scratcher","这种","如果","绿色","1","我们","简单","自定义","（","help","数据","club","说明","重启","'","往","浏览器","正常","这儿","返回值","import","后","scratch","处理结果","需要","现阶段",".","为","启动","对应","codelab","介绍","adapter","调用","第三","+","www","规则","会","点击","勾选","小圆点","让","结尾","其设","py",":","在","机制","~","重复","https","处理","\"","箭头","ui","来自","extension","logger","之后","参考","链接","随意","改变","文件","被","效果",")","content","任意","响应","/","world","自定","将","三方","python","圆点","_","启用","from","官方","中","想","对","通过","用例","chrome","双击","2","?","支持","网页","当","eim","发送","提醒","陆续","呈现","称为","并","函数","浏览","依赖","逻辑","webbrowser","如何","传递","建议","。","：","打开","3","加上","库","给","firefox","，","或者","页面","web","hello","scratch3","连接","脚本","引入","定义","extensions","加载","ok","运行","多","如下","找到","请","monitor","返回","¶","轻松","其他","默认","）","第三方","阶段","版本","结果","观看","4","插件","使用","更","node"," ","open","return","def","与","代码","修改","图中","源码","团队","拓展","试试","消息","5","scratch3.0","能力","选择","所指","目前","最佳"],"title":"EIM Monitor","title_tokens":["monitor"," ","eim"]},{"location":"extension_guide/eim_monitor/#eim-monitor","text":"","text_tokens":[],"title":"EIM Monitor","title_tokens":["monitor"," ","eim"]},{"location":"extension_guide/eim_monitor/#_1","text":"通过 extension_eim_monitor 插件， Scratcher 可以轻松使用 Python 拓展 Scratch 的能力。 当 extension_eim_monitor 启用时， 来自 Scratch EIM 插件的消息将被 ~/codelab_adapter/extensions/eim_monitor.py 脚本处理， 处理结果返回给 Scratch。 我们将这种对 Scratch 消息的响应机制称为 monitor 。 默认的脚本，会在Scratch的消息结尾加上 from monitor 并返回。 脚本源码 （简单的 Python 代码）为： def monitor ( content , logger ): return content + ' from monitor' 你可以随意修改 monitor 脚本代码，改变处理规则。","text_tokens":[",","称为","的","结尾","(","时","可以","py","并","在","结果","~","机制",":","你","处理","。","：","scratcher","这种","加上","插件","给","使用","，","我们","来自","简单","extension","（","logger"," ","随意","改变","被","脚本",")","content","'","return","响应","def","extensions","/","将","代码","python","_","启用","from","修改","源码","scratch","处理结果","拓展","monitor","通过",".","对","为","codelab","返回","adapter","消息","轻松","默认","+","能力","eim","当","会","规则","）"],"title":"插件介绍","title_tokens":["介绍","插件"]},{"location":"extension_guide/eim_monitor/#_2","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/eim_monitor/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/eim_monitor/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"extension_guide/eim_monitor/#3-extension_eim_monitor","text":"在 Web UI 中点击加载 extension_eim_monitor 插件","text_tokens":["ui","插件","加载","web","extension","在","_"," ","中","eim","点击","monitor"],"title":"步骤 3：加载 extension_eim_monitor 插件","title_tokens":["3","插件","步骤","加载","extension","_"," ","eim","：","monitor"]},{"location":"extension_guide/eim_monitor/#4hello-world","text":"选择对应的 Scratch3 插件：EIM 往 CodeLab Adapter 发送消息，观看 Python 对其的处理结果：","text_tokens":["的","结果","观看","处理","其","：","插件","，","scratch3"," ","往","python","处理结果","对","对应","codelab","adapter","消息","发送","选择","eim"],"title":"步骤 4：hello world","title_tokens":["步骤","world","hello"," ","4","："]},{"location":"extension_guide/eim_monitor/#5-eim_monitor","text":"修改 eim_monitor.py 代码后，需要重启勾选 extension_eim_monitor 插件。 运行 extension_eim_monitor 插件后， monitor 函数会被重复调用，通过修改 monitor 函数的返回值，可以让 Scratch 中发送任意数据。 Help 如何找到 eim_monitor.py 文件? ~/codelab_adapter/extensions/eim_monitor.py","text_tokens":["让","的","py","可以","函数","~","如何","重复","。","插件","，","extension","help","数据"," ","文件","重启","被","任意","extensions","/","返回值","代码","运行","_","中","修改","找到","后","需要","scratch","monitor","通过",".","codelab","返回","调用","adapter","?","发送","eim","会","勾选"],"title":"步骤 5：自定义 eim_monitor 逻辑","title_tokens":["定义","步骤","自定义","自定","5","逻辑","_"," ","eim","：","monitor"]},{"location":"extension_guide/eim_monitor/#_3","text":"import webbrowser def monitor ( content , logger ): ''' 打开网页 ''' webbrowser . open ( content ) return \"ok\" 在 Scratch EIM 中传递消息 https://www.codelab.club 试试。 提醒 如果你想引入第三方库，请使用 node_eim_monitor.","text_tokens":[",","(","webbrowser",":","在","传递","你","https","\"","。","打开","如果","库","使用","，","logger","node","club"," ","引入","'",")","content","open","return","def","/","三方","ok","_","import","中","想","scratch","请","monitor",".","codelab","试试","消息","第三","网页","www","eim","提醒","第三方"],"title":"其他用例","title_tokens":["用例","其他"]},{"location":"extension_guide/eim_monitor/#_4","text":"使用 Python 拓展 Scratch 的能力","text_tokens":["的","使用","python"," ","能力","scratch","拓展"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/eim_trigger/","text":"EIM Trigger ¶ 插件介绍 ¶ 通过 extension_eim_trigger 插件， Scratcher 可以轻松使用 Python 拓展 Scratch 的能力。 extension_eim_trigger 通过调用 ~/codelab_adapter/extensions/eim_trigger.py 脚本，往 Scratch 发送消息。 我们将其称为消息的触发机制( trigger )。 默认的脚本，每隔 1s，往 Scratch 中发送一次时间戳， 脚本源码 （简单的 Python 代码）为： import time def trigger (): timestamp = time . time () time . sleep ( 1 ) return timestamp 你可以随意修改 trigger 脚本代码，往 Scratch 中发送任意数据。 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：加载 extension_eim_trigger 插件 ¶ 在 Web UI 中点击加载 extension_eim_trigger 插件 步骤 4：hello world ¶ 开启 extension_eim_trigger 插件后 选择对应的 Scratch3 插件：EIM 让 Scratch3 的角色读出每秒更新一次的时间戳： 步骤 5：自定义 eim_trigger 逻辑 ¶ 默认的逻辑是 每秒更新一次时间戳 ，相应代码为： import time def trigger (): timestamp = time . time () time . sleep ( 1 ) return timestamp 运行 extension_eim_trigger 插件后， trigger 函数会被重复调用，通过修改 trigger 函数的返回值，可以让 Scratch 中发送任意数据。 Help 如何找到 eim_trigger.py 文件? ~/codelab_adapter/extensions/eim_trigger.py 其他用例 ¶ import time i = 0 def trigger (): global i i += 1 time . sleep ( 1 ) return i 参考 ¶ 使用 Python 拓展 Scratch 的能力","text_tokens":[",","的","步骤","(","可以","安装","上","你","其","scratcher","绿色","1","我们","简单","自定义","（","help","数据","trigger","说明","往","浏览器","正常","这儿","返回值","戳","import","后","scratch","现阶段",".","1s","为","启动","codelab","对应","介绍","调用","adapter","+","会","点击","小圆点","让","其设","py",":","在","机制","~","重复","箭头","每秒","ui","global","extension","之后","参考","timestamp","链接","随意","文件","任意","效果",")","被","i","每隔","更新","/","world","自定","将","读出","python","圆点","_","中","官方","相应","通过","用例","chrome","双击","2","?","支持","发送","eim","陆续","呈现","称为","函数","浏览","依赖","逻辑","如何","建议","。","：","0","打开","3","firefox","，","或者","页面","web","hello","scratch3","连接","脚本","定义","extensions","加载","运行","多","如下","找到","time","返回","¶","触发","轻松","其他","默认","）","阶段","版本","sleep","4","一次","插件","使用","=","更"," ","时间","return","def","与","代码","修改","图中","源码","是","团队","拓展","角色","开启","消息","5","scratch3.0","能力","选择","所指","目前","最佳"],"title":"EIM Trigger","title_tokens":["trigger"," ","eim"]},{"location":"extension_guide/eim_trigger/#eim-trigger","text":"","text_tokens":[],"title":"EIM Trigger","title_tokens":["trigger"," ","eim"]},{"location":"extension_guide/eim_trigger/#_1","text":"通过 extension_eim_trigger 插件， Scratcher 可以轻松使用 Python 拓展 Scratch 的能力。 extension_eim_trigger 通过调用 ~/codelab_adapter/extensions/eim_trigger.py 脚本，往 Scratch 发送消息。 我们将其称为消息的触发机制( trigger )。 默认的脚本，每隔 1s，往 Scratch 中发送一次时间戳， 脚本源码 （简单的 Python 代码）为： import time def trigger (): timestamp = time . time () time . sleep ( 1 ) return timestamp 你可以随意修改 trigger 脚本代码，往 Scratch 中发送任意数据。","text_tokens":["称为","的","(","可以","py",":","机制","~","sleep","你","。","其","一次","scratcher","：","1","插件","我们","使用","，","简单","=","extension","（","数据"," ","trigger","时间","timestamp","随意","脚本","任意",")","往","每隔","def","return","extensions","/","将","代码","python","戳","_","import","中","修改","time","源码","scratch","拓展","通过",".","1s","为","codelab","调用","adapter","轻松","消息","触发","默认","能力","eim","发送","）"],"title":"插件介绍","title_tokens":["介绍","插件"]},{"location":"extension_guide/eim_trigger/#_2","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/eim_trigger/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/eim_trigger/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"extension_guide/eim_trigger/#3-extension_eim_trigger","text":"在 Web UI 中点击加载 extension_eim_trigger 插件","text_tokens":["ui","插件","加载","web","extension","在","_"," ","trigger","中","eim","点击"],"title":"步骤 3：加载 extension_eim_trigger 插件","title_tokens":["3","插件","步骤","加载","extension","_"," ","trigger","eim","："]},{"location":"extension_guide/eim_trigger/#4hello-world","text":"开启 extension_eim_trigger 插件后 选择对应的 Scratch3 插件：EIM 让 Scratch3 的角色读出每秒更新一次的时间戳：","text_tokens":["让","的","：","一次","每秒","插件","extension","scratch3"," ","trigger","时间","更新","读出","戳","_","后","对应","角色","开启","eim","选择"],"title":"步骤 4：hello world","title_tokens":["步骤","world","hello"," ","4","："]},{"location":"extension_guide/eim_trigger/#5-eim_trigger","text":"默认的逻辑是 每秒更新一次时间戳 ，相应代码为： import time def trigger (): timestamp = time . time () time . sleep ( 1 ) return timestamp 运行 extension_eim_trigger 插件后， trigger 函数会被重复调用，通过修改 trigger 函数的返回值，可以让 Scratch 中发送任意数据。 Help 如何找到 eim_trigger.py 文件? ~/codelab_adapter/extensions/eim_trigger.py","text_tokens":["让","的","(","可以","py",":","函数","逻辑","sleep","如何","重复","~","。","：","一次","每秒","1","插件","，","=","extension","help","数据"," ","trigger","时间","timestamp","文件","被","任意",")","更新","def","return","extensions","/","返回值","代码","戳","运行","_","import","相应","修改","中","找到","后","time","是","scratch","通过",".","为","codelab","返回","调用","adapter","默认","?","发送","eim","会"],"title":"步骤 5：自定义 eim_trigger 逻辑","title_tokens":["定义","步骤","自定义","自定","5","逻辑","_"," ","trigger","eim","："]},{"location":"extension_guide/eim_trigger/#_3","text":"import time i = 0 def trigger (): global i i += 1 time . sleep ( 1 ) return i","text_tokens":["def",".","1","global","(","=",":","time","sleep","import"," ","trigger","+","i","0",")","return"],"title":"其他用例","title_tokens":["用例","其他"]},{"location":"extension_guide/eim_trigger/#_4","text":"使用 Python 拓展 Scratch 的能力","text_tokens":["的","使用","python"," ","能力","scratch","拓展"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/etoys/","text":"Etoys ¶ 介绍 ¶ Etoys 是: 一种教育工具，向孩子们传授强大的思想(powerful ideas) 丰富的媒体创作环境和可视化编程系统 开放系统，几乎适用于所有个人电脑 Etoys 的开发始于迪斯尼，由艾伦·凯（Alan Kay）主导，受 Seymour Papert 的 Logo 语言影响，支持建构主义学习。 开发团队包括：Scott Wallace、Ted Kaehler、John Maloney 和 Dan Ingalls。 极大影响了 Scratch（John Maloney 是 Scratch 的首席架构师） 截图 ¶ 接入 Adapter ¶ Etoys 的最后一次更新是 2012 年（5.0 版本）。 我们试图通过将其接入 Adatper，使其得到 Adapter 连接的整个生态：物联网、AI、开源硬件... 使 Etoys 强大的表达能力与新的技术融合。 思路 ¶ 接入的思路是\"hack\"。 Etoys与外部通信的方式并不多，在 百宝箱 里，仅发现了Scratch客户端，可以与外部通信。 于是我们通过将 Adapter 伪装成 Scratch 1.3，来与Etoys通信，消息流向是( Etoys->Adatper->Scratch3.0 ) 由于百宝箱里的 Scratch客户端是socket client，所以更复杂的通信也是可能的，但 Etoys->Adatper->Scratch3.0 是我自己的典型使用场景。 更多细节参考: Etoys 学习笔记: 与 Scratch 互操作 . 也欢迎你自己进行hack ：） 使用 ¶ 使用方式很简单，在Adapter 中开启 extension_socket_server 插件（如果不存在该插件，到 插件市场 下载即可），源码在 extension_socket_server.py 开启插件后，加载demo程序，并点击绿旗运行它。 Scratch-Etoys 之后在 Etoys 里使用 broadcask 积木 即可： 提醒 在使用具体积木时，需要先建立连接，点击 Etoys里Scratch客户端即可，如果连接顺利，猫的眼睛会睁开。 以下是一个简单的例子： 使用Etoys里的按钮打开本地目录和CodeLab主页，背后利用到了 Adapter Python Extension的能力: 一切都是消息！ Etoys 与 Scratch 对比 ¶ Scratch适合入门，它通过给定清晰的结构，提供更多确定性，让入门变得容易（不必担心搞乱环境）。 随着项目变得更复杂，Etoys是更理想的选择，因其拥有继承自Smalltalk的强大环境和表达能力，惊人的一致性，彻底的面向对象，随着项目逐渐生长，复杂度总是在可控的范围内(因为消息-对象隐喻）。 随着项目变得复杂，Scratch用户需要掌握越来越多的“技巧”，编程成为一件搜罗和记忆许多技巧（特例）的乏味工作（就像传统计算机教育），环境无法提供更多的支持。 Etoys/Squeak 为“Scratch下一步是什么？”提供了理想的答案: Scratch -> Etoys -> Squeak(Smalltalk) 教育者 ¶ Alan Kay 和 Etoys社区围绕Etoys写了许多精彩的文章，推荐阅读。也许是有史以来关于向孩子传授 powerful ideas 最精彩的文章之一。 诸如: Squeak Etoys Authoring & Media Kedama: A GUI-based Interactive Massively Parallel Particle Programming System 更多文章可以从 Etoy resources 和 Viewpoints Research Institute 里找 进阶 ¶ 你可以参考 Etoys 学习笔记: 与 Scratch 互操作 自行构建功能更丰富的Server，使用 Adapter Node 将其接入Adapter生态。 参考 ¶ Etoys 学习笔记: 与 Scratch 互操作","text_tokens":["的","绿旗","一个","开发","典型","demo","最","融合","拥有","工具","适用","什么","scratch","通信","需要","为","institute","艾伦","得到","背后","新","随着","因为","装成","即可","让","-","生态","在","一步","市场","入门","media","dan","年","发现","extension","一种","惊人","生长","更新","可控","目录","伪装成","计算机","一致性","试图","复杂","场景","工作","首席","于是","john","方式","并","思路","面向对象","教育者","阅读","主义","构建","加载","！","传授","表达能力","¶","a","个人","百宝箱","自","插件","logo"," ","但","迪斯尼","到","开启","scratch3.0","算机","kedama","之一","内","socket","其","百宝","简单","利用","计算机教育","笔记","关于","越来",".","”","变得复杂","点击","睁开","可能","物","scott","定性","下载","硬件","建构",")","掌握","broadcask","来","有史以来","按钮","主导","、","支持","提醒","进阶","几乎","最后","架构师","总是","。","顺利","打开","一切","理想","文章","particle","细节","流向","ingalls","适合","搜罗","开源","以下","该","ted","向","wallace","自行","client","项目","）","电脑","围绕","提供","互操作","程序","etoy","确定","一次","操作","创作","resources","2012","5.0","与","找","丰富","建构主义","包括","消息","能力","选择","具体","孩子","表达","viewpoints","(","用户","可以","我","如果","精彩","客户端","kay","担心","ideas","massively","功能","隐喻","始于","不多","受","介绍","宝箱","面向","下","接入","1.3","powerful","py",":","papert","也许","parallel","programming","语言","之后","参考","诸如","和","interactive","/","将","存在","squeak","python","开放系统","_","中","从","通过","server","整个","记忆","眼睛","建立","强大","例子","：","主页","由","技巧","一致","极大","范围","？","运行","技术","系统","很","使","进行","截图","彻底","欢迎","里","不必","based","·","smalltalk","积木","更","node","并不多","由于","个人电脑","确定性","编程","影响","源码","环境","adatper","计算","们","学习","对象","答案","猫","“","时","所以","你","继承","乏味","给定","我们","就",">","（","system","复杂度","特例","于","逐渐","社区","结构","媒体","后","成为","codelab","了","adapter","所有","会","maloney","本地","seymour","ai","\"","开放","搞乱","客户","alan","可视化","自己","hack","...","许多","联网","架构","外部","越来越","gui","一切都是","教育","无法","也","推荐","，","传统","authoring","连接","一件","可视","多","因","变得","kaehler","写","版本","&","对比","像","伪装","使用","清晰","它","仅","先","etoys","以来","不","是","团队","research","凯","思想","容易"],"title":"Etoys","title_tokens":["etoys"]},{"location":"extension_guide/etoys/#etoys","text":"","text_tokens":[],"title":"Etoys","title_tokens":["etoys"]},{"location":"extension_guide/etoys/#_1","text":"Etoys 是: 一种教育工具，向孩子们传授强大的思想(powerful ideas) 丰富的媒体创作环境和可视化编程系统 开放系统，几乎适用于所有个人电脑 Etoys 的开发始于迪斯尼，由艾伦·凯（Alan Kay）主导，受 Seymour Papert 的 Logo 语言影响，支持建构主义学习。 开发团队包括：Scott Wallace、Ted Kaehler、John Maloney 和 Dan Ingalls。 极大影响了 Scratch（John Maloney 是 Scratch 的首席架构师）","text_tokens":["的","(","开发","（","于","kay","工具","ideas","适用","媒体","始于","scratch","受","了","艾伦","所有","maloney","powerful","seymour",":","papert","scott","开放","dan","语言","建构","一种","和",")","alan","可视化","开放系统","主导","、","支持","几乎","强大","首席","架构","架构师","john","。","：","教育","，","由","主义","ingalls","可视","极大","系统","传授","ted","向","wallace","kaehler","）","电脑","个人","·","logo","创作"," ","个人电脑","编程","迪斯尼","etoys","丰富","影响","是","环境","团队","凯","思想","建构主义","包括","们","学习","孩子"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/etoys/#_2","text":"","text_tokens":[],"title":"截图","title_tokens":["截图"]},{"location":"extension_guide/etoys/#adapter","text":"Etoys 的最后一次更新是 2012 年（5.0 版本）。 我们试图通过将其接入 Adatper，使其得到 Adapter 连接的整个生态：物联网、AI、开源硬件... 使 Etoys 强大的表达能力与新的技术融合。","text_tokens":["联网","的","版本","生态","ai","物","。","其","一次","：","我们","年","，","硬件","（"," ","连接","融合","2012","更新","5.0","开源","etoys","将","与","技术","是","adatper","通过","表达能力","试图","、","使","adapter","整个","得到","...","能力","新","接入","）","表达","最后","强大"],"title":"接入 Adapter","title_tokens":["adapter","接入"," "]},{"location":"extension_guide/etoys/#_3","text":"接入的思路是\"hack\"。 Etoys与外部通信的方式并不多，在 百宝箱 里，仅发现了Scratch客户端，可以与外部通信。 于是我们通过将 Adapter 伪装成 Scratch 1.3，来与Etoys通信，消息流向是( Etoys->Adatper->Scratch3.0 ) 由于百宝箱里的 Scratch客户端是socket client，所以更复杂的通信也是可能的，但 Etoys->Adatper->Scratch3.0 是我自己的典型使用场景。 更多细节参考: Etoys 学习笔记: 与 Scratch 互操作 . 也欢迎你自己进行hack ：）","text_tokens":["的","于是","-","方式","(","互操作","可以","可能","里","在","所以",":","外部","socket","欢迎","思路","你","进行","\"","。","典型","：","百宝","我","操作","伪装","我们","也","使用","，","发现","客户端",">","更","笔记","参考","细节"," ","并不多","流向","由于","客户",")","但","仅","etoys","将","与","来","自己","多","伪装成","不多","hack","是","scratch","通信","adatper","通过","场景",".","了","adapter","消息","宝箱","scratch3.0","复杂","学习","client","接入","）","装成","1.3","百宝箱"],"title":"思路","title_tokens":["思路"]},{"location":"extension_guide/etoys/#_4","text":"使用方式很简单，在Adapter 中开启 extension_socket_server 插件（如果不存在该插件，到 插件市场 下载即可），源码在 extension_socket_server.py 开启插件后，加载demo程序，并点击绿旗运行它。 Scratch-Etoys 之后在 Etoys 里使用 broadcask 积木 即可： 提醒 在使用具体积木时，需要先建立连接，点击 Etoys里Scratch客户端即可，如果连接顺利，猫的眼睛会睁开。 以下是一个简单的例子： 使用Etoys里的按钮打开本地目录和CodeLab主页，背后利用到了 Adapter Python Extension的能力: 一切都是消息！","text_tokens":["绿旗","的","时","一个","socket","demo","如果","简单","利用","客户端","（","后","scratch","需要",".","codelab","adapter","了","背后","会","点击","睁开","即可","-","本地","py",":","在","市场","下载","extension","之后","客户","和","broadcask","存在","目录","python","_","按钮","中","server","提醒","眼睛","建立","方式","并","例子","。","：","一切都是","顺利","打开","一切","，","主页","连接","加载","运行","以下","！","该","很","）","里","程序","插件","使用","积木"," ","它","先","etoys","不","到","源码","是","开启","消息","能力","具体","猫"],"title":"使用","title_tokens":["使用"]},{"location":"extension_guide/etoys/#etoys-scratch","text":"Scratch适合入门，它通过给定清晰的结构，提供更多确定性，让入门变得容易（不必担心搞乱环境）。 随着项目变得更复杂，Etoys是更理想的选择，因其拥有继承自Smalltalk的强大环境和表达能力，惊人的一致性，彻底的面向对象，随着项目逐渐生长，复杂度总是在可控的范围内(因为消息-对象隐喻）。 随着项目变得复杂，Scratch用户需要掌握越来越多的“技巧”，编程成为一件搜罗和记忆许多技巧（特例）的乏味工作（就像传统计算机教育），环境无法提供更多的支持。 Etoys/Squeak 为“Scratch下一步是什么？”提供了理想的答案: Scratch -> Etoys -> Squeak(Smalltalk)","text_tokens":["的","算机","(","“","用户","内","其","继承","乏味","给定","就","计算机教育",">","（","复杂度","特例","拥有","逐渐","担心","结构","隐喻","什么","成为","scratch","需要","越来","”","为","了","变得复杂","面向","下","因为","随着","让","-",":","在","一步","定性","入门","搞乱","惊人","和","生长",")","掌握","/","squeak","可控","计算机","通过","一致性","复杂","记忆","支持","许多","强大","工作","越来越","总是","。","教育","无法","理想","，","面向对象","传统","技巧","一致","一件","适合","搜罗","范围","？","多","因","表达能力","变得","项目","）","提供","彻底","确定","不必","像","自","smalltalk","更","清晰"," ","它","确定性","编程","etoys","是","环境","计算","消息","能力","选择","对象","答案","表达","容易"],"title":"Etoys 与 Scratch 对比","title_tokens":["etoys","与"," ","对比","scratch"]},{"location":"extension_guide/etoys/#_5","text":"Alan Kay 和 Etoys社区围绕Etoys写了许多精彩的文章，推荐阅读。也许是有史以来关于向孩子传授 powerful ideas 最精彩的文章之一。 诸如: Squeak Etoys Authoring & Media Kedama: A GUI-based Interactive Massively Parallel Particle Programming System 更多文章可以从 Etoy resources 和 Viewpoints Research Institute 里找","text_tokens":["powerful","的","-","viewpoints","kedama","可以","之一",":","里","&","gui","etoy","也许","based","。","media","parallel","programming","推荐","精彩","，","更","文章","system","particle","最"," ","authoring","阅读","诸如","resources","和","interactive","kay","关于","alan","社区","ideas","etoys","squeak","有史以来","找","massively","多","以来","从","传授","是","research","institute","了","向","写","a","孩子","许多","围绕"],"title":"教育者","title_tokens":["教育者","教育"]},{"location":"extension_guide/etoys/#_6","text":"你可以参考 Etoys 学习笔记: 与 Scratch 互操作 自行构建功能更丰富的Server，使用 Adapter Node 将其接入Adapter生态。","text_tokens":["的","生态","互操作","可以",":","你","。","其","操作","使用","，","笔记","更","node","参考"," ","构建","etoys","将","与","功能","丰富","scratch","server","adapter","自行","学习","接入"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/etoys/#_7","text":"Etoys 学习笔记: 与 Scratch 互操作","text_tokens":["操作","互操作","etoys","笔记",":","与","学习"," ","scratch"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/extension_market/","text":"Extension Market ¶ CodeLab Adapter 3.0 有一个统一的插件市场，可以方便下载到新的插件，就像我们在 vscode 或 sublime text 里的体验的那种插件系统，有个体面的 UI，而不是使用 curl 或者 wget 去 github 里手动下载。 作为演示我们下载了插件市场里的一个番茄工作法插件，这个插件的功能很简单(源码也是公开的): 每 25 分钟提醒编程者起来看看窗外风景。 下载完成之后，不需要重启软件，即可在 Scratch 和 Web UI 中看到新下载的插件，点击运行它：每 25 分钟，你就会收到一条信息提示你做个短途休息。 提交自定义插件到插件市场 ¶ 只需要将你自定义的 Adapter Extension 或者 Adapter Node 提交到 codelab_adapter_extensions , 提交合并之后，它将出现在插件市场中。 提醒 3.1.0 版本增加了对 Adapter Node 的支持。Adapter Node 脚本可以托管在互联网的任何位置。 这是目前所有可用的插件都在： codelab_adapter_extensions 。源码以 GPL 协议开放。研究与学习可以随意使用它。 codelab.club 内部在使用的一些插件近期也在整理源码，将陆续开放出来。欢迎大家一起改进它们。 你可以用这些插件将 Scratch 3.0/blockly: 接入 Python kernel 接入四轴飞行器 接入 Cozmo/Vector 接入任何用 Python 写的 AI 程序 接入眼动仪 接入 Minecraft 接入 blender ……","text_tokens":[",","飞行","的","一条","(","可以","一个","看到","提示","你","我们","就","简单","软件","自定义","近期","眼动仪","kernel","club","做","重启","用","一起","短途","内部","功能","blender","体面","这些","需要","scratch","番茄",".","去","codelab","作为","adapter","了","market","25","以","新","会","所有","点击","接入","sublime","即可","这是",":","在","看看","ai","市场","gpl","开放","cozmo","或","改进","ui","不是","下载","大家","extension","之后","…","窗外","vector","随意","互联网","那种","和",")","/","自定","任何","将","有个","python","_","飞行器","curl","中","增加","整理","对","演示","只","公开","提醒","支持","陆续","工作","联网","它们","。","：","0","每","收到","也","，","或者","web","可用","完成","vscode","脚本","起来","位置","定义","extensions","互联","blockly","运行","系统","有","github","体验","很","统一","¶","而","合并","写","text","wget","版本","欢迎","里","程序","方便","信息","像","minecraft","分钟","托管","3.1","出现","插件","使用","法","node","者","四轴"," ","它","个","编程","手动","与","这个","提交","都","不","研究","协议","一些","到","源码","是","风景","3.0","学习","出来","休息","目前"],"title":"extension market","title_tokens":["extension"," ","market"]},{"location":"extension_guide/extension_market/#extension-market","text":"CodeLab Adapter 3.0 有一个统一的插件市场，可以方便下载到新的插件，就像我们在 vscode 或 sublime text 里的体验的那种插件系统，有个体面的 UI，而不是使用 curl 或者 wget 去 github 里手动下载。 作为演示我们下载了插件市场里的一个番茄工作法插件，这个插件的功能很简单(源码也是公开的): 每 25 分钟提醒编程者起来看看窗外风景。 下载完成之后，不需要重启软件，即可在 Scratch 和 Web UI 中看到新下载的插件，点击运行它：每 25 分钟，你就会收到一条信息提示你做个短途休息。","text_tokens":["的","一条","(","可以","一个","看到","提示","你","我们","就","简单","软件","做","重启","短途","功能","体面","scratch","需要","番茄","去","codelab","作为","adapter","了","25","新","会","点击","sublime","即可",":","在","看看","市场","或","ui","不是","下载","之后","窗外","那种","和",")","有个","curl","中","演示","公开","提醒","工作","。","：","每","收到","也","，","或者","web","完成","vscode","起来","运行","系统","有","github","体验","很","统一","而","text","wget","里","方便","信息","像","分钟","插件","使用","法","者"," ","它","个","编程","手动","这个","不","到","源码","是","风景","3.0","休息"],"title":"Extension Market","title_tokens":["extension"," ","market"]},{"location":"extension_guide/extension_market/#_1","text":"只需要将你自定义的 Adapter Extension 或者 Adapter Node 提交到 codelab_adapter_extensions , 提交合并之后，它将出现在插件市场中。 提醒 3.1.0 版本增加了对 Adapter Node 的支持。Adapter Node 脚本可以托管在互联网的任何位置。 这是目前所有可用的插件都在： codelab_adapter_extensions 。源码以 GPL 协议开放。研究与学习可以随意使用它。 codelab.club 内部在使用的一些插件近期也在整理源码，将陆续开放出来。欢迎大家一起改进它们。 你可以用这些插件将 Scratch 3.0/blockly: 接入 Python kernel 接入四轴飞行器 接入 Cozmo/Vector 接入任何用 Python 写的 AI 程序 接入眼动仪 接入 Minecraft 接入 blender ……","text_tokens":[",","飞行","的","可以","你","自定义","近期","眼动仪","kernel","club","用","一起","内部","blender","这些","需要","scratch",".","codelab","adapter","了","以","所有","接入","这是",":","在","ai","市场","gpl","开放","cozmo","改进","大家","extension","之后","…","vector","随意","互联网","/","自定","任何","将","python","_","飞行器","中","增加","整理","对","只","支持","提醒","陆续","联网","它们","。","：","0","也","，","或者","可用","脚本","位置","定义","extensions","互联","blockly","合并","写","版本","欢迎","程序","minecraft","托管","3.1","出现","插件","使用","node","四轴"," ","它","与","提交","都","研究","协议","一些","到","源码","3.0","学习","出来","目前"],"title":"提交自定义插件到插件市场","title_tokens":["定义","插件","自定义","自定","提交","市场","到"]},{"location":"extension_guide/extension_python_kernel/","text":"Python eval kernel ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：hello world ¶ 选择对应的 Scratch3 插件：Python 插件 在 Scratch Python 插件里使用 插件启停积木 启动 CodeLab Adapter Python 插件。 执行 Python 代码: Python 插件将以 eval 执行 Python 代码(只能执行表达式)，如果你想使用 exec ，文末有指导。 你可以在插件中添加新的类，来自定义新功能, 我们做了一个范例: PyHelper 源码 。你可以使用 PyHelper.open_url(\"https://www.codelab.club\") 来为 Scratch 引入打开网页的功能。 你甚至可以更进一步，在 Scratch 中自定义积木！不需要编程 JavaScript，通过 Python 来扩展 Scratch！让我们构建一个打开网页的积木（Scratch本身没有打开网页的功能）: 点击制作新的积木: 制作自定义积木， 添加输入项目 : url 参数. 接下来我们开始定义这个积木的功能，完成之后我们就可以使用它了 以上例子的功能是按下空格，打开 CodeLab 主页。 你可以在插件里添加更多的类似 PyHelper 的自定义类，来为 Scratch 引入更多新的能力，使用 Python 就行！ 延伸 ¶ 再来做一个例子， @HansonXie 给我写了封邮件，说想写一个extension或者node来进行文件存储，希望用Python来做，而不是Javascript。在此我写个简单例子 我们可以使用 Jupyterlab 编辑 extension_python.py . 在其中增加一个新的助手类，来负责存储文件 class StorageHelp : def save_text_to_file ( text , filename ): with open ( filename , \"w\" ): filename . write ( text ) 之后,将其添加到eval中（使其可用)。 eval ( code , { \"__builtins__\" : None }, { \"PyHelper\" : self . PyHelper , \"StorageHelp\" : StorageHelp () }) 完成后，重新勾选extension_python.py（stop and start，不需要重启 Adapter）。 此次，自定义的积木，包括两个参数：存储的文本(text) 和 文件名(filename) 提醒 注意文件名和内容都是字符串，有引号 \"xxxxx\" 点击运行新的积木, 在jupyterlab中，可以看到新创建的文件已经在 extensions 目录里 提醒 exec 可能带来各种安全风险，暂时将其从插件市场移走了。eval也更符合我们采用的 对象/消息 隐喻。 如果你确实需要exec，可以自行构建插件， 参考 python_exec.py 内置在 Adapter 里的 Python 插件以 eval 执行 Python 代码(只能执行表达式)，如果你希望以功能更轻大的 exec (可执行任何 Python 语句)执行 Python 代码，可以在 插件市场 里下载 extension_python_exec 插件 。 关于 eval 和 exec 的区别，参考: 深度辨析 Python 的 eval() 与 exec() What's the difference between eval, exec, and compile? 我们之没有将 extension_python_exec 内置在 Adapter 中，而是希望用户在需要时自行下载，因为它的功能过于强大，可能会带来一下风险，所以选择权交由使用者。强大的能力通常会伴随风险，当然我们不会做太多限制，由你决定：） 参考 ¶ 将 codelab-adapter 用作 Python 解释器","text_tokens":[",","的","一个","解释","上","看到","用者","内置","1","做","说明","伴随","这儿","说","选择权","制作","scratch","需要","编辑","为","更轻","限制","新","因为","勾选","已经","让","暂时","-","其设","在","一步","市场","太多","来自","extension","file","添加","过于","任何","目录","2","助手","陆续","xxxxx","深度","或者","页面","web","表达式","更进一步","可用","构建","！","如下","延伸","¶","而","而是","移走","插件","范例"," ","builtins","图中","到","scratch3.0","扩展","通常","其","执行","简单","kernel","club","重启","none","浏览器","关于","下来","现阶段",".","启动","and","本身","点击","小圆点","以上","可能","引号","下载","效果",")","来","按","想","增加","封","支持","提醒","其中","呈现","存储","}","依赖","建议","。","打开","3","不会","hello","scratch3","此","文本","save","开始","extensions","有","文末","确实","自行","解释器","项目","）","text","{","字符串","决定","class","只能","pyhelper","新创建","与","代码","包括","消息","定义新","能力","选择","目前","表达","创建","步骤","(","用户","可以","输入","如果","我","绿色","用","负责","内置在","功能","隐喻","甚至","对应","storagehelp","www","下","py",":","https","w","没有","箭头","就行","两个","不是","各种","之后","参考","文件","和","__","/","自定","将","注意","python","圆点","_","官方","中","从","空格","通过","chrome","?","filename","网页","compile","强大","之","再来","例子","：","给","difference","主页","由","to","运行","jupyterlab","使","默认","字符","参数","url","进行","阶段","文件名","里","更轻大","符合","积木","更","node","语句","what","eval","open","编程","安全","这个","源码","重新","对象","所指","最佳","时","安装","所以","with","你","指导","接下来","我们","就","自定义","类似","（","用作","'","正常","后","codelab","adapter","了","启停","以","会","区别","内容","exec","\"","s","ui","self","@","释器","一下","链接","类","带来","write","world","双击","当然","做太多","浏览","使用者","也","firefox","between","，","希望","完成","连接","接下","引入","stop","可","定义","多","hansonxie","新创","code","start","邮件","交由","写","版本","风险","辨析","使用","采用","javascript","它","def","进一步","达式","都","the","不","是","团队","写个","此次"],"title":"Python eval kernel","title_tokens":["eval"," ","kernel","python"]},{"location":"extension_guide/extension_python_kernel/#python-eval-kernel","text":"","text_tokens":[],"title":"Python eval kernel","title_tokens":["eval"," ","kernel","python"]},{"location":"extension_guide/extension_python_kernel/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/extension_python_kernel/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/extension_python_kernel/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"extension_guide/extension_python_kernel/#3hello-world","text":"选择对应的 Scratch3 插件：Python 插件 在 Scratch Python 插件里使用 插件启停积木 启动 CodeLab Adapter Python 插件。 执行 Python 代码: Python 插件将以 eval 执行 Python 代码(只能执行表达式)，如果你想使用 exec ，文末有指导。 你可以在插件中添加新的类，来自定义新功能, 我们做了一个范例: PyHelper 源码 。你可以使用 PyHelper.open_url(\"https://www.codelab.club\") 来为 Scratch 引入打开网页的功能。 你甚至可以更进一步，在 Scratch 中自定义积木！不需要编程 JavaScript，通过 Python 来扩展 Scratch！让我们构建一个打开网页的积木（Scratch本身没有打开网页的功能）: 点击制作新的积木: 制作自定义积木， 添加输入项目 : url 参数. 接下来我们开始定义这个积木的功能，完成之后我们就可以使用它了 以上例子的功能是按下空格，打开 CodeLab 主页。 你可以在插件里添加更多的类似 PyHelper 的自定义类，来为 Scratch 引入更多新的能力，使用 Python 就行！","text_tokens":[",","的","(","扩展","可以","一个","输入","你","指导","接下来","执行","如果","我们","就","自定义","类似","（","club","做","功能","下来","制作","甚至","scratch","需要","对应",".","启动","为","codelab","adapter","了","启停","www","以","新","本身","下","点击","让","以上",":","在","exec","https","一步","\"","没有","就行","来自","之后","类",")","添加","/","自定","将","来","按","python","_","中","想","空格","通过","网页","例子","。","：","打开","，","表达式","主页","更进一步","完成","scratch3","构建","接下","引入","开始","定义","多","！","有","文末","参数","url","项目","）","里","插件","使用","积木","更","范例","只能"," ","javascript","eval","它","pyhelper","open","编程","进一步","代码","达式","这个","不","源码","是","定义新","能力","选择","表达"],"title":"步骤 3：hello world","title_tokens":["3","步骤","world","hello"," ","："]},{"location":"extension_guide/extension_python_kernel/#_2","text":"再来做一个例子， @HansonXie 给我写了封邮件，说想写一个extension或者node来进行文件存储，希望用Python来做，而不是Javascript。在此我写个简单例子 我们可以使用 Jupyterlab 编辑 extension_python.py . 在其中增加一个新的助手类，来负责存储文件 class StorageHelp : def save_text_to_file ( text , filename ): with open ( filename , \"w\" ): filename . write ( text ) 之后,将其添加到eval中（使其可用)。 eval ( code , { \"__builtins__\" : None }, { \"PyHelper\" : self . PyHelper , \"StorageHelp\" : StorageHelp () }) 完成后，重新勾选extension_python.py（stop and start，不需要重启 Adapter）。 此次，自定义的积木，包括两个参数：存储的文本(text) 和 文件名(filename) 提醒 注意文件名和内容都是字符串，有引号 \"xxxxx\" 点击运行新的积木, 在jupyterlab中，可以看到新创建的文件已经在 extensions 目录里 提醒 exec 可能带来各种安全风险，暂时将其从插件市场移走了。eval也更符合我们采用的 对象/消息 隐喻。 如果你确实需要exec，可以自行构建插件， 参考 python_exec.py 内置在 Adapter 里的 Python 插件以 eval 执行 Python 代码(只能执行表达式)，如果你希望以功能更轻大的 exec (可执行任何 Python 语句)执行 Python 代码，可以在 插件市场 里下载 extension_python_exec 插件 。 关于 eval 和 exec 的区别，参考: 深度辨析 Python 的 eval() 与 exec() What's the difference between eval, exec, and compile? 我们之没有将 extension_python_exec 内置在 Adapter 中，而是希望用户在需要时自行下载，因为它的功能过于强大，可能会带来一下风险，所以选择权交由使用者。强大的能力通常会伴随风险，当然我们不会做太多限制，由你决定：）","text_tokens":[",","的","(","时","用户","可以","一个","所以","with","看到","你","通常","用者","其","内置","执行","我","如果","我们","简单","自定义","（","做","重启","none","'","伴随","用","关于","说","负责","内置在","功能","隐喻","选择权","后","需要","编辑",".","更轻","and","了","adapter","限制","storagehelp","以","新","会","区别","点击","因为","勾选","已经","暂时","内容","py","可能",":","在","exec","市场","w","\"","引号","两个","没有","s","不是","self","各种","@","下载","太多","extension","之后","file","一下","参考","文件","类","带来","和",")","添加","write","__","过于","/","自定","任何","将","来","注意","python","目录","_","中","想","增加","从","封","当然","?","做太多","filename","提醒","助手","其中","compile","xxxxx","强大","存储","}","之","再来","例子","使用者","。","：","深度","也","给","between","，","或者","表达式","difference","不会","希望","可用","完成","to","由","构建","此","文本","stop","可","save","定义","extensions","运行","jupyterlab","hansonxie","有","新创","使","code","确实","start","自行","而","而是","邮件","字符","交由","参数","写","移走","进行","{","text","）","文件名","里","字符串","风险","更轻大","符合","决定","class","辨析","插件","使用","积木","更","node","采用","只能","语句","what"," ","javascript","builtins","eval","它","open","pyhelper","def","新创建","安全","与","代码","达式","都","the","不","到","是","写个","包括","消息","重新","此次","对象","选择","能力","表达","创建"],"title":"延伸","title_tokens":["延伸"]},{"location":"extension_guide/extension_python_kernel/#_3","text":"将 codelab-adapter 用作 Python 解释器","text_tokens":["-","codelab","adapter","将","解释","释器","python","解释器"," ","用作"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/faceapi/","text":"Tutorial ¶ hello world","text_tokens":["world","¶","hello"," ","tutorial"],"title":"faceapi","title_tokens":["faceapi"]},{"location":"extension_guide/faceapi/#tutorial","text":"hello world","text_tokens":["world"," ","hello"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/ha/","text":"Tutorial ¶ hello world 参考 安装和配置 Home Assistant","text_tokens":["home","assistant","world","¶","安装","配置","hello","参考"," ","tutorial","和"],"title":"home assistant","title_tokens":[" ","home","assistant"]},{"location":"extension_guide/ha/#tutorial","text":"hello world 参考 安装和配置 Home Assistant","text_tokens":["home","assistant","world","安装","配置","hello","参考"," ","和"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/imageData/","text":"Tutorial ¶ 用于获取和设置舞台区数据，具体而言: 获取当前舞台图像、当前视频图像 这些数据的消费者包括: extension_stage.py node_physical_blocks2.py 获取/设置当前角色的自定义造型 demo ¶ 大多数的 physical blocks 项目都使用到了 获取当前视频图像 . 而以下项目使用到了 获取/设置当前角色的自定义造型 : 与 physical blocks 2.0 配合使用 ¶ 提醒 如果你想切换分辨率，Adapter的版本需要 >=3.7.4 , 或者到插件市场下载最新的physical blocks 2.0插件。 此外值得注意的是，分辨率越高，刷新率越慢（很大原因是因为传输的数据大造成的）","text_tokens":[",","的","最新","很大","你","demo","原因","大多","大","如果","自定义",">","（","获取","辨率","数据","tutorial","区","是因为","大多数","这些","需要",".","了","adapter","设置","因为","值得","py",":","市场","physical","下载","extension","越高","3.7","和","舞台","传输","/","自定","注意","此外","当前","_","造成","想","、","提醒","多数","分辨率","用于","消费者","刷新率","。","，","或者","刷新","造型","定义","切换","2.0","以下","消费","¶","值得注意","而","分辨","项目","）","图像","版本","配合","4","而言","插件","使用","=","node"," ","视频","blocks","与","都","到","是","角色","stage","blocks2","越慢","包括","具体"],"title":"imageData","title_tokens":["imagedata"]},{"location":"extension_guide/imageData/#tutorial","text":"用于获取和设置舞台区数据，具体而言: 获取当前舞台图像、当前视频图像 这些数据的消费者包括: extension_stage.py node_physical_blocks2.py 获取/设置当前角色的自定义造型","text_tokens":["图像","的","py",":","用于","消费者","physical","而言","自定义","，","extension","获取","node","数据"," ","造型","和","视频","舞台","区","定义","/","自定","当前","_","这些","消费",".","stage","blocks2","角色","、","包括","设置","具体"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/imageData/#demo","text":"大多数的 physical blocks 项目都使用到了 获取当前视频图像 . 而以下项目使用到了 获取/设置当前角色的自定义造型 :","text_tokens":["图像","的",":","physical","大多","使用","自定义","获取"," ","造型","项目","视频","blocks","定义","/","自定","当前","都","以下","大多数","到",".","角色","了","而","设置","多数"],"title":"demo","title_tokens":["demo"]},{"location":"extension_guide/imageData/#physical-blocks-20","text":"提醒 如果你想切换分辨率，Adapter的版本需要 >=3.7.4 , 或者到插件市场下载最新的physical blocks 2.0插件。 此外值得注意的是，分辨率越高，刷新率越慢（很大原因是因为传输的数据大造成的）","text_tokens":[",","的","版本","最新","很大","你","市场","4","刷新率","原因","。","physical","大","如果","插件","下载","，","或者",">","=","（","辨率","数据","刷新"," ","越高","3.7","blocks","传输","切换","2.0","注意","此外","是因为","造成","想","到","需要","是",".","越慢","值得","adapter","值得注意","分辨","提醒","因为","）","分辨率"],"title":"与 physical blocks 2.0 配合使用","title_tokens":["2.0","使用","配合","与"," ","physical","blocks"]},{"location":"extension_guide/introduction/","text":"Extension Guide ¶ 我们将在此介绍 CodeLab Adapter 各种插件的用法，我们已通过 CodeLab Adapter extension 将一些有趣的硬件和 AI 接入到了 scratch 3.0 中。 目前已接入的设备参考 主页 。 如果已有的插件中，没有你期待的，你可以使用 CodeLab Adapter extension 自行将喜欢的硬件或 AI 等系统接入 Scratch 3.0，参考 开发手册 。 也可以参考已有的例子，我们正在陆续把我们写的 extensions 放入 codelab_adapter_extensions ，欢迎 fork，欢迎分享 : )","text_tokens":["正在","的","用法","已有","可以","欢迎",":","在","ai","你","例子","没有","。","开发","或","如果","喜欢","我们","各种","插件","，","使用","主页","硬件","extension","也","参考"," ","此","和",")","fork","手册","分享","extensions","设备","将","_","等","放入","一些","guide","中","系统","把","到","scratch","期待","通过","codelab","有趣","¶","介绍","adapter","了","自行","3.0","已","写","目前","接入","陆续"],"title":"介绍(introduction)","title_tokens":["介绍",")","introduction","("]},{"location":"extension_guide/introduction/#extension-guide","text":"我们将在此介绍 CodeLab Adapter 各种插件的用法，我们已通过 CodeLab Adapter extension 将一些有趣的硬件和 AI 接入到了 scratch 3.0 中。 目前已接入的设备参考 主页 。 如果已有的插件中，没有你期待的，你可以使用 CodeLab Adapter extension 自行将喜欢的硬件或 AI 等系统接入 Scratch 3.0，参考 开发手册 。 也可以参考已有的例子，我们正在陆续把我们写的 extensions 放入 codelab_adapter_extensions ，欢迎 fork，欢迎分享 : )","text_tokens":["正在","的","用法","已有","可以","欢迎",":","在","ai","你","例子","没有","。","开发","或","如果","喜欢","我们","各种","插件","，","使用","主页","硬件","extension","也","参考"," ","此","和",")","fork","手册","分享","extensions","设备","将","_","等","放入","一些","中","系统","把","到","scratch","期待","通过","codelab","有趣","介绍","adapter","了","自行","3.0","已","写","目前","接入","陆续"],"title":"Extension Guide","title_tokens":["extension"," ","guide"]},{"location":"extension_guide/iot/","text":"Tutorial ¶ hello world","text_tokens":["world","¶","hello"," ","tutorial"],"title":"iot","title_tokens":["iot"]},{"location":"extension_guide/iot/#tutorial","text":"hello world","text_tokens":["world"," ","hello"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/json/","text":"Tutorial ¶ json 插件。 使用说明 ¶ 不允许将 Scratch 变量设置为字符串之外的东西。 如果你要讲来自Adapter的json数据存入Scratch变量，请先将数据序列化为字符串(json stringify)，以下是一个例子: Scratch-json-var","text_tokens":["的","-","(","一个",":","var","你","字符串","序列","例子","。","存入","东西","如果","插件","使用","，","来自","数据"," ","tutorial","说明","变量",")","先","将","以下","不","讲","json","是","scratch","请","允许","为","之外","序列化","¶","adapter","设置","字符","要","stringify"],"title":"json","title_tokens":["json"]},{"location":"extension_guide/json/#tutorial","text":"json 插件。","text_tokens":["。","json"," ","插件"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/json/#_1","text":"不允许将 Scratch 变量设置为字符串之外的东西。 如果你要讲来自Adapter的json数据存入Scratch变量，请先将数据序列化为字符串(json stringify)，以下是一个例子: Scratch-json-var","text_tokens":["的","-","(","一个",":","var","你","字符串","序列","例子","。","存入","东西","如果","，","来自","数据"," ","变量",")","先","将","以下","不","讲","json","是","scratch","请","允许","为","之外","序列化","adapter","设置","字符","要","stringify"],"title":"使用说明","title_tokens":["说明","使用"]},{"location":"extension_guide/jupyterlab/","text":"JupyterLab ¶ JupyterLab 是 jupyter notebook 的下一代产品。 Jupyter Notebook（前身是IPython Notebook）是一个基于Web的交互式计算环境。 如果你正在学习 Python/数据科学/人工智能，它是你绝佳的编程环境。 CodeLab Adapter 将其集成到插件，如果想编辑代码，诸如 编辑 CodeLab Adapter的配置文件 使用 Python 扩展 Scratch的能力 构建新插件 它都是我们推荐的工具。 或者任何时候你想学习 Python ，JupyterLab 都是你理想的伙伴。 Tutorial ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 运行 extention_jupyterlab 插件。 提醒 完整版已经内置了一切依赖。 如果你是有精简版，确保你已经 安装了 Python3 。 你不必手动安装 jupyterlab ，运行插件，CodeLab Adapter 会为你其余的一切。 当然你也可以在命令行里手动安装它。 步骤 2：使用 jupyterlab ¶ jupyterlab 默认将打开 Adapter主目录 。 Adapter主目录 存放有: 用户配置文件 extensions 目录（可以在此修改 extension 的行为（如 eim_monitor ,修改完后，重新勾选插件即可，不必重启 Adapter） nodes 目录（可以在此修改 Adapter Node 的行为，修改完后，重新勾选插件即可，不必重启 Adapter） jupyter notebooks (用于存放Python代码，你可以从这里开始你的Python之旅) 资源文件(诸如 webui 的 html 文件，你可以自由修改！) Adapter 运行日志，当你需要 调试 extension 时，查看日志将很有帮助。 你可以使用 jupyterlab 随意修改它们。别担心改坏了。如果发现修改后 Adapter无法正常运行。则将整个 Adapter 主目录 删除即可，重启 Adapter，你将得到一个崭新的 Adapter 主目录。它是为你学习而构建的环境，别担心玩坏它，尽情探索吧。","text_tokens":[",","的","步骤","扩展","(","用户","安装","一个","可以","时","别","伙伴","notebooks","你","extention","行为","ipython","其","内置","如果","探索","1","我们","（","notebook","数据","精简版","tutorial","之旅","重启","完整版","存放","运行日志","浏览器","正常","担心","工具","计算环境","后","scratch","需要","编辑","现阶段",".","为","启动","codelab","adapter","了","删除","完后","得到","尽情","新","勾选","已经","即可","其设","基于",":","在","会为","整版","时候","nodes","发现","之后","绝佳","extension","jupyter","文件","诸如","随意","改坏","效果",")","/","任何","将","python","目录","_","官方","想","从","吧","下一代","这里","chrome","其余","webui","配置","双击","当然","配置文件","2","整个","一代","支持","提醒","当","交互式","eim","查看","陆续","如","它们","崭新","html","浏览","依赖","用于","集成","建议","。","：","打开","无法","一切","推荐","理想","，","或者","firefox","web","也","前身","构建","确保","此","调试","开始","extensions","自由","运行","多","jupyterlab","产品","精简","！","命令","python3","monitor","有","资源","很","¶","默认","交互","而","则","人工","）","日志","阶段","正在","版本","里","玩坏","智能","不必","插件","使用","更","node"," ","它","编程","命令行","手动","代码","科学","人工智能","都","完整","修改","是","到","环境","团队","主目录","计算","帮助","重新","学习","能力","目前","最佳"],"title":"jupyterlab","title_tokens":["jupyterlab"]},{"location":"extension_guide/jupyterlab/#jupyterlab","text":"JupyterLab 是 jupyter notebook 的下一代产品。 Jupyter Notebook（前身是IPython Notebook）是一个基于Web的交互式计算环境。 如果你正在学习 Python/数据科学/人工智能，它是你绝佳的编程环境。 CodeLab Adapter 将其集成到插件，如果想编辑代码，诸如 编辑 CodeLab Adapter的配置文件 使用 Python 扩展 Scratch的能力 构建新插件 它都是我们推荐的工具。 或者任何时候你想学习 Python ，JupyterLab 都是你理想的伙伴。","text_tokens":["正在","的","扩展","基于","一个","伙伴","你","集成","时候","ipython","智能","。","其","如果","插件","我们","使用","，","推荐","或者","web","（","绝佳","理想","notebook","jupyter","数据"," ","前身","文件","诸如","构建","它","编程","/","工具","任何","将","计算环境","代码","python","科学","jupyterlab","产品","人工智能","都","想","是","到","环境","下一代","编辑","scratch","codelab","计算","adapter","配置","配置文件","交互","学习","一代","能力","交互式","新","人工","）"],"title":"JupyterLab","title_tokens":["jupyterlab"]},{"location":"extension_guide/jupyterlab/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/jupyterlab/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/jupyterlab/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 运行 extention_jupyterlab 插件。 提醒 完整版已经内置了一切依赖。 如果你是有精简版，确保你已经 安装了 Python3 。 你不必手动安装 jupyterlab ，运行插件，CodeLab Adapter 会为你其余的一切。 当然你也可以在命令行里手动安装它。","text_tokens":["的","安装","可以","里","浏览","依赖","会为","在","整版","你","extention","不必","。","内置","打开","如果","插件","一切","也","，","之后","精简版"," ","确保","完整版","它","浏览器","命令行","手动","将","运行","_","jupyterlab","完整","精简","是","命令","python3","有","启动","codelab","其余","双击","adapter","了","当然","默认","提醒","已经"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/jupyterlab/#2-jupyterlab","text":"jupyterlab 默认将打开 Adapter主目录 。 Adapter主目录 存放有: 用户配置文件 extensions 目录（可以在此修改 extension 的行为（如 eim_monitor ,修改完后，重新勾选插件即可，不必重启 Adapter） nodes 目录（可以在此修改 Adapter Node 的行为，修改完后，重新勾选插件即可，不必重启 Adapter） jupyter notebooks (用于存放Python代码，你可以从这里开始你的Python之旅) 资源文件(诸如 webui 的 html 文件，你可以自由修改！) Adapter 运行日志，当你需要 调试 extension 时，查看日志将很有帮助。 你可以使用 jupyterlab 随意修改它们。别担心改坏了。如果发现修改后 Adapter无法正常运行。则将整个 Adapter 主目录 删除即可，重启 Adapter，你将得到一个崭新的 Adapter 主目录。它是为你学习而构建的环境，别担心玩坏它，尽情探索吧。","text_tokens":[",","的","(","时","用户","可以","一个","别","notebooks","你","行为","如果","探索","（","之旅","重启","存放","运行日志","正常","担心","后","需要","为","adapter","了","删除","完后","得到","尽情","勾选","即可",":","在","nodes","发现","extension","jupyter","文件","诸如","随意","改坏",")","将","目录","python","_","从","吧","这里","webui","配置","整个","配置文件","查看","当","eim","如","它们","崭新","html","用于","。","打开","无法","，","构建","此","调试","开始","extensions","自由","运行","jupyterlab","！","monitor","有","资源","很","默认","而","则","）","日志","玩坏","不必","插件","使用","node"," ","它","代码","修改","是","主目录","环境","帮助","重新","学习"],"title":"步骤 2：使用 jupyterlab","title_tokens":["步骤","使用","2","jupyterlab"," ","："]},{"location":"extension_guide/knn/","text":"Tutorial ¶ hello world !!! 提醒 推荐使用 Teachable Machine , 目前已经部署在国内。","text_tokens":[",","!","teachable","推荐","使用","world","¶","在","部署","hello","。"," ","提醒","machine","tutorial","国内","目前","已经"],"title":"knn","title_tokens":["knn"]},{"location":"extension_guide/knn/#tutorial","text":"hello world !!! 提醒 推荐使用 Teachable Machine , 目前已经部署在国内。","text_tokens":[",","!","teachable","推荐","使用","world","在","部署","hello","。"," ","提醒","machine","国内","目前","已经"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/leapmotion/","text":"","text_tokens":[],"title":"leap motion","title_tokens":["leap","motion"," "]},{"location":"extension_guide/lidar/","text":"交互激光雷达 ¶ 将房间变成 Scratch 舞台区！","text_tokens":["激光","区","激光雷达","变成","¶","将","交互"," ","！","scratch","舞台","房间","雷达"],"title":"交互激光雷达","title_tokens":["激光","激光雷达","雷达","交互"]},{"location":"extension_guide/lidar/#_1","text":"将房间变成 Scratch 舞台区！","text_tokens":["区","变成","将"," ","！","scratch","舞台","房间"],"title":"交互激光雷达","title_tokens":["激光","激光雷达","雷达","交互"]},{"location":"extension_guide/microbit/","text":"Tutorial ¶ 提醒 microbit v2 用户，请使用这个 固件 。目前需要手动刷新，Adapter的下个版本我们将提供更好的支持。 提醒 microbit radio插件 与 usb microbit插件 不能同时使用. 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：连接 micro:bit，加载插件 ¶ 使用数据线将 micro:bit 接入电脑。 ps: Windows 7 用户注意，为了能发现并连接 micro:bit，需要 安装驱动 （和使用 mu-editor 操作相同） 在 CodeLab Adapter 中点击加载 usb micro:bit 插件: 如果你是第一次连接，会自动烧录固件（背面LED灯快速闪烁）。刷完之后，重新连接，连接之后，你应该看到 micro:bit 背后的信号灯高频闪烁，如果它没有高频闪烁，则按一下 micro:bit 背部的复位按钮 ps: linux 用户注意，scratch3_adapter 使用 usb 串口与 micro:bit 连接，linux 下，使用 usb 串口需要做权限设置： sudo chmod 666 /dev/ttyACM0 提醒 如果你遇到问题，可手动烧录 固件(v1) (保存文件到本地，并拖到 Microbit盘里)。 microbit v2 用户，请使用这个 固件 步骤 4：hello world ¶ 现在让我们利用 Scratch3 控制 micro:bit，让它在点阵屏上打印 hello world 选择对应的 Scratch3 插件：usb microbit。 选择对应拓展积木，点击运行 结语 ¶ 这个例子完整展示了 CodeLab Adapter 的使用流程 打开 CodeLab Adapter 打开 CodeLab Scratch3 接入你的设备（可以是任何开源硬件） 打开对应插件 选择对应拓展积木，在 Scratch 3.0 中与设备交互 如果你想接入的设备目前没有默认插件支持它，你可以自己来写，CodeLab Adapter 允许你将任何硬件接入 scratch 3.0 中，别害怕，需要的代码很少也很简单，详情参见 开发手册 。我们支持使用任何编程语言来写拓展，目前我们自己主要使用 Python。 我们也将在 extension guide 中介绍各种社区插件的使用方法。 !!! usb_Microbit_firmware.hex的源码 。 采用 python.microbit.org 生成hex","text_tokens":[",","的","步骤","(","用户","安装","可以","别","上","为了","看到","你","开发","如果","绿色","1","现在","我们","利用","简单","org","（","数据","做","tutorial","说明","bit","问题","浏览器","正常","这儿","radio","社区","设备","sudo","固件","应该","害怕","需要","scratch","现阶段",".","为","启动","对应","codelab","adapter","usb","了","参见","介绍","设置","背后","自动","刷","下","会","点击","接入","小圆点","让","-","本地","其设",":","在","led","复位","屏上","主要","第一次","没有","箭头","ttyacm0","ui","各种","语言","发现","硬件","之后","编程语言","一下","extension","灯","第一","链接","文件","效果","和",")","手册","/","更好","world","将","注意","按","任何","圆点","自己","按钮","_","来","python","官方","中","想","guide","背面","dev","chrome","双击","linux","2","背部","支持","提醒","陆续","呈现","展示","!","烧录","遇到","并","下个","依赖","浏览","保存","建议","例子","micro","。","microbit","：","打印","firmware","打开","3","也","firefox","，","或者","页面","web","数据线","hello","scratch3","刷新","连接","可","不能","方法","快速","开源","加载","运行","多","串口","如下","请","驱动","流程","权限","允许","很","信号","¶","结语","默认","交互","则","写","点阵","）","电脑","阶段","editor","提供","版本","7","4","一次","chmod","详情","操作","闪烁","插件","使用","很少","积木","hex","更","采用"," ","相同","v1","它","盘里","编程","能","666","手动","windows","与","代码","这个","完整","生成","图中","是","到","团队","拓展","v2","mu","源码","ps","重新","scratch3.0","3.0","完","高频","信号灯","拖","同时","选择","所指","目前","最佳","控制"],"title":"micro:bit","title_tokens":[":","bit","micro"]},{"location":"extension_guide/microbit/#tutorial","text":"提醒 microbit v2 用户，请使用这个 固件 。目前需要手动刷新，Adapter的下个版本我们将提供更好的支持。 提醒 microbit radio插件 与 usb microbit插件 不能同时使用.","text_tokens":["的","提供","版本","用户","下个","。","microbit","我们","插件","使用","，","刷新"," ","不能","radio","手动","更好","将","与","固件","这个","需要","请","v2",".","adapter","usb","支持","提醒","同时","目前"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/microbit/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/microbit/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/microbit/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"extension_guide/microbit/#3-microbit","text":"使用数据线将 micro:bit 接入电脑。 ps: Windows 7 用户注意，为了能发现并连接 micro:bit，需要 安装驱动 （和使用 mu-editor 操作相同） 在 CodeLab Adapter 中点击加载 usb micro:bit 插件: 如果你是第一次连接，会自动烧录固件（背面LED灯快速闪烁）。刷完之后，重新连接，连接之后，你应该看到 micro:bit 背后的信号灯高频闪烁，如果它没有高频闪烁，则按一下 micro:bit 背部的复位按钮 ps: linux 用户注意，scratch3_adapter 使用 usb 串口与 micro:bit 连接，linux 下，使用 usb 串口需要做权限设置： sudo chmod 666 /dev/ttyACM0 提醒 如果你遇到问题，可手动烧录 固件(v1) (保存文件到本地，并拖到 Microbit盘里)。 microbit v2 用户，请使用这个 固件","text_tokens":["的","(","用户","安装","为了","看到","你","如果","（","数据","做","bit","问题","sudo","固件","应该","需要","codelab","adapter","usb","设置","背后","自动","刷","下","会","点击","接入","-","本地",":","在","led","复位","第一次","没有","ttyacm0","发现","之后","一下","灯","第一","文件","和",")","/","将","注意","按","按钮","_","中","背面","dev","linux","背部","提醒","烧录","遇到","并","保存","micro","。","：","microbit","，","数据线","scratch3","连接","可","快速","加载","串口","驱动","请","权限","信号","则","）","电脑","editor","7","一次","chmod","操作","闪烁","插件","使用"," ","相同","v1","它","盘里","能","666","手动","windows","与","这个","是","到","v2","mu","ps","重新","完","高频","信号灯","拖"],"title":"步骤 3：连接 micro:bit，加载插件","title_tokens":["3","插件","步骤","，","加载",":","micro"," ","连接","：","bit"]},{"location":"extension_guide/microbit/#4hello-world","text":"现在让我们利用 Scratch3 控制 micro:bit，让它在点阵屏上打印 hello world 选择对应的 Scratch3 插件：usb microbit。 选择对应拓展积木，点击运行","text_tokens":["让","的",":","在","屏上","micro","。","：","打印","microbit","现在","我们","利用","插件","，","积木","hello","scratch3"," ","它","bit","world","运行","拓展","对应","usb","选择","点阵","点击","控制"],"title":"步骤 4：hello world","title_tokens":["步骤","world","hello"," ","4","："]},{"location":"extension_guide/microbit/#_2","text":"这个例子完整展示了 CodeLab Adapter 的使用流程 打开 CodeLab Adapter 打开 CodeLab Scratch3 接入你的设备（可以是任何开源硬件） 打开对应插件 选择对应拓展积木，在 Scratch 3.0 中与设备交互 如果你想接入的设备目前没有默认插件支持它，你可以自己来写，CodeLab Adapter 允许你将任何硬件接入 scratch 3.0 中，别害怕，需要的代码很少也很简单，详情参见 开发手册 。我们支持使用任何编程语言来写拓展，目前我们自己主要使用 Python。 我们也将在 extension guide 中介绍各种社区插件的使用方法。 !!! usb_Microbit_firmware.hex的源码 。 采用 python.microbit.org 生成hex","text_tokens":["的","可以","别","你","开发","如果","我们","简单","org","（","社区","设备","害怕","scratch","需要","对应",".","codelab","了","adapter","参见","介绍","usb","接入","在","主要","没有","各种","语言","硬件","编程语言","extension","手册","任何","将","自己","来","python","_","中","想","guide","支持","展示","!","例子","。","microbit","firmware","打开","也","，","scratch3","方法","开源","流程","很","允许","默认","交互","写","）","详情","插件","使用","很少","积木","hex","采用"," ","它","编程","与","代码","这个","完整","生成","是","源码","拓展","3.0","选择","目前"],"title":"结语","title_tokens":["结语"]},{"location":"extension_guide/microbit_radio/","text":"Tutorial ¶ 提醒 使用micro:bit v2的话，需要手动在 makecode 里刷入固件（推荐使用v1） micro:bit v1 和 micro:bit v2 的radio可以通信。 只能用于 makecode radio， makecode radio 与 micropython radio不兼容。 Adapter 3.7.4 支持切换 radio channel。 介绍 ¶ 我们在 CodeLab Adapter 深度连接 micro:bit （makecode）生态 中提到 我们将一块 micro:bit 接入电脑，用作中转站（类似 usb dongle），用于在 CodeLab Adapter 和任何 micro:bit 套件做中转站。这里的一个背景知识是，任何的 micro:bit 直接可以通过 radio（简易的无线连接）方便地彼此通信。 在这个思路中，获得的一个意外收获是：能让任何电脑与 microbit 无线连接！即便没有蓝牙！ ps：在这个教程中，需要准备 2 块 micro:bit。其中一块用作消息中转（暂且称其为 中转站 ），另一块用于实现项目功能（暂且称其为 功能板 ）。 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：hello MakeCode ¶ 从一个简单的例子开始： radio_node （ Adapter > 3.4 ） 将上述代码 download 到 功能板 (2 块 micro:bit 中的一块)。 上述代码的功能是: 当 功能板 收到来自 CodeLab Scratch 的消息时, 将在矩阵屏上显示出消息。 当 功能板 的 A 按钮 被按下时，发送字符 a , B 按钮 被按下时，发送字符 b （ microbit -> scratch ）， 当用力摇晃时，发送字符 shake 这样便完成了 Scratch--无线microbot 的双向通信: * `scratch -> microbit` * `microbit -> scratch` 注意 功能板收到的所有消息都是 字符串 步骤 2：拔下 功能板 ，接上 中转站 ，加载固件 ¶ 使用数据线将 中转站 micro:bit 接入电脑，刷入 固件 。 提醒 Windows 7用户注意，无法发现 micro:bit，需要 安装驱动 （和使用 mu-editor 操作相同） linux 用户注意，CodeLab Adapter 使用 usb 串口与 micro:bit 连接，linux 下，使用 usb 串口需要做权限设置： sudo chmod 666 /dev/ttyACM0 步骤 3：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 点击加载 extension_microbit_radio 插件 步骤 4：打开 Codelab Scratch3 ，构建自己的应用 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 在此展示一个简单例子：使用 A、B 按钮让角色出现和消失。你可以在线打开它 radio_hello_world_demo 总结 ¶ 根据以上的模版，加以调整，你可以自行构建自己的应用。 完整项目 ¶ fire！ ¶ 我们使用 micro:bit 来赋予淘宝上的普通魔杖以魔法。一共需要 3 个 micro:bit，一个用作中转站，一个用作可穿戴手表（micro:bit 绑在表带上），一个用作投石器。 当我们挥动魔杖时，触发投石器开关，fire！ 以下是源码 micro:bit 可穿戴设备源码 投石器源码 Scratch wand_catapult 我们来关注下以上 2 个 micro:bit 中信息的流向， 可穿戴设备，信息的流向是： micro:bit -> Scratch 投石器信息的流向为： Scratch -> micro:bit 提醒 运行项目时，记得把 CodeLab Adapter 运行起来。 Scratch 翻页笔 ¶ 硬件方面，使用了2个microbit: 作为翻页笔的手持的microbit: 固件 作为中转站(dongle)的microbit: 固件 它们之间基于 radio 通信（ micro:bit radio ） Scratch 程序参考 Scratch-翻页笔-demo.sb3","text_tokens":[",","的","便","步骤","(","时","用户","可以","一个","安装","应用","赋予","上","开关","wand","你","无线连接","知识","demo","绿色","1","我们","简单","类似",">","（","地","之间","提到","数据","用作","做","tutorial","说明","目前","bit","用力","浏览器","正常","这儿","dongle","radio","设备","sudo","固件","方面","功能","蓝牙","一共","需要","通信","scratch","现阶段",".","为","上述","兼容","codelab","启动","绑","作为","adapter","介绍","usb","了","手持","设置","以","下","所有","接入","点击","双向","加以","让","小圆点","-","生态","其设","以上","挥动",":","在","实现","屏上","石器","基于","3.4","双向通信","没有","穿戴","矩阵","箭头","ttyacm0","刷入","根据","b","ui","来自","发现","之后","extension","fire","硬件","翻页","参考","收获","链接","3.7","和","效果",")","被","普通","板","/","任何","world","将","按","注意","自己","圆点","来","_","按钮","获得","中","官方","从","dev","总结","通过","micropython","这里","chrome","、","linux","双击","2","支持","提醒","当","发送","记得","拔","淘宝","其中","陆续","块","出","呈现","展示","*","它们","摇晃","用于","依赖","浏览","调整","转站","makecode","思路","建议","例子","micro","。","中转站","：","microbit","打开","收到","3","关注","深度","无法","推荐","firefox","，","或者","数据线","web","页面","彼此","笔","hello","完成","scratch3","流向","连接","构建","此","直接","可","开始","起来","切换","接上","教程","加载","背景","运行","多","catapult","串口","以下","手表","`","！","把","如下","驱动","一块","权限","即便","魔法","¶","消失","带上","自行","触发","默认","中转","模版","在线","字符","a","项目","）","电脑","阶段","无线","download","投","暂且","editor","版本","里刷入","程序","魔杖","7","字符串","方便","4","信息","chmod","最佳","另","操作","出现","插件","使用","更","node","准备","只能","shake"," ","microbot","相同","v1","它","个","显示","channel","能","666","手动","windows","与","代码","这个","意外","都","不","完整","图中","是","到","团队","源码","v2","mu","角色","表","ps","的话","消息","scratch3.0","sb3","所指","套件","称其为","简易","这样"],"title":"micro:bit radio","title_tokens":["radio",":"," ","micro","bit"]},{"location":"extension_guide/microbit_radio/#tutorial","text":"提醒 使用micro:bit v2的话，需要手动在 makecode 里刷入固件（推荐使用v1） micro:bit v1 和 micro:bit v2 的radio可以通信。 只能用于 makecode radio， makecode radio 与 micropython radio不兼容。 Adapter 3.7.4 支持切换 radio channel。","text_tokens":["的","可以","里刷入",":","在","用于","makecode","4","micro","。","推荐","使用","，","（","只能"," ","3.7","v1","和","bit","channel","切换","radio","手动","与","固件","不","需要","通信","v2","micropython",".","兼容","的话","adapter","支持","提醒","）"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/microbit_radio/#_1","text":"我们在 CodeLab Adapter 深度连接 micro:bit （makecode）生态 中提到 我们将一块 micro:bit 接入电脑，用作中转站（类似 usb dongle），用于在 CodeLab Adapter 和任何 micro:bit 套件做中转站。这里的一个背景知识是，任何的 micro:bit 直接可以通过 radio（简易的无线连接）方便地彼此通信。 在这个思路中，获得的一个意外收获是：能让任何电脑与 microbit 无线连接！即便没有蓝牙！ ps：在这个教程中，需要准备 2 块 micro:bit。其中一块用作消息中转（暂且称其为 中转站 ），另一块用于实现项目功能（暂且称其为 功能板 ）。","text_tokens":["的","可以","一个","无线连接","知识","我们","类似","（","地","提到","用作","做","bit","dongle","radio","功能","蓝牙","需要","通信","codelab","adapter","usb","接入","让","生态",":","在","实现","没有","收获","和","板","任何","将","获得","中","通过","这里","2","其中","块","用于","转站","makecode","思路","micro","中转站","。","：","microbit","深度","，","彼此","连接","直接","教程","背景","！","一块","即便","中转","项目","）","电脑","无线","暂且","方便","另","准备"," ","能","与","这个","意外","是","ps","消息","套件","称其为","简易"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/microbit_radio/#_2","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/microbit_radio/#1hello-makecode","text":"从一个简单的例子开始： radio_node （ Adapter > 3.4 ） 将上述代码 download 到 功能板 (2 块 micro:bit 中的一块)。 上述代码的功能是: 当 功能板 收到来自 CodeLab Scratch 的消息时, 将在矩阵屏上显示出消息。 当 功能板 的 A 按钮 被按下时，发送字符 a , B 按钮 被按下时，发送字符 b （ microbit -> scratch ）， 当用力摇晃时，发送字符 shake 这样便完成了 Scratch--无线microbot 的双向通信: * `scratch -> microbit` * `microbit -> scratch` 注意 功能板收到的所有消息都是 字符串","text_tokens":[",","的","-","便","(","时","摇晃","*","一个",":","在","屏上","所有","字符串","3.4","例子","双向通信","micro","。","：","矩阵","microbit","b","收到","简单","，",">","来自","node","（","shake","完成"," ","microbot","被",")","bit","用力","显示","开始","板","radio","出","将","按","代码","注意","_","功能","按钮","都","`","从","中","到","是","scratch","通信","一块","这样","上述","codelab","adapter","消息","2","了","双向","字符","当","发送","下","a","）","download","块","无线"],"title":"步骤 1：hello MakeCode","title_tokens":["1","步骤","hello"," ","makecode","："]},{"location":"extension_guide/microbit_radio/#2","text":"使用数据线将 中转站 micro:bit 接入电脑，刷入 固件 。 提醒 Windows 7用户注意，无法发现 micro:bit，需要 安装驱动 （和使用 mu-editor 操作相同） linux 用户注意，CodeLab Adapter 使用 usb 串口与 micro:bit 连接，linux 下，使用 usb 串口需要做权限设置： sudo chmod 666 /dev/ttyACM0","text_tokens":["editor","-","用户","安装",":","7","转站","micro","。","中转站","：","chmod","刷入","ttyacm0","操作","无法","使用","，","数据线","发现","（","数据"," ","做","连接","相同","和","bit","666","/","windows","将","注意","固件","与","sudo","串口","dev","需要","驱动","mu","权限","codelab","linux","adapter","usb","中转","设置","提醒","下","接入","）","电脑"],"title":"步骤 2：拔下功能板，接上中转站，加载固件","title_tokens":["中转站","板","步骤","接上","，","加载","2","固件","中转","功能","转站"," ","下","拔","："]},{"location":"extension_guide/microbit_radio/#3-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 点击加载 extension_microbit_radio 插件","text_tokens":["浏览","。","microbit","打开","插件","，","之后","extension"," ","浏览器","radio","加载","将","_","启动","codelab","双击","adapter","默认","点击"],"title":"步骤 3：打开 Codelab Adapter","title_tokens":["3","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/microbit_radio/#4-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 在此展示一个简单例子：使用 A、B 按钮让角色出现和消失。你可以在线打开它 radio_hello_world_demo","text_tokens":[",","小圆点","呈现","的","展示","让","可以","一个",":","在","上","你","例子","demo","。","箭头","：","打开","b","绿色","出现","ui","简单","使用","或者","页面","web","hello","scratch3"," ","链接","说明","连接","此","和","它","正常","这儿","radio","world","将","与","圆点","按钮","_","如下","图中","角色","codelab","、","adapter","消失","scratch3.0","在线","所指","a","点击"],"title":"步骤 4：打开 Codelab Scratch3，构建自己的应用","title_tokens":["的","步骤","codelab","，","应用","自己","scratch3"," ","4","构建","：","打开"]},{"location":"extension_guide/microbit_radio/#_3","text":"根据以上的模版，加以调整，你可以自行构建自己的应用。","text_tokens":["的","，","以上","可以","应用","自己","自行","调整","模版","你","构建","。","根据","加以"],"title":"总结","title_tokens":["总结"]},{"location":"extension_guide/microbit_radio/#_4","text":"","text_tokens":[],"title":"完整项目","title_tokens":["项目","完整"]},{"location":"extension_guide/microbit_radio/#fire","text":"我们使用 micro:bit 来赋予淘宝上的普通魔杖以魔法。一共需要 3 个 micro:bit，一个用作中转站，一个用作可穿戴手表（micro:bit 绑在表带上），一个用作投石器。 当我们挥动魔杖时，触发投石器开关，fire！ 以下是源码 micro:bit 可穿戴设备源码 投石器源码 Scratch wand_catapult 我们来关注下以上 2 个 micro:bit 中信息的流向， 可穿戴设备，信息的流向是： micro:bit -> Scratch 投石器信息的流向为： Scratch -> micro:bit 提醒 运行项目时，记得把 CodeLab Adapter 运行起来。","text_tokens":["投","的","-","挥动","时","开关","一个",":","在","赋予","上","魔杖","石器","wand","转站","信息","micro","。","中转站","穿戴","：","关注","3","带上","我们","使用","，",">","（","fire"," ","用作","流向","bit","个","可","以上","起来","普通","设备","来","运行","_","catapult","以下","手表","！","一共","中","把","是","需要","源码","scratch","绑","表","为","魔法","codelab","adapter","触发","2","中转","记得","提醒","当","以","下","项目","淘宝","）"],"title":"fire！","title_tokens":["！","fire"]},{"location":"extension_guide/microbit_radio/#scratch","text":"硬件方面，使用了2个microbit: 作为翻页笔的手持的microbit: 固件 作为中转站(dongle)的microbit: 固件 它们之间基于 radio 通信（ micro:bit radio ） Scratch 程序参考 Scratch-翻页笔-demo.sb3","text_tokens":["的","-","(","它们","基于",":","程序","转站","micro","中转站","microbit","demo","笔","使用","，","硬件","（","之间","翻页","参考"," ",")","bit","个","dongle","radio","固件","方面","scratch","通信",".","作为","了","2","手持","中转","sb3","）"],"title":"Scratch 翻页笔","title_tokens":["翻页"," ","scratch","笔"]},{"location":"extension_guide/minecraft/","text":"Tutorial ¶ 插件说明 ¶ Windows 和 Mac 用户开箱可用。Linux用户将自动安装依赖 外部环境依赖 ¶ 需要配合 minecraft Pi edition 或者 raspberryjuice 使用。 开始使用 ¶ 运行 minecraft，使得 mcpi 能够接入minecraft，如果你不是使用树莓派，可能需要调整 插件源码 ， 细节参考 mcpi 文档。 启动 CodeLab Adapter，运行 node_minecraft 插件。 打开 Scratch 编程界面，我们已经制作了一个 demo: Scratch-mcTurtle (如果你打开出错，请清理浏览器缓存)， 你可以从这里起步，它是一个运行在Minecraft世界里的Turtle，它会出现在你周围 推荐你飞到空中(空格)去看它的运行轨迹。 如果你想做更多有趣的事，建议阅读 minecraft , 我们鼓励你去修改 插件源码 ，去支持更多的对象。欢迎把你的修改结果提交到 CodeLab 源码仓库，分享给社区里的其他人用 参考 ¶ Minecraft Minecraft API Minecraft Graphics Turtle Coding shapes in Minecraft Minecraft - Stuff Library TeachCraft https://projects.raspberrypi.org/en/projects/getting-started-with-minecraft-pi Python Coding for Minecraft mcpi minecraft-python","text_tokens":[",","的","(","用户","安装","外部环境","一个","可以","with","你","周围","demo","如果","stuff","我们","org","做","说明","tutorial","用","projects","getting","浏览器","社区","其他人","制作","需要","scratch",".","启动","去","codelab","for","adapter","了","graphics","它会","teachcraft","自动","接入","仓库","已经","en","-","可能",":","在","edition","https","鼓励","不是","他人","派","参考","pi","世界","和",")","/","将","python","_","从","想","空格","shapes","这里","raspberrypi","linux","缓存","支持","能够","浏览","依赖","调整","外部","建议","。","文档","打开","树莓","推荐","，","或者","给","可用","细节","阅读","raspberryjuice","library","开始","看","分享","运行","多","把","请","清理","¶","其他","使得","api","起步","飞到","出错","配合","turtle","欢迎","界面","里","结果","空中","minecraft","开箱","出现","插件","使用","in","更","node","轨迹"," ","事","它","编程","mcturtle","windows","mcpi","提交","started","修改","源码","是","环境","到","有趣","mac","对象","coding"],"title":"Minecraft","title_tokens":["minecraft"]},{"location":"extension_guide/minecraft/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/minecraft/#_1","text":"Windows 和 Mac 用户开箱可用。Linux用户将自动安装依赖","text_tokens":["用户","windows","linux","mac","将","可用","安装","依赖"," ","自动","。","和","开箱"],"title":"插件说明","title_tokens":["插件","说明"]},{"location":"extension_guide/minecraft/#_2","text":"需要配合 minecraft Pi edition 或者 raspberryjuice 使用。","text_tokens":["使用","配合","或者","edition"," ","pi","。","minecraft","需要","raspberryjuice"],"title":"外部环境依赖","title_tokens":["依赖","外部环境","环境","外部"]},{"location":"extension_guide/minecraft/#_3","text":"运行 minecraft，使得 mcpi 能够接入minecraft，如果你不是使用树莓派，可能需要调整 插件源码 ， 细节参考 mcpi 文档。 启动 CodeLab Adapter，运行 node_minecraft 插件。 打开 Scratch 编程界面，我们已经制作了一个 demo: Scratch-mcTurtle (如果你打开出错，请清理浏览器缓存)， 你可以从这里起步，它是一个运行在Minecraft世界里的Turtle，它会出现在你周围 推荐你飞到空中(空格)去看它的运行轨迹。 如果你想做更多有趣的事，建议阅读 minecraft , 我们鼓励你去修改 插件源码 ，去支持更多的对象。欢迎把你的修改结果提交到 CodeLab 源码仓库，分享给社区里的其他人用","text_tokens":[",","的","(","可以","一个","你","周围","demo","如果","我们","做","用","浏览器","社区","其他人","制作","需要","scratch","启动","去","codelab","adapter","了","它会","接入","仓库","已经","-","可能",":","在","鼓励","不是","他人","派","参考","世界",")","_","从","想","空格","这里","缓存","支持","能够","浏览","调整","建议","文档","。","打开","树莓","推荐","，","给","细节","阅读","看","分享","运行","多","把","请","清理","其他","使得","起步","飞到","出错","turtle","欢迎","界面","里","结果","空中","minecraft","出现","插件","使用","更","node","轨迹"," ","事","它","编程","mcturtle","mcpi","提交","修改","源码","是","到","有趣","对象"],"title":"开始使用","title_tokens":["开始","使用"]},{"location":"extension_guide/minecraft/#_4","text":"Minecraft Minecraft API Minecraft Graphics Turtle Coding shapes in Minecraft Minecraft - Stuff Library TeachCraft https://projects.raspberrypi.org/en/projects/getting-started-with-minecraft-pi Python Coding for Minecraft mcpi minecraft-python","text_tokens":["-","turtle",":","with","https","minecraft","stuff","org","in"," ","pi","library","projects","getting","/","python","mcpi","started","shapes",".","raspberrypi","for","graphics","teachcraft","api","coding","en"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/motion_sensor/","text":"Tutorial ¶ coding kit, for movers, shakers and makers. 注意 Windows 和 Mac 用户开箱可用。 使用方式: 到 插件市场 下载插件, 搜索 motion 插件类型: Adapter Node 插件源码: node_motionSensor_proximity.py 、 node_motionSensor_gesture.py 提醒 node_motionSensor_proximity 和 node_motionSensor_gesture 插件，分别对应 motion sensor 距离模式 和 手势模式。两个插件不能同时运行，当需要切换到另一个插件时，需要把当前正在运行的插件给停止了。 Demo ¶ Scratch-robomaster-motion-sensor.sb3","text_tokens":[",","正在","的","-","方式","时","用户","py","一个",":","robomaster","市场","demo","。","gesture","两个","开箱","手势","另","sensor","proximity","插件","距离","使用","下载","，","shakers","给","node","停止","movers","可用"," ","tutorial","和","motion","不能","搜索","motionsensor","切换","windows","注意","运行","当前","_","把","到","源码","需要","scratch","对应",".","模式","、","分别","for","¶","and","makers","mac","adapter","了","提醒","kit","同时","当","sb3","类型","coding"],"title":"kano motion sensor","title_tokens":["motion"," ","kano","sensor"]},{"location":"extension_guide/motion_sensor/#tutorial","text":"coding kit, for movers, shakers and makers. 注意 Windows 和 Mac 用户开箱可用。 使用方式: 到 插件市场 下载插件, 搜索 motion 插件类型: Adapter Node 插件源码: node_motionSensor_proximity.py 、 node_motionSensor_gesture.py 提醒 node_motionSensor_proximity 和 node_motionSensor_gesture 插件，分别对应 motion sensor 距离模式 和 手势模式。两个插件不能同时运行，当需要切换到另一个插件时，需要把当前正在运行的插件给停止了。","text_tokens":[",","正在","的","方式","时","用户","py","一个",":","市场","。","gesture","两个","开箱","手势","另","sensor","proximity","插件","距离","使用","下载","，","shakers","给","node","停止","movers","可用"," ","和","motion","不能","搜索","motionsensor","切换","windows","注意","运行","当前","_","把","到","源码","需要","对应",".","模式","、","分别","for","and","makers","mac","adapter","了","提醒","kit","同时","当","类型","coding"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/motion_sensor/#demo","text":"Scratch-robomaster-motion-sensor.sb3","text_tokens":["sensor",".","-","robomaster","sb3","motion","scratch"],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/mpfshell/","text":"mpfshell ¶ 文档参考： scratch3-eim-mpfshell mpfshell-lite","text_tokens":["lite","-","¶","scratch3","参考"," ","mpfshell","eim","文档","："],"title":"mpfshell(正在迁移中)","title_tokens":["正在","(","迁移","mpfshell","中",")"]},{"location":"extension_guide/mpfshell/#mpfshell","text":"文档参考： scratch3-eim-mpfshell mpfshell-lite","text_tokens":["lite","-","scratch3","参考"," ","mpfshell","eim","文档","："],"title":"mpfshell","title_tokens":["mpfshell"]},{"location":"extension_guide/neverland2/","text":"Neverland 2.0 ¶ demo3 原理 ¶ 项目包含以下部分: adapter master: 空间主节点，以 NEVERLAND_HUB 模式运行的Adapter,运行在树莓派上 adapter node: 空间功能节点，运行在树莓派上。在我们的视频里，有一个节点连接了makeymakey（makey node） user client: 运行在用户计算机上的 Adapter adapter master ¶ ADAPTER_MODE=3 ./codelab-adapter 关于 Adapter 的模式 adapter node ¶ python3 makey_node.py user client ¶ 正常运行Adapter即可","text_tokens":[",","即可","的","-","算机","用户","py","一个",":","在","里","上","。","部分","mode","hub","3","我们","树莓","，","=","node","（","派"," ","连接","视频","关于","正常","2.0","demo3","/","master","包含","运行","_","功能","以下","节点","user","计算机","python3","有","模式",".","makeymakey","codelab","makey","¶","adapter","了","计算","neverland","原理","主","以","client","项目","）","空间"],"title":"neverland2.0","title_tokens":["neverland2.0"]},{"location":"extension_guide/neverland2/#neverland-20","text":"demo3","text_tokens":["demo3"],"title":"Neverland 2.0","title_tokens":[" ","2.0","neverland"]},{"location":"extension_guide/neverland2/#_1","text":"项目包含以下部分: adapter master: 空间主节点，以 NEVERLAND_HUB 模式运行的Adapter,运行在树莓派上 adapter node: 空间功能节点，运行在树莓派上。在我们的视频里，有一个节点连接了makeymakey（makey node） user client: 运行在用户计算机上的 Adapter","text_tokens":[",","的","算机","用户","一个",":","在","里","上","。","部分","hub","我们","树莓","，","node","（","派"," ","连接","视频","master","包含","运行","_","功能","以下","节点","user","计算机","有","模式","makeymakey","makey","adapter","了","计算","neverland","主","以","client","项目","）","空间"],"title":"原理","title_tokens":["原理"]},{"location":"extension_guide/neverland2/#adapter-master","text":"ADAPTER_MODE=3 ./codelab-adapter 关于 Adapter 的模式","text_tokens":["模式","3",".","关于","-","codelab","的","/","adapter","=","_"," ","mode"],"title":"adapter master","title_tokens":["master","adapter"," "]},{"location":"extension_guide/neverland2/#adapter-node","text":"python3 makey_node.py","text_tokens":[".","makey","py","node","_"," ","python3"],"title":"adapter node","title_tokens":["adapter"," ","node"]},{"location":"extension_guide/neverland2/#user-client","text":"正常运行Adapter即可","text_tokens":["即可","adapter","正常","运行"],"title":"user client","title_tokens":["user"," ","client"]},{"location":"extension_guide/opencv/","text":"OpenCV ¶ 参考： 运行在树莓派中的 codelab-adapter opencv 插件 。","text_tokens":["的","-","树莓","codelab","opencv","插件","¶","adapter","在","运行","参考","派"," ","中","。","："],"title":"OpenCV(正在迁移中)","title_tokens":["正在","(","opencv","迁移","中",")"]},{"location":"extension_guide/opencv/#opencv","text":"参考： 运行在树莓派中的 codelab-adapter opencv 插件 。","text_tokens":["的","-","树莓","codelab","opencv","插件","adapter","在","运行","参考","派"," ","中","。","："],"title":"OpenCV","title_tokens":["opencv"]},{"location":"extension_guide/osc/","text":"OSC (Open Sound Control) ¶ 介绍 ¶ OSC (Open Sound Control) 是一种用于将声音合成器、计算机和其他多媒体设备联网的协议，用于音乐表演或表演控制等目的。OSC 的优势包括互操作性，准确性，灵活性以及增强的组织和文档。 最新版的 CodeLab Adapter( >= 3.7.1 )内置了 OSC 服务，端口为 12361 CodeLab Adapter即可充当 OSC server，又可充当 OSC client， 两类积木都提供了 积木说明 ¶ 例子 ¶ demo ¶ demo 源码 ¶ osc 手写板 如果你使用 IPhone 或者其他支持压力输入的屏幕，则可以通过按压力度控制画笔粗细。 操作说明 ¶ 下载 OSC 软件(演示视频里用的是 Syntien ), 将其配置到 Adapter OSC Server 上（ Adapter_IP:12361 ） 之后进入 interface，开始操作即可。 输出的 osc 信号将进入 Adapter，继而可以在 Scratch 的 OSC 积木中访问它。 一则 osc 消息由 2 部分构成: address(地址，类似 url) args（参数，是个 list）, 每一个参数的含义请参考具体 OSC 软件的文档说明 address 和 args 可以在具体 osc 软件中找到。 提醒 ¶ 一切都是消息！ OSC 相关软件推荐(client) ¶ 我目前最喜欢的 OSC client 是: Syntien Unipad Syntien ¶ Syntien 提供了丰富的控制面板 它甚至允许你自定义面板！ Unipad ¶ Unipad 提供多种游戏手柄界面，这些可以很好地跟Scratch项目结合！ OSC 如此高的刷新率，几乎没有任何延迟 进阶 ¶ 接入支持OSC的软件玩起来： * 音乐: [SonicPi](/extension_guide/sonicPi/) * AI：[Wekinator](http://www.wekinator.org/)","text_tokens":[",","延迟","的","算机","(","表演","可以","一个","最新","又","输入","上","你","demo","其","部分","内置","音乐","如果","最新版","1","继而","我","类似","软件","自定义",">","玩起来","（","地","org","control","address","最","说明","目前","用","跟","设备","unipad","多种","媒体","优势","构成","]","相关","合成器","甚至","scratch","这些","目的",".","为","codelab","list","了","介绍","adapter","活性","www","接入","即可","按压","制面",":","在","含义","ai","如此","没有","或","下载","成器","12361","之后","extension","ip","一种","参考","玩起","充当","3.7","灵活性","和",")","增强","新版","结合","/","自定","任何","将","_","输出","中","guide","计算机","灵活","通过","server","演示","声音","、","游戏","合成","配置","2","支持","提醒","进阶","interface","具体","手柄","几乎","iphone","联网","互操作性","*","用于","刷新率","例子","好","。","文档","一切都是","：","每","一切","推荐","，","或者","由","刷新","wekinator","可","开始","起来","定义","进入","等","服务","！","找到","sonicpi","请","很","允许","信号","¶","以及","访问","其他","多媒体","控制面板","则","参数","client","画笔","url","项目","）","面板","手写板","提供","两类","互操作","里","界面","一则","args","力度","[","操作","喜欢","准确性","使用","积木","=","组织","准确"," ","手写","高","视频","它","open","压力","个","屏幕","http","syntien","端口","粗细","都","丰富","协议","是","源码","到","计算","包括","消息","sound","操作性","地址","osc","控制"],"title":"OSC","title_tokens":["osc"]},{"location":"extension_guide/osc/#osc-open-sound-control","text":"","text_tokens":[],"title":"OSC (Open Sound Control)","title_tokens":["(","sound","control"," ","osc",")","open"]},{"location":"extension_guide/osc/#_1","text":"OSC (Open Sound Control) 是一种用于将声音合成器、计算机和其他多媒体设备联网的协议，用于音乐表演或表演控制等目的。OSC 的优势包括互操作性，准确性，灵活性以及增强的组织和文档。 最新版的 CodeLab Adapter( >= 3.7.1 )内置了 OSC 服务，端口为 12361 CodeLab Adapter即可充当 OSC server，又可充当 OSC client， 两类积木都提供了","text_tokens":["联网","互操作性","即可","的","算机","(","表演","互操作","两类","提供","用于","最新","又","。","文档","或","内置","音乐","操作","最新版","1","准确性","，","成器",">","=","组织","12361","积木","准确","一种","control"," ","充当","3.7","灵活性","和",")","open","可","增强","新版","端口","设备","将","媒体","优势","等","服务","都","协议","计算机","是","合成器","灵活","目的",".","为","server","声音","、","codelab","合成","计算","包括","以及","adapter","其他","多媒体","sound","操作性","了","活性","client","osc","控制"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/osc/#_2","text":"","text_tokens":[],"title":"积木说明","title_tokens":["积木","说明"]},{"location":"extension_guide/osc/#_3","text":"","text_tokens":[],"title":"例子","title_tokens":["例子"]},{"location":"extension_guide/osc/#demo","text":"","text_tokens":[],"title":"demo","title_tokens":["demo"]},{"location":"extension_guide/osc/#demo_1","text":"osc 手写板 如果你使用 IPhone 或者其他支持压力输入的屏幕，则可以通过按压力度控制画笔粗细。","text_tokens":["手写板","的","可以","按压","输入","你","力度","。","如果","使用","，","或者"," ","手写","压力","屏幕","粗细","画笔","通过","其他","支持","则","osc","控制","iphone"],"title":"demo 源码","title_tokens":[" ","源码","demo"]},{"location":"extension_guide/osc/#_4","text":"下载 OSC 软件(演示视频里用的是 Syntien ), 将其配置到 Adapter OSC Server 上（ Adapter_IP:12361 ） 之后进入 interface，开始操作即可。 输出的 osc 信号将进入 Adapter，继而可以在 Scratch 的 OSC 积木中访问它。 一则 osc 消息由 2 部分构成: address(地址，类似 url) args（参数，是个 list）, 每一个参数的含义请参考具体 OSC 软件的文档说明 address 和 args 可以在具体 osc 软件中找到。","text_tokens":[",","即可","的","(","可以","一个","里",":","在","上","一则","含义","args","。","其","部分","文档","每","操作","继而","下载","软件","，","积木","12361","（","之后","类似","由","ip","参考","address"," ","说明","和","视频",")","它","用","个","开始","syntien","将","进入","_","interface","构成","具体","输出","中","找到","是","到","scratch","请","server","演示","信号","配置","adapter","访问","消息","2","list","地址","参数","osc","url","）"],"title":"操作说明","title_tokens":["操作","说明"]},{"location":"extension_guide/osc/#_5","text":"一切都是消息！","text_tokens":["一切都是","消息","一切","！"],"title":"提醒","title_tokens":["提醒"]},{"location":"extension_guide/osc/#osc-client","text":"我目前最喜欢的 OSC client 是: Syntien Unipad","text_tokens":["喜欢","的","syntien","osc","unipad",":","最"," ","client","目前","是","我"],"title":"OSC 相关软件推荐(client)","title_tokens":["推荐","(","软件"," ","client","osc","相关",")"]},{"location":"extension_guide/osc/#syntien","text":"Syntien 提供了丰富的控制面板 它甚至允许你自定义面板！","text_tokens":["允许","的","定义","提供","syntien","自定义","自定","了","制面","甚至","你","控制面板"," ","丰富","！","它","控制","面板"],"title":"Syntien","title_tokens":["syntien"]},{"location":"extension_guide/osc/#unipad","text":"Unipad 提供多种游戏手柄界面，这些可以很好地跟Scratch项目结合！ OSC 如此高的刷新率，几乎没有任何延迟","text_tokens":["延迟","的","提供","可以","界面","刷新率","好","如此","没有","，","地","刷新"," ","高","跟","结合","任何","unipad","多种","！","这些","scratch","很","游戏","osc","项目","手柄","几乎"],"title":"Unipad","title_tokens":["unipad"]},{"location":"extension_guide/osc/#_6","text":"接入支持OSC的软件玩起来： * 音乐: [SonicPi](/extension_guide/sonicPi/) * AI：[Wekinator](http://www.wekinator.org/)","text_tokens":["的","*","(",":","ai","：","音乐","[","软件","org","玩起来","extension","玩起"," ","wekinator",")","起来","http","/","_","]","guide","sonicpi",".","支持","www","osc","接入"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/physical_blocks/","text":"Tutorial ¶ 介绍 ¶ 提醒 建议使用2.0版本: physical blocks 2.0 。 不久将弃用1.0版本。 使用 physical blocks，可以在一张桌子上对实物进行编程。 Windows 和 Mac 用户开箱可用。 Linux需要安装依赖（参考文末） 建议以 入门案例 为模版。 参考: CodeLab DynamicTable: A Seeing World CodeLab DynamicTable: 一个可实施的技术方案 积木介绍 ¶ 可以从 arucogen 查询 ArUco marker id Demo ¶ 入门案例 ¶ 分享两个入门案例: Scratch-marker-angle-demo.sb3 : 获取 marker 旋转角 Scratch-spell-demo.sb3 : 获取 marker id 列表(从左到右，从上到下) 更多案例 ¶ 第一期的直播演示项目 智能家居展厅 FAQ ¶ 如何打印 Marker ¶ 我们提供了一份30张的版本: 你可以从 arucogen 里打印（建议从编号1开始） 更多细节参考 CodeLab DynamicTable: 一个可实施的技术方案 默认的Marker只有50种, 想要更多怎么办 ¶ 默认是 4X4_50 (最多50种)的marker， 你可以选择 4x4_100 (最多100种)，或者 4x4_1000 (最多1000种) 选择之后请修改(推荐使用 JupyterLab )插件里对应的代码(104行): # aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_4X4_50) aruco_dict = cv2 . aruco . Dictionary_get ( cv2 . aruco . DICT_4X4_100 ) 关于不同的marker数量决定了字典的大小，越小的数字，鲁棒性越好。 考虑到大多数用户的场景，50个是够用的，所以我们默认采用50. Linux 用户 ¶ Linux 用户需要手动安装 opencv-contrib-python （有系统依赖）。 树莓派用户 ¶ 安装依赖系统 sudo apt-get install libjpeg-dev libtiff5-dev libjasper-dev libpng12-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt-get install libxvidcore-dev libx264-dev sudo apt install libatlas-base-dev sudo apt-get install qt4-dev-tools sudo apt-get install libhdf5-dev libhdf5-serial-dev libhdf5-103 之后安装 opencv-contrib-python pip3 install opencv-contrib-python==3.4.6.27","text_tokens":[",","的","(","用户","可以","安装","一个","小","所以","上","你","demo","libjasper","大多","1","我们","一张","（","获取","家居","tutorial","用","关于","sudo","libhdf5","libpng12","大多数","需要","scratch","对应",".","为","codelab","50","怎么","介绍","了","查询","marker","以","libavformat","contrib","-",":","在","spell","libtiff5","将弃","实施","3.4","一份","够用","入门","physical","两个","想要","install","一期","最多","之后","dictionary","实物","参考","第一","派","30","和",")","get","张","libavcodec","pip3","编号","world","python","_","从","apt","dev","第一期","对","考虑","展厅","演示","案例","linux","桌子","dict","arucogen","id","tools","提醒","场景","多数","上到","dynamictable","方案","依赖","列表","如何","建议","好","。","行","打印","100","推荐","树莓","，","直播","faq","或者","opencv","可用","角","libatlas","angle","#","细节","旋转","越","不同","libswscale","鲁棒性","可","开始","分享","2.0","数量","多","技术","只有","jupyterlab","103","系统","libv4l","qt4","请","104","有","1000","文末","¶","模版","默认","1.0","a","项目","进行","）","提供","版本","里","6.27","种","智能","决定","开箱","不久","字典","插件","aruco","使用","积木","更","=","serial","采用","seeing"," ","数字","blocks","个","编程","大小","libxvidcore","怎么办","手动","windows","cv2","代码","libx264","修改","是","4x4","到","从左到右","libjpeg","从上到下","base","mac","智能家居","sb3","选择"],"title":"physical blocks 1.0","title_tokens":["physical"," ","blocks","1.0"]},{"location":"extension_guide/physical_blocks/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/physical_blocks/#_1","text":"提醒 建议使用2.0版本: physical blocks 2.0 。 不久将弃用1.0版本。 使用 physical blocks，可以在一张桌子上对实物进行编程。 Windows 和 Mac 用户开箱可用。 Linux需要安装依赖（参考文末） 建议以 入门案例 为模版。 参考: CodeLab DynamicTable: A Seeing World CodeLab DynamicTable: 一个可实施的技术方案","text_tokens":["方案","的","版本","dynamictable","用户","可以","安装",":","在","依赖","上","将弃","一个","实施","建议","。","入门","physical","开箱","不久","使用","，","一张","（","可用","seeing","实物","参考"," ","和","blocks","用","编程","可","2.0","world","windows","技术","需要","对","为","codelab","文末","linux","桌子","案例","mac","模版","提醒","1.0","以","a","进行","）"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/physical_blocks/#_2","text":"可以从 arucogen 查询 ArUco marker id","text_tokens":["aruco","可以","arucogen","id","查询","marker"," ","从"],"title":"积木介绍","title_tokens":["积木","介绍"]},{"location":"extension_guide/physical_blocks/#demo","text":"","text_tokens":[],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/physical_blocks/#_3","text":"分享两个入门案例: Scratch-marker-angle-demo.sb3 : 获取 marker 旋转角 Scratch-spell-demo.sb3 : 获取 marker id 列表(从左到右，从上到下)","text_tokens":["-","(",":","spell","列表","demo","入门","两个","，","获取","角","angle"," ","旋转",")","分享","scratch","从左到右",".","案例","从上到下","id","marker","sb3","上到"],"title":"入门案例","title_tokens":["入门","案例"]},{"location":"extension_guide/physical_blocks/#_4","text":"第一期的直播演示项目 智能家居展厅","text_tokens":["展厅","的","演示","一期","直播","第一"," ","家居","智能","智能家居","项目","第一期"],"title":"更多案例","title_tokens":["更","案例","多"]},{"location":"extension_guide/physical_blocks/#faq","text":"","text_tokens":[],"title":"FAQ","title_tokens":["faq"]},{"location":"extension_guide/physical_blocks/#marker","text":"我们提供了一份30张的版本: 你可以从 arucogen 里打印（建议从编号1开始） 更多细节参考 CodeLab DynamicTable: 一个可实施的技术方案","text_tokens":["的","提供","版本","dynamictable","方案","可以","一个",":","里","实施","你","建议","一份","打印","1","我们","更","（","参考","细节"," ","30","可","张","开始","编号","多","技术","从","codelab","了","arucogen","）"],"title":"如何打印 Marker","title_tokens":["如何","marker","打印"," "]},{"location":"extension_guide/physical_blocks/#marker50","text":"默认是 4X4_50 (最多50种)的marker， 你可以选择 4x4_100 (最多100种)，或者 4x4_1000 (最多1000种) 选择之后请修改(推荐使用 JupyterLab )插件里对应的代码(104行): # aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_4X4_50) aruco_dict = cv2 . aruco . Dictionary_get ( cv2 . aruco . DICT_4X4_100 ) 关于不同的marker数量决定了字典的大小，越小的数字，鲁棒性越好。 考虑到大多数用户的场景，50个是够用的，所以我们默认采用50.","text_tokens":["的","(","小","可以","用户","里",":","所以","种","你","好","够用","行","决定","100","。","大多","字典","插件","推荐","使用","最多","，","或者","aruco","之后","=","我们","采用","#","dictionary","越"," ","不同","数字",")","鲁棒性","个","get","大小","关于","数量","cv2","代码","_","jupyterlab","修改","大多数","是","4x4","请","到","104","对应",".","考虑","1000","50","dict","了","默认","marker","选择","场景","多数"],"title":"默认的Marker只有50种, 想要更多怎么办","title_tokens":[",","的","怎么办","50","怎么","更","默认","多","种","marker","只有"," ","想要"]},{"location":"extension_guide/physical_blocks/#linux","text":"Linux 用户需要手动安装 opencv-contrib-python （有系统依赖）。","text_tokens":["contrib","-","手动","opencv","linux","用户","安装","（","依赖","python"," ","系统","。","）","需要","有"],"title":"Linux 用户","title_tokens":["linux","用户"," "]},{"location":"extension_guide/physical_blocks/#_5","text":"安装依赖系统 sudo apt-get install libjpeg-dev libtiff5-dev libjasper-dev libpng12-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt-get install libxvidcore-dev libx264-dev sudo apt install libatlas-base-dev sudo apt-get install qt4-dev-tools sudo apt-get install libhdf5-dev libhdf5-serial-dev libhdf5-103 之后安装 opencv-contrib-python pip3 install opencv-contrib-python==3.4.6.27","text_tokens":["contrib","-","安装","6.27","依赖","libtiff5","3.4","libjasper","install","opencv","=","serial","之后","libatlas"," ","libswscale","get","libavcodec","libxvidcore","pip3","sudo","libx264","python","libhdf5","libpng12","103","系统","apt","dev","libv4l","qt4",".","libjpeg","base","tools","libavformat"],"title":"树莓派用户","title_tokens":["用户","派","树莓"]},{"location":"extension_guide/physical_blocks2/","text":"Tutorial ¶ 介绍 ¶ physical blocks 2.0，新的更新我们都将在这个版本是进行， physical blocks 1.0 在未来将弃用。 使用 physical blocks，可以在一张桌子上对实物进行编程。 Windows 和 Mac 用户开箱可用。 Linux需要安装依赖（参考文末） 提醒 CodeLab Adapter版本 >= 3.7.3 参考: CodeLab DynamicTable: A Seeing World CodeLab DynamicTable: 一个可实施的技术方案 积木介绍 ¶ 可以从 arucogen 查询 ArUco marker id Demo ¶ 入门案例 ¶ 分享两个入门案例: physical-blocks2-angle-demo : 获取 marker 旋转角 physical-blocks2-spell-demo : 获取 marker id 列表(从左到右，从上到下) 更多案例 ¶ 第一期的直播演示项目 智能家居展厅 FAQ ¶ 刷新率/FPS ¶ 在 MacOS（2.3 GHz Intel Core i5）下，大约达到10帧的刷新率 目前尚未发布的 Pro 版本大约是 20 帧的刷新率 可使用以下技巧观察刷新率: 与1.0版本的区别？ ¶ 标记列表默认是字符串(序列化之后)，可以随意与scrath积木组合(诸如 xx包含xx 积木)，避免因为操作list引起的崩溃（诸如将list保存为变量）。 在2.0中，直到主动使用JSON parse积木解析后，它才称为列表。相关操作参考: json积木 ，也可参考前边的例子: physical-blocks2-spell-demo 此外2.0 只使用一个积木更新数据，提高标签存在的稳定性（也提高速度），其中一种典型的编程模式是: 在一次更新数据之后的积木都对应更新瞬间的视野状态。而不像1.0，每个积木都有各自瞬间的视野。 如何打印 Marker ¶ 我们提供了一份30张的版本: 你可以从 arucogen 里打印（建议从编号1开始） 更多细节参考 CodeLab DynamicTable: 一个可实施的技术方案 默认的Marker支持250种不同类型（marker id） ¶ 默认是 4X4_250 (最多250种)的marker， 你可以选择： 4x4_50 (最多50种) 4x4_250 (最多250种) 4x4_100 (最多100种) 4x4_1000 (最多1000种) 选择之后请修改(推荐使用 JupyterLab )插件里对应的代码(104行): # aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_4X4_250) aruco_dict = cv2 . aruco . Dictionary_get ( cv2 . aruco . DICT_4X4_1000 ) 关于不同的marker数量决定了字典的大小，越小的数字，鲁棒性越好。 Linux 用户 ¶ Linux 用户需要手动安装 opencv-contrib-python （有系统依赖）。 树莓派用户 ¶ 安装依赖系统 sudo apt-get install libjpeg-dev libtiff5-dev libjasper-dev libpng12-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt-get install libxvidcore-dev libx264-dev sudo apt install libatlas-base-dev sudo apt-get install qt4-dev-tools sudo apt-get install libhdf5-dev libhdf5-serial-dev libhdf5-103 之后安装 opencv-contrib-python pip3 install opencv-contrib-python==3.4.6.27","text_tokens":["的","(","用户","可以","安装","一个","大约","尚未","上","小","你","core","demo","2.3","典型","libjasper","1","我们","观察","一张",">","（","获取","pro","数据","家居","tutorial","用","关于","intel","sudo","libhdf5","libpng12","scrath","提高","后","相关","需要","模式",".","为","对应","codelab","list","50","介绍","adapter","每个","了","查询","marker","视野","新","下","区别","组合","因为","libavformat","contrib","-",":","在","spell","派","将弃","实施","序列","libtiff5","3.4","未来","定性","一份","入门","physical","两个","install","一期","最多","xx","之后","一种","实物","参考","第一","dictionary","随意","诸如","3.7","主动","和","变量",")","30","get","更新","张","libavcodec","好","pip3","编号","/","world","将","存在","包含","此外","python","_","从","中","apt","dev","第一期","对","展厅","演示","序列化","案例","linux","桌子","dict","arucogen","id","tools","只","支持","提醒","帧","250","其中","上到","称为","dynamictable","才","方案","依赖","保存","列表","如何","刷新率","fps","例子","标签","。","建议","打印","：","稳定性","100","行","3","标记","也","推荐","，","直播","faq","opencv","树莓","可用","角","libatlas","angle","#","刷新","旋转","细节","状态","不同","技巧","崩溃","越","libswscale","鲁棒性","可","ghz","开始","分享","2.0","数量","？","多","技术","以下","jupyterlab","103","系统","json","瞬间","libv4l","请","qt4","避免","有","104","1000","文末","¶","前边","默认","而","速度","字符","1.0","i5","a","项目","进行","）","类型","稳定","提供","版本","里","6.27","种","10","字符串","智能","像","决定","一次","开箱","直到","字典","操作","插件","aruco","使用","积木","=","更","serial","达到","seeing"," ","数字","它","blocks","编程","大小","libxvidcore","手动","各自","windows","与","代码","cv2","20","这个","libx264","都","不","引起","修改","是","4x4","从左到右","blocks2","libjpeg","从上到下","parse","mac","解析","base","智能家居","选择","目前","macos","发布"],"title":"physical blocks 2.0","title_tokens":["physical"," ","blocks","2.0"]},{"location":"extension_guide/physical_blocks2/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/physical_blocks2/#_1","text":"physical blocks 2.0，新的更新我们都将在这个版本是进行， physical blocks 1.0 在未来将弃用。 使用 physical blocks，可以在一张桌子上对实物进行编程。 Windows 和 Mac 用户开箱可用。 Linux需要安装依赖（参考文末） 提醒 CodeLab Adapter版本 >= 3.7.3 参考: CodeLab DynamicTable: A Seeing World CodeLab DynamicTable: 一个可实施的技术方案","text_tokens":["方案","的","版本","dynamictable","用户","可以","安装",":","在","依赖","上","将弃","一个","实施","未来","。","physical","开箱","3","我们","使用","，","一张",">","（","=","可用","seeing","实物","参考"," ","3.7","和","blocks","用","更新","编程","可","2.0","world","windows","将","这个","技术","都","是","需要","对",".","codelab","文末","linux","桌子","adapter","mac","提醒","1.0","新","a","进行","）"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/physical_blocks2/#_2","text":"可以从 arucogen 查询 ArUco marker id","text_tokens":["aruco","可以","arucogen","id","查询","marker"," ","从"],"title":"积木介绍","title_tokens":["积木","介绍"]},{"location":"extension_guide/physical_blocks2/#demo","text":"","text_tokens":[],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/physical_blocks2/#_3","text":"分享两个入门案例: physical-blocks2-angle-demo : 获取 marker 旋转角 physical-blocks2-spell-demo : 获取 marker id 列表(从左到右，从上到下)","text_tokens":["-","(",":","spell","列表","demo","入门","两个","physical","，","获取","角","angle"," ","旋转",")","分享","从左到右","blocks2","案例","从上到下","id","marker","上到"],"title":"入门案例","title_tokens":["入门","案例"]},{"location":"extension_guide/physical_blocks2/#_4","text":"第一期的直播演示项目 智能家居展厅","text_tokens":["展厅","的","演示","一期","直播","第一"," ","家居","智能","智能家居","项目","第一期"],"title":"更多案例","title_tokens":["更","案例","多"]},{"location":"extension_guide/physical_blocks2/#faq","text":"","text_tokens":[],"title":"FAQ","title_tokens":["faq"]},{"location":"extension_guide/physical_blocks2/#fps","text":"在 MacOS（2.3 GHz Intel Core i5）下，大约达到10帧的刷新率 目前尚未发布的 Pro 版本大约是 20 帧的刷新率 可使用以下技巧观察刷新率:","text_tokens":["的","版本","尚未","在","大约",":","10","core","刷新率","2.3","使用","，","观察","（","达到","pro","刷新"," ","技巧","可","ghz","intel","20","以下","macos","是","i5","帧","下","目前","）","发布"],"title":"刷新率/FPS","title_tokens":["刷新","刷新率","fps","/"]},{"location":"extension_guide/physical_blocks2/#10","text":"标记列表默认是字符串(序列化之后)，可以随意与scrath积木组合(诸如 xx包含xx 积木)，避免因为操作list引起的崩溃（诸如将list保存为变量）。 在2.0中，直到主动使用JSON parse积木解析后，它才称为列表。相关操作参考: json积木 ，也可参考前边的例子: physical-blocks2-spell-demo 此外2.0 只使用一个积木更新数据，提高标签存在的稳定性（也提高速度），其中一种典型的编程模式是: 在一次更新数据之后的积木都对应更新瞬间的视野状态。而不像1.0，每个积木都有各自瞬间的视野。","text_tokens":["的","(","可以","一个","demo","典型","（","数据","scrath","提高","后","相关","模式","对应","为","list","每个","视野","组合","因为","-",":","在","spell","序列","定性","physical","xx","之后","一种","参考","随意","诸如","主动","变量",")","更新","将","存在","包含","此外","中","序列化","只","其中","称为","才","保存","列表","例子","标签","。","稳定性","标记","也","，","状态","崩溃","可","2.0","json","瞬间","避免","有","前边","默认","而","速度","字符","1.0","）","稳定","字符串","像","一次","直到","操作","使用","积木"," ","它","编程","各自","与","都","不","引起","是","blocks2","parse","解析"],"title":"与1.0版本的区别？","title_tokens":["的","版本","与","？","1.0","区别"]},{"location":"extension_guide/physical_blocks2/#marker","text":"我们提供了一份30张的版本: 你可以从 arucogen 里打印（建议从编号1开始） 更多细节参考 CodeLab DynamicTable: 一个可实施的技术方案","text_tokens":["的","提供","版本","dynamictable","方案","可以","一个",":","里","实施","你","建议","一份","打印","1","我们","更","（","参考","细节"," ","30","可","张","开始","编号","多","技术","从","codelab","了","arucogen","）"],"title":"如何打印 Marker","title_tokens":["如何","marker","打印"," "]},{"location":"extension_guide/physical_blocks2/#marker250marker-id","text":"默认是 4X4_250 (最多250种)的marker， 你可以选择： 4x4_50 (最多50种) 4x4_250 (最多250种) 4x4_100 (最多100种) 4x4_1000 (最多1000种) 选择之后请修改(推荐使用 JupyterLab )插件里对应的代码(104行): # aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_4X4_250) aruco_dict = cv2 . aruco . Dictionary_get ( cv2 . aruco . DICT_4X4_1000 ) 关于不同的marker数量决定了字典的大小，越小的数字，鲁棒性越好。","text_tokens":["的","(","小","可以","里",":","种","你","好","行","：","100","决定","。","字典","插件","推荐","使用","最多","，","aruco","=","之后","#","dictionary","越"," ","不同","数字",")","鲁棒性","get","大小","关于","数量","cv2","代码","_","jupyterlab","修改","是","4x4","请","104","对应",".","1000","50","dict","了","默认","marker","250","选择"],"title":"默认的Marker支持250种不同类型（marker id）","title_tokens":["的","（","id","默认","种","marker","支持"," ","250","不同","）","类型"]},{"location":"extension_guide/physical_blocks2/#linux","text":"Linux 用户需要手动安装 opencv-contrib-python （有系统依赖）。","text_tokens":["contrib","-","手动","opencv","linux","用户","安装","（","依赖","python"," ","系统","。","）","需要","有"],"title":"Linux 用户","title_tokens":["linux","用户"," "]},{"location":"extension_guide/physical_blocks2/#_5","text":"安装依赖系统 sudo apt-get install libjpeg-dev libtiff5-dev libjasper-dev libpng12-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt-get install libxvidcore-dev libx264-dev sudo apt install libatlas-base-dev sudo apt-get install qt4-dev-tools sudo apt-get install libhdf5-dev libhdf5-serial-dev libhdf5-103 之后安装 opencv-contrib-python pip3 install opencv-contrib-python==3.4.6.27","text_tokens":["contrib","-","安装","6.27","依赖","libtiff5","3.4","libjasper","install","opencv","=","serial","之后","libatlas"," ","libswscale","get","libavcodec","libxvidcore","pip3","sudo","libx264","python","libhdf5","libpng12","103","系统","apt","dev","libv4l","qt4",".","libjpeg","base","tools","libavformat"],"title":"树莓派用户","title_tokens":["用户","派","树莓"]},{"location":"extension_guide/posenet/","text":"Tutorial ¶ hello world","text_tokens":["world","¶","hello"," ","tutorial"],"title":"posenet","title_tokens":["posenet"]},{"location":"extension_guide/posenet/#tutorial","text":"hello world","text_tokens":["world"," ","hello"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/python_exec/","text":"Python exec kernel ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 Python exec 插件不是内置插件，需要自行在 插件市场 下载。 exec 比 eval 更为强大（关于二者的区别参考 这儿 ） ，可以执行任何 Python 代码，你甚至可以在 Scratch 里构建木马病毒。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：hello world ¶ 选择对应的 Scratch3 插件：EIM. 在 Scratch 里使用 插件启停积木 启动 CodeLab Adapter Python exec 插件。 现在你可以运行任何Python代码了! 我们还是以打开浏览器为例, 可以直接运行: import webbrowser; webbrowser.open(\"https://www.codelab.club\") ， import 也是没问题的！ 提醒 广播的主题是 eim/extension_python_exec , extension_python_exec 正是插件的名字 延伸 ¶ python里能做的许多事情，现在你都可以在这个积木里做。让我们来做一些更复杂的事情。 让我们使用 Python 在Scratch里获取 CodeLab Adapter的最新版本，并让小猫🐱读出来 import requests latest_version_url = \"http://adapter.codelab.club/about/latest_version.json\" response = requests . get ( latest_version_url ) . json () print ( response [ \"version\" ]) 我们首先需要把这些代码变成单行代码， 可以使用 python single line convert 来做: 点击convert，开始转化，转化之后得到: exec(\"\"\"\\nimport requests\\nlatest_version_url = \"http://adapter.codelab.club/about/latest_version.json\"\\nresponse = requests.get(latest_version_url).json()\\nprint(response[\"version\"])\\n\"\"\") 运行它！ 完美！ 提醒 我们使用了一些奇技淫巧在Scratch里写大段 Python 代码， 仅仅是出于好玩和 because we can 的 geek 精神，通常更好的做法是将一些功能代码放在adapter 扩展文件里，而不是在Scratch 里写大段代码，那将是难以阅读和理解的。","text_tokens":[",","的","步骤","(","扩展","安装","可以","事情","上","最新","你","nresponse","通常","内置","奇技淫巧","执行","比","1","绿色","现在","我们","\\","because","（","kernel","获取","木马","club","精神","做","说明","问题","version","浏览器","关于","这儿","正常","print","出于","大段","import","功能","]","这些","甚至","scratch","需要","can","现阶段",".","为","启动","对应","codelab","仅仅","adapter","了","启停","那","得到","www","以","区别","点击","we","小圆点","让","其设",":","在","exec","https","市场","response","\"","木马病毒","箭头","ui","不是","下载","淫巧","难以","之后","extension","参考","链接","文件","效果","和",")","get","/","任何","world","将","来","🐱","读出","python","圆点","_","更好","官方","名字","chrome","变成","双击","首先","2","二者","复杂","n","支持","提醒","eim","完美","陆续","许多","nlatest","强大","呈现","!","转化","single","并","webbrowser","浏览","依赖","建议","。","：","打开","3",";","也","firefox","好玩","，","或者","页面","web","hello","scratch3","nimport","阅读","构建","连接","放在","直接","为例","requests","开始","做法","latest","运行","多","没","！","把","如下","json","广播","延伸","line","还是","¶","自行","默认","而","写","url","）","阶段","正是","geek","版本","主题","nprint","里","奇技","convert","[","插件","理解","使用","积木","更","=","病毒"," ","读出来","eval","它","open","http","about","能","与","代码","这个","都","一些","图中","更为","是","团队","小猫","单行","scratch3.0","出来","选择","所指","目前","最佳"],"title":"Python exec kernel","title_tokens":["exec"," ","kernel","python"]},{"location":"extension_guide/python_exec/#python-exec-kernel","text":"","text_tokens":[],"title":"Python exec kernel","title_tokens":["exec"," ","kernel","python"]},{"location":"extension_guide/python_exec/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/python_exec/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 Python exec 插件不是内置插件，需要自行在 插件市场 下载。 exec 比 eval 更为强大（关于二者的区别参考 这儿 ） ，可以执行任何 Python 代码，你甚至可以在 Scratch 里构建木马病毒。","text_tokens":["的","可以","里","浏览","在","exec","你","市场","。","木马病毒","内置","执行","打开","比","插件","不是","下载","，","之后","（","病毒","参考","木马"," ","构建","eval","浏览器","关于","这儿","任何","将","代码","python","更为","需要","甚至","scratch","启动","codelab","双击","adapter","自行","二者","默认","区别","）","强大"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/python_exec/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"extension_guide/python_exec/#3hello-world","text":"选择对应的 Scratch3 插件：EIM. 在 Scratch 里使用 插件启停积木 启动 CodeLab Adapter Python exec 插件。 现在你可以运行任何Python代码了! 我们还是以打开浏览器为例, 可以直接运行: import webbrowser; webbrowser.open(\"https://www.codelab.club\") ， import 也是没问题的！ 提醒 广播的主题是 eim/extension_python_exec , extension_python_exec 正是插件的名字","text_tokens":[",","!","的","正是","(","主题","可以","里","在","浏览",":","webbrowser","exec","你","https","\"","。","：","打开",";","现在","插件","我们","使用","，","积木","也","extension","scratch3","club"," ",")","直接","open","问题","为例","浏览器","/","任何","代码","python","运行","没","import","_","！","是","scratch","广播","名字","对应",".","启动","codelab","还是","adapter","了","启停","www","提醒","选择","eim","以"],"title":"步骤 3：hello world","title_tokens":["3","步骤","world","hello"," ","："]},{"location":"extension_guide/python_exec/#_2","text":"python里能做的许多事情，现在你都可以在这个积木里做。让我们来做一些更复杂的事情。 让我们使用 Python 在Scratch里获取 CodeLab Adapter的最新版本，并让小猫🐱读出来 import requests latest_version_url = \"http://adapter.codelab.club/about/latest_version.json\" response = requests . get ( latest_version_url ) . json () print ( response [ \"version\" ]) 我们首先需要把这些代码变成单行代码， 可以使用 python single line convert 来做: 点击convert，开始转化，转化之后得到: exec(\"\"\"\\nimport requests\\nlatest_version_url = \"http://adapter.codelab.club/about/latest_version.json\"\\nresponse = requests.get(latest_version_url).json()\\nprint(response[\"version\"])\\n\"\"\") 运行它！ 完美！ 提醒 我们使用了一些奇技淫巧在Scratch里写大段 Python 代码， 仅仅是出于好玩和 because we can 的 geek 精神，通常更好的做法是将一些功能代码放在adapter 扩展文件里，而不是在Scratch 里写大段代码，那将是难以阅读和理解的。","text_tokens":["的","(","扩展","可以","事情","最新","你","nresponse","通常","奇技淫巧","because","现在","我们","\\","获取","精神","club","做","version","print","大段","import","功能","]","这些","scratch","需要","can",".","codelab","仅仅","adapter","了","那","得到","we","点击","让",":","在","exec","response","\"","不是","淫巧","难以","之后","文件","和",")","get","/","🐱","更好","读出","来","将","python","_","变成","首先","复杂","n","提醒","完美","许多","nlatest","转化","single","并","。","好玩","，","nimport","阅读","放在","requests","开始","做法","latest","运行","把","！","json","line","而","写","url","geek","版本","nprint","里","奇技","convert","[","理解","使用","积木","更","="," ","读出来","它","http","about","能","代码","这个","都","一些","是","小猫","单行","出来","出于"],"title":"延伸","title_tokens":["延伸"]},{"location":"extension_guide/rpi_gpio/","text":"Tutorial ¶ 系统依赖参考 EIM 教程 。 操作树莓派 GPIO 的工具里， gpiozero 尤为出色，因其具有很好的可理解性， 图形化未必意味着更好的可理解性。 为了充分利用 gpiozero，决定只对它做一层薄薄的包装(REPL), 使其在 Scratch 中可用。 尤其适合于那些试图以 Python 去增强 Scratch 的人。 提醒 如果你在用 树莓派 4B， 建议更新一下wiringPi: wiringPi updated to 2.52 for the Raspberry Pi 4B 安装和配置 ¶ 参考 Installing GPIO Zero Raspbian 默认已经预装 gpiozero 。 你需要启动它: sudo systemctl start pigpiod 如果你计划在 PC 或 Mac上对树莓派 GPIO 进行编程， 需要 配置使其可被远程访问 。 同时你需要在本地安装: python -m pip install codelab_adapter_client gpiozero pigpio --user 我们推荐远程访问模式，这意味着，树莓派可以运行在局域网里的任何地方，而你可以在自己的电脑上使用 CodeLab Adapter 对它进行编程，如此一来，你可以把 Scratch 和 Adapter 的所有能力带给它。 当然你也可以在树莓派上运行 Adapter 和 Scratch。 提醒 在 Adapter 3.2 之前，你需要自行从 插件市场 里下载 raspberrypi 插件。 源码地址 树莓派默认地址为: raspberrypi.local , 如果你ping不通它，可以手动在插件里填写树莓派ip。 运行树莓派插件，打开 Scratch-rpi-gpiozero 。 提醒 如果你手头没有LED， 你可以 使用命令行工具 gpio ，观察引脚输出变化。 gpio用的mode是wPi，而gpiozero用的是BCM，所以pin17对应wpi的pin0 最后 ¶ 我们并不打算构建完备的积木组操控树莓派，树莓派高度灵活，难以完全积木化它的所有特性，那样不会提高可理解性。 我们希望用户灵活使用 Python 去增强 Scratch ，更好的扩展模式可以参考 Python eval kernel 。 当然一些功能是可以积木化的，期待你来提交 PR。 提醒 Raspbian Scratch 3 Desktop 也是个很好的选择，有丰富的积木。 CodeLab Adapter的目标是**连接**。 参考 ¶ gpio 测试工具 wiringPi updated to 2.52 for the Raspberry Pi 4B","text_tokens":[",","repl","的","pigpiod","(","扩展","用户","安装","可以","所以","为了","上","目标","你","引脚","gpiozero","其","mode","如果","pip","bcm","我们","利用","rpi","观察","化","pigpio","完备","未必","kernel","wiringpi","做","tutorial","用","意味着","gpio","于","化它","工具","sudo","出色","功能","提高","scratch","需要","模式",".","去","启动","为","codelab","对应","测试","for","充分利用","adapter","以","所有","充分","已经","-","raspberry","本地","那些","在",":","不通","led","局域","市场","如此","没有","如此一来","计划","性","或","install","一来","打算","填写","pr","下载","难以","一下","ip","参考","派","pi","一层","和",")","预装","被","wpi","更新","zero","地方","增强","m","更好","任何","自己","来","python","_","中","从","尤为","局域网","local","输出","期待","灵活","对","试图","raspberrypi","配置","当然","3.2","手头","raspbian","只","那样","提醒","eim","pin17","最后","*","薄薄","并","依赖","包装","systemctl","建议","好","高度","。","人","打开","3","也","树莓","推荐","，","不会","可用","希望","to","远程","变化","构建","连接","可","薄薄的","教程","适合","试工","这","运行","把","系统","操控","命令","有","因","具有","很","installing","使","¶","访问","start","自行","默认","而","client","2.52","带给","进行","电脑","意味","里","4b","分利","决定","之前","测试工具","操作","pin0","插件","理解","图形化","使用","积木","updated","ping"," ","pc","eval","它","个","编程","命令行","尤其","手动","组","提交","the","不","一些","丰富","图形","user","源码","是","完全","mac","desktop","地址","同时","能力","特性","选择"],"title":"RaspberryPi GPIO","title_tokens":["gpio"," ","raspberrypi"]},{"location":"extension_guide/rpi_gpio/#tutorial","text":"系统依赖参考 EIM 教程 。 操作树莓派 GPIO 的工具里， gpiozero 尤为出色，因其具有很好的可理解性， 图形化未必意味着更好的可理解性。 为了充分利用 gpiozero，决定只对它做一层薄薄的包装(REPL), 使其在 Scratch 中可用。 尤其适合于那些试图以 Python 去增强 Scratch 的人。 提醒 如果你在用 树莓派 4B， 建议更新一下wiringPi: wiringPi updated to 2.52 for the Raspberry Pi 4B","text_tokens":[",","repl","的","(","为了","你","gpiozero","其","如果","利用","未必","wiringpi","做","用","意味着","gpio","于","工具","出色","scratch","去","for","充分利用","以","充分","raspberry","那些","在",":","性","一下","参考","派","pi","一层",")","更新","增强","更好","python","中","尤为","对","试图","只","提醒","eim","薄薄","依赖","包装","建议","好","。","人","树莓","，","可用","to","可","薄薄的","教程","适合","系统","因","具有","很","使","2.52","意味","里","4b","分利","决定","操作","理解","图形化","updated"," ","它","尤其","the","图形"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/rpi_gpio/#_1","text":"参考 Installing GPIO Zero Raspbian 默认已经预装 gpiozero 。 你需要启动它: sudo systemctl start pigpiod 如果你计划在 PC 或 Mac上对树莓派 GPIO 进行编程， 需要 配置使其可被远程访问 。 同时你需要在本地安装: python -m pip install codelab_adapter_client gpiozero pigpio --user 我们推荐远程访问模式，这意味着，树莓派可以运行在局域网里的任何地方，而你可以在自己的电脑上使用 CodeLab Adapter 对它进行编程，如此一来，你可以把 Scratch 和 Adapter 的所有能力带给它。 当然你也可以在树莓派上运行 Adapter 和 Scratch。 提醒 在 Adapter 3.2 之前，你需要自行从 插件市场 里下载 raspberrypi 插件。 源码地址 树莓派默认地址为: raspberrypi.local , 如果你ping不通它，可以手动在插件里填写树莓派ip。 运行树莓派插件，打开 Scratch-rpi-gpiozero 。 提醒 如果你手头没有LED， 你可以 使用命令行工具 gpio ，观察引脚输出变化。 gpio用的mode是wPi，而gpiozero用的是BCM，所以pin17对应wpi的pin0","text_tokens":[",","的","pigpiod","安装","可以","所以","上","你","引脚","gpiozero","其","mode","如果","pip","bcm","我们","rpi","观察","pigpio","用","意味着","gpio","工具","sudo","需要","scratch","模式",".","启动","为","对应","codelab","adapter","所有","已经","-","本地",":","在","不通","led","局域","市场","如此","没有","如此一来","计划","或","install","一来","填写","下载","ip","参考","派","预装","被","和","wpi","zero","地方","m","任何","自己","python","_","从","输出","局域网","local","对","raspberrypi","配置","当然","3.2","手头","raspbian","提醒","pin17","systemctl","。","打开","也","树莓","推荐","，","远程","变化","可","这","运行","把","命令","installing","使","访问","start","自行","默认","而","client","带给","进行","电脑","意味","里","之前","pin0","插件","使用","ping"," ","pc","它","编程","命令行","手动","user","源码","是","mac","地址","同时","能力"],"title":"安装和配置","title_tokens":["配置","安装","和"]},{"location":"extension_guide/rpi_gpio/#_2","text":"我们并不打算构建完备的积木组操控树莓派，树莓派高度灵活，难以完全积木化它的所有特性，那样不会提高可理解性。 我们希望用户灵活使用 Python 去增强 Scratch ，更好的扩展模式可以参考 Python eval kernel 。 当然一些功能是可以积木化的，期待你来提交 PR。 提醒 Raspbian Scratch 3 Desktop 也是个很好的选择，有丰富的积木。 CodeLab Adapter的目标是**连接**。","text_tokens":["的","*","扩展","用户","可以","并","目标","你","好","高度","。","性","pr","打算","3","特性","我们","树莓","理解","，","积木","难以","不会","使用","kernel","完备","希望","化","派","参考"," ","构建","连接","eval","个","可","化它","增强","更好","组","来","python","功能","提交","不","一些","操控","丰富","提高","是","灵活","scratch","期待","有","模式","完全","去","很","codelab","当然","adapter","desktop","也","raspbian","那样","提醒","选择","所有"],"title":"最后","title_tokens":["最后"]},{"location":"extension_guide/rpi_gpio/#_3","text":"gpio 测试工具 wiringPi updated to 2.52 for the Raspberry Pi 4B","text_tokens":["测试","gpio","试工","raspberry","工具","for","updated","to","4b"," ","wiringpi","the","pi","2.52","测试工具"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/simple_NLU/","text":"Tutorial ¶ simple NLU 是一个简单的语义处理器，基于简单的规则匹配，可以做一些有趣的事情。 主要受到 Cozmo 社区 Cozmo-Voice-Commands 项目的启发。 Demo ¶ 以下是一些 demo: Robomaster ¶ Cozmo 学猫叫 ¶ 插件说明 ¶ 使用方式: 到 插件市场 下载插件, 搜索 NLU 插件类型: Adapter Extension 插件源码: extension_simple_NLU.py 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 开始使用 ¶ 我们以前头的 Cozmo 学猫叫项目为例，解释插件的使用。 NLU 是一个语义解析器，语言文本的输入，是任意的。你可以使用 Scratch 内置的语音输入；也可以使用 Siri。 如果你和视频 demo 一样，准备使用 Siri，需要先将 Siri 接入到 Adapter 中，参考 文档 。 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 加载 Scratch-simple-nlu-cozmo 提醒 如果你加载遇到问题，可能需要先刷新浏览器缓存 点击绿旗，将运行相应的adapter插件。按下空格将运行示例输入: cozmo 前进50毫米，然后吓跑他，接着右转90度，之后表演一下学猫叫 如果一切正常，可以拿起你的Siri，控制Cozmo啦！ 使用scratch内置语音输入 如果你不想使用Siri，也可以使用CodeLab Scratch内置的语音输入， 以下是案例： Scratch-nlu-cozmo-with-Scratch-input 。按下 a 按键,开始语音输入(默认5秒，你可以自己调节输入时长) 进阶 ¶ 如果你想构建更强大的语义引擎，可以使用 wit.ai 、 api.ai 当然你也可以使用等开源项目 rasa 自行构建，中文用户推荐 Rasa_NLU_Chi","text_tokens":[",","的","绿旗","步骤","(","表演","时","可以","一个","安装","解释","事情","输入","上","with","你","demo","内置","如果","绿色","1","我们","简单","voice","一切正常","他","右转","做","tutorial","说明","问题","浏览器","正常","这儿","社区","；","按下","scratch","需要","现阶段",".","为","启动","codelab","50","adapter","nlu","siri","一样","长","规则","接着","接入","点击","拿","小圆点","-","simple","其设","基于","py","可能",":","在","语音输入","ai","主要","猫叫","市场","处理","前进","cozmo","箭头","ui","下载","语言","不想","extension","语音","之后","一下","以前","参考","链接","效果","任意","和",")","搜索","/","毫米","将","自己","圆点","_","官方","中","相应","吓跑","空格","想","示例","chrome","、","案例","双击","缓存","当然","2","然后","理器","支持","提醒","进阶","啦","陆续","强大","呈现","调节","方式","度","遇到","用户","处理器","浏览","依赖","90","秒","建议","。","文档","：","头","打开","也","firefox","受到","，","或者","页面","web","一切","推荐","scratch3","刷新","引擎","连接","语义","匹配","文本","构建","解析器","为例","学","开始","开源","加载","运行","多","以下","等","！","如下","启发","¶","commands","自行","默认","api","a","项目","类型","阶段","按键","版本","robomaster","插件","起","使用","更","准备"," ","视频","chi","中文","先","与","wit","一些","图中","是","到","源码","团队","有趣","解析","5","scratch3.0","input","所指","目前","最佳","控制","rasa"],"title":"simple NLU","title_tokens":["nlu"," ","simple"]},{"location":"extension_guide/simple_NLU/#tutorial","text":"simple NLU 是一个简单的语义处理器，基于简单的规则匹配，可以做一些有趣的事情。 主要受到 Cozmo 社区 Cozmo-Voice-Commands 项目的启发。","text_tokens":["的","-","simple","基于","可以","一个","处理器","事情","主要","处理","。","cozmo","简单","受到","，","voice"," ","做","语义","匹配","社区","一些","是","启发","有趣","commands","nlu","理器","规则","项目"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/simple_NLU/#demo","text":"以下是一些 demo:","text_tokens":[":","以下"," ","一些","demo","是"],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/simple_NLU/#robomaster","text":"","text_tokens":[],"title":"Robomaster","title_tokens":["robomaster"]},{"location":"extension_guide/simple_NLU/#cozmo","text":"","text_tokens":[],"title":"Cozmo 学猫叫","title_tokens":["学","cozmo"," ","猫叫"]},{"location":"extension_guide/simple_NLU/#_1","text":"使用方式: 到 插件市场 下载插件, 搜索 NLU 插件类型: Adapter Extension 插件源码: extension_simple_NLU.py","text_tokens":[",","方式","simple","py",":","市场","插件","使用","下载","extension"," ","搜索","_","源码","到",".","adapter","nlu","类型"],"title":"插件说明","title_tokens":["插件","说明"]},{"location":"extension_guide/simple_NLU/#_2","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/simple_NLU/#_3","text":"我们以前头的 Cozmo 学猫叫项目为例，解释插件的使用。 NLU 是一个语义解析器，语言文本的输入，是任意的。你可以使用 Scratch 内置的语音输入；也可以使用 Siri。 如果你和视频 demo 一样，准备使用 Siri，需要先将 Siri 接入到 Adapter 中，参考 文档 。","text_tokens":["的","可以","一个","解释","输入","语音输入","猫叫","你","demo","。","cozmo","文档","内置","头","如果","我们","插件","使用","，","语言","也","语音","准备","以前","参考"," ","语义","任意","文本","和","视频","解析器","为例","学","先","将","；","中","是","scratch","需要","到","解析","nlu","adapter","siri","一样","项目","接入"],"title":"开始使用","title_tokens":["开始","使用"]},{"location":"extension_guide/simple_NLU/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/simple_NLU/#2-codelab-scratch","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 加载 Scratch-simple-nlu-cozmo 提醒 如果你加载遇到问题，可能需要先刷新浏览器缓存 点击绿旗，将运行相应的adapter插件。按下空格将运行示例输入: cozmo 前进50毫米，然后吓跑他，接着右转90度，之后表演一下学猫叫 如果一切正常，可以拿起你的Siri，控制Cozmo啦！ 使用scratch内置语音输入 如果你不想使用Siri，也可以使用CodeLab Scratch内置的语音输入， 以下是案例： Scratch-nlu-cozmo-with-Scratch-input 。按下 a 按键,开始语音输入(默认5秒，你可以自己调节输入时长)","text_tokens":[",","的","绿旗","(","表演","时","可以","输入","上","with","你","内置","如果","绿色","一切正常","他","右转","说明","问题","浏览器","正常","这儿","按下","scratch","需要","codelab","50","adapter","nlu","siri","长","接着","点击","拿","小圆点","-","simple","可能",":","语音输入","猫叫","前进","箭头","cozmo","ui","不想","之后","语音","一下","链接",")","毫米","将","自己","圆点","相应","吓跑","空格","示例","案例","缓存","然后","提醒","啦","呈现","调节","度","遇到","浏览","90","秒","。","：","打开","一切","也","，","或者","页面","web","scratch3","刷新","连接","学","开始","加载","运行","以下","！","如下","默认","a","按键","插件","起","使用"," ","先","与","图中","是","5","scratch3.0","input","所指","控制"],"title":"步骤 2：打开 Codelab Scratch","title_tokens":["步骤","codelab","2"," ","：","scratch","打开"]},{"location":"extension_guide/simple_NLU/#_4","text":"如果你想构建更强大的语义引擎，可以使用 wit.ai 、 api.ai 当然你也可以使用等开源项目 rasa 自行构建，中文用户推荐 Rasa_NLU_Chi","text_tokens":["的","用户","可以","ai","你","如果","也","推荐","使用","，","更","引擎"," ","构建","语义","chi","中文","开源","wit","_","等","想",".","、","当然","nlu","rasa","自行","api","项目","强大"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/siri/","text":"Tutorial ¶ Hey siri 介绍 ¶ 使用该插件，可将 Siri 接入到 CodeLab Scratch，并与 CodeLab 可编程空间里的一切互动。 演示 ¶ 插件说明 ¶ 使用方式: 到 插件市场 下载插件, 搜索 siri 插件类型: Adapter Extension 插件源码: extension_Siri.py 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 在 Codelab Scratch 里加载 Siri 插件, 点击绿旗，运行 Adapter Siri 插件。 步骤 3：在 iOS(iPhone/iPad)的 快捷指令 里自定义指令 ¶ 确保 iOS 设备和 Adapter 所在设备处在同一个局域网 提醒 建议iOS版本在13以上，不然URL内容获取块可能无法手动输入URL 创建一个 对话模式 指令, 该指令的功能是将 Siri 提示输入( 什么内容 )的内容输入到 CodeLab Scratch 使用语音 Hey siri，对话模式 ，将激活刚才自定义的 对话模式 指令 在 Scratch 中接受来自 Siri 的输入内容( 早上好 ) 控制乐高 (列表选择)指令 ¶ 对着iOS设备说 Hey siri，控制乐高 ，将激活刚才自定义的 控制乐高 指令 创建一个 控制乐高 指令, 该指令的功能是将 Siri 提示输入( 哪一个 )的内容输入到 CodeLab Scratch 在 Scratch 中接受来自 Siri 的输入内容( 顺时针旋转 ) 原理说明 ¶ CodeLab ❤ Siri","text_tokens":[",","的","绿旗","步骤","(","安装","一个","输入","上","提示","指令","绿色","1","自定义","获取","hey","tutorial","说明","早上好","浏览器","正常","这儿","说","同一","设备","功能","什么","早上","scratch","现阶段",".","为","启动","模式","codelab","介绍","adapter","处在","siri","点击","接入","小圆点","其设","以上","py","内容",":","在","可能","对话","局域","市场","箭头","ui","下载","不然","来自","extension","之后","语音","哪","链接","刚才","效果","和",")","搜索","/","自定","将","圆点","_","官方","中","局域网","上好","对","演示","chrome","双击","2","支持","提醒","陆续","块","iphone","呈现","方式","并","浏览","依赖","列表","同一个","建议","着","。","：","顺时针","打开","3","无法","一切","firefox","，","或者","页面","web","可编程","scratch3","旋转","连接","确保","可","定义","激活","时针","加载","运行","多","如下","该","所在","接受","¶","默认","url","类型","阶段","空间","快捷","版本","里","互动","13","插件","乐高","使用","更"," ","编程","❤","手动","与","顺时","可编","图中","到","源码","团队","是","ipad","ios","scratch3.0","原理","选择","所指","目前","最佳","控制","创建"],"title":"Siri","title_tokens":["siri"]},{"location":"extension_guide/siri/#tutorial","text":"Hey siri","text_tokens":[" ","siri","hey"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/siri/#_1","text":"使用该插件，可将 Siri 接入到 CodeLab Scratch，并与 CodeLab 可编程空间里的一切互动。","text_tokens":["的","并","里","互动","。","插件","一切","使用","，","可编程"," ","可","编程","将","与","可编","该","到","scratch","codelab","siri","接入","空间"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/siri/#_2","text":"","text_tokens":[],"title":"演示","title_tokens":["演示"]},{"location":"extension_guide/siri/#_3","text":"使用方式: 到 插件市场 下载插件, 搜索 siri 插件类型: Adapter Extension 插件源码: extension_Siri.py","text_tokens":[",",".","搜索","插件","使用","方式","下载","adapter","py",":","extension","siri","_"," ","市场","源码","到","类型"],"title":"插件说明","title_tokens":["插件","说明"]},{"location":"extension_guide/siri/#_4","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/siri/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/siri/#2-codelab-scratch","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 在 Codelab Scratch 里加载 Siri 插件, 点击绿旗，运行 Adapter Siri 插件。","text_tokens":[",","小圆点","呈现","的","绿旗",":","在","里","上","。","箭头","打开","绿色","ui","插件","，","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","加载","将","与","圆点","运行","如下","图中","scratch","codelab","adapter","scratch3.0","siri","所指","点击"],"title":"步骤 2：打开 Codelab Scratch","title_tokens":["步骤","codelab","2"," ","：","scratch","打开"]},{"location":"extension_guide/siri/#3-iosiphoneipad","text":"确保 iOS 设备和 Adapter 所在设备处在同一个局域网 提醒 建议iOS版本在13以上，不然URL内容获取块可能无法手动输入URL 创建一个 对话模式 指令, 该指令的功能是将 Siri 提示输入( 什么内容 )的内容输入到 CodeLab Scratch 使用语音 Hey siri，对话模式 ，将激活刚才自定义的 对话模式 指令 在 Scratch 中接受来自 Siri 的输入内容( 早上好 )","text_tokens":[",","的","版本","(","以上","内容","一个","可能","在","输入","对话","提示","局域","同一个","建议","指令","13","无法","使用","，","不然","自定义","来自","语音","获取","hey"," ","确保","刚才","和",")","早上好","定义","手动","同一","激活","设备","将","自定","功能","什么","中","早上","局域网","该","上好","所在","是","到","scratch","接受","模式","codelab","ios","adapter","处在","siri","提醒","url","块","创建"],"title":"步骤 3：在 iOS(iPhone/iPad)的快捷指令里自定义指令","title_tokens":["3","快捷","的","定义","步骤","ios","(","/","自定","自定义","里","在"," ","指令","：","ipad",")","iphone"]},{"location":"extension_guide/siri/#_5","text":"对着iOS设备说 Hey siri，控制乐高 ，将激活刚才自定义的 控制乐高 指令 创建一个 控制乐高 指令, 该指令的功能是将 Siri 提示输入( 哪一个 )的内容输入到 CodeLab Scratch 在 Scratch 中接受来自 Siri 的输入内容( 顺时针旋转 )","text_tokens":[",","的","(","内容","一个","在","输入","提示","指令","着","顺时针","乐高","自定义","，","来自","哪","hey"," ","旋转","刚才",")","说","定义","激活","时针","自定","设备","将","顺时","功能","中","该","是","到","scratch","对","接受","codelab","ios","siri","控制","创建"],"title":"控制乐高(列表选择)指令","title_tokens":["乐高","(","列表","指令","选择",")","控制"]},{"location":"extension_guide/siri/#_6","text":"CodeLab ❤ Siri","text_tokens":["❤"," ","codelab","siri"],"title":"原理说明","title_tokens":["原理","说明"]},{"location":"extension_guide/sonicPi/","text":"Tutorial ¶ 插件说明 ¶ Windows 和 Mac 用户开箱可用。Linux用户将自动安装依赖 外部环境依赖 ¶ 需要下载 Sonic Pi 。 开始使用 ¶ 运行 Sonic Pi。 启动 CodeLab Adapter，运行 node_sonicPi 插件。 打开 Scratch 编程界面，我们已经制作了一个 demo: Scratch-SonicPi 。 进阶 ¶ 更多可用的指令，参考 python-sonic 。 如果你想深入了解 Sonic Pi ，可以跟着 Sonic Pi 软件内置的文档学习。 发送消息 ¶ >= 3.7.2 的 Adapter 支持使用Scratch积木发送OSC消息，消息的参数(args)是一个 list(采用json语法，字符串使用 双引号 ) Receiving OSC ¶ Sonic Pi Receiving OSC 参考这个文档，你也可以基于 python-sonic 构建一个 自定义插件 直接与Sonic Pi沟通。 参考 ¶ Sonic Pi python-sonic","text_tokens":["的","(","用户","安装","外部环境","一个","可以","双引号","你","指令","demo","内置","如果","我们","自定义","软件",">","说明","tutorial","制作","需要","scratch",".","启动","codelab","list","adapter","了","自动","已经","-","基于",":","跟着","引号","下载","深入","参考","pi","3.7","和",")","自定","将","python","_","想","linux","2","支持","进阶","发送","依赖","外部","。","文档","打开","也","，","可用","构建","直接","开始","定义","运行","多","json","sonicpi","¶","语法","字符","参数","界面","字符串","args","开箱","插件","使用","积木","更","node","=","采用"," ","编程","windows","与","这个","receiving","是","环境","sonic","消息","mac","了解","学习","沟通","osc"],"title":"Sonic Pi","title_tokens":["sonic"," ","pi"]},{"location":"extension_guide/sonicPi/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/sonicPi/#_1","text":"Windows 和 Mac 用户开箱可用。Linux用户将自动安装依赖","text_tokens":["用户","windows","linux","mac","将","可用","安装","依赖"," ","自动","。","和","开箱"],"title":"插件说明","title_tokens":["插件","说明"]},{"location":"extension_guide/sonicPi/#_2","text":"需要下载 Sonic Pi 。","text_tokens":["下载","sonic"," ","pi","。","需要"],"title":"外部环境依赖","title_tokens":["依赖","外部环境","环境","外部"]},{"location":"extension_guide/sonicPi/#_3","text":"运行 Sonic Pi。 启动 CodeLab Adapter，运行 node_sonicPi 插件。 打开 Scratch 编程界面，我们已经制作了一个 demo: Scratch-SonicPi 。","text_tokens":["-","一个","界面",":","demo","。","打开","插件","我们","，","node"," ","pi","编程","运行","_","制作","scratch","sonicpi","启动","codelab","sonic","adapter","了","已经"],"title":"开始使用","title_tokens":["开始","使用"]},{"location":"extension_guide/sonicPi/#_4","text":"更多可用的指令，参考 python-sonic 。 如果你想深入了解 Sonic Pi ，可以跟着 Sonic Pi 软件内置的文档学习。","text_tokens":["的","-","可以","跟着","你","指令","。","文档","内置","如果","深入","，","软件","更","可用","参考"," ","pi","python","多","想","sonic","了解","学习"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/sonicPi/#_5","text":">= 3.7.2 的 Adapter 支持使用Scratch积木发送OSC消息，消息的参数(args)是一个 list(采用json语法，字符串使用 双引号 )","text_tokens":["的","(","双引号","一个","字符串","args","引号","使用","，","积木",">","=","采用"," ","3.7",")","json","是","scratch",".","list","adapter","消息","2","语法","支持","字符","发送","参数","osc"],"title":"发送消息","title_tokens":["消息","发送"]},{"location":"extension_guide/sonicPi/#receiving-osc","text":"Sonic Pi Receiving OSC 参考这个文档，你也可以基于 python-sonic 构建一个 自定义插件 直接与Sonic Pi沟通。","text_tokens":["-","基于","可以","一个","你","文档","。","也","插件","自定义","，","参考"," ","pi","构建","直接","定义","自定","与","python","这个","receiving","sonic","沟通","osc"],"title":"Receiving OSC","title_tokens":["osc","receiving"," "]},{"location":"extension_guide/sonicPi/#_6","text":"Sonic Pi python-sonic","text_tokens":["-","sonic","python"," ","pi"],"title":"参考","title_tokens":["参考"]},{"location":"extension_guide/stage/","text":"Tutorial ¶ Stage 指 Scratch 的舞台区。 Adapter Stage 插件允许将舞台区的图像（舞台或者摄像头图像）以 base64 的格式发往 Adapter，你可以使用 Adapter node/extension 自定构建图像处理程序，诸如使用 神经网络 或 OpenCV，将识别的结果返回给 Scratch。 当然，你也可以构建一个自动保存舞台状态的插件，或者自拍/美颜插件：） 需要配合 Scratch ImageData 插件中的积木使用。 提醒 在 Adapter 3.2 之前，你需要自行从 插件市场 里下载 Stage 插件。 源码地址 运行 Stage 插件（当前插件的功能是把图像保存到 Adapter Home 目录 ）,你可以通过修改插件做其他事情。 如果你想使用 OpenCV 或 Tensorflow 处理图像，需要自定义 Adapter Node Demo ¶ stage image","text_tokens":[",","的","可以","一个","事情","你","demo","如果","自定义","（","做","tutorial","自拍","往","区","像头","功能","发","指","scratch","需要","adapter","自动","以","在","市场","处理","或","神经网络","下载","extension","摄像","美颜","诸如","舞台","网络","home","/","自定","将","目录","当前","中","从","想","通过","当然","3.2","提醒","保存","。","：","也","给","，","或者","opencv","摄像头","状态","构建","定义","base64","运行","把","允许","神经网","返回","¶","自行","其他","）","图像","imagedata","配合","里","tensorflow","程序","结果","识别","自","之前","插件","定","使用","积木","node","格式"," ","图像处理","修改","源码","是","到","神经","stage","image","地址"],"title":"Stage","title_tokens":["stage"]},{"location":"extension_guide/stage/#tutorial","text":"Stage 指 Scratch 的舞台区。 Adapter Stage 插件允许将舞台区的图像（舞台或者摄像头图像）以 base64 的格式发往 Adapter，你可以使用 Adapter node/extension 自定构建图像处理程序，诸如使用 神经网络 或 OpenCV，将识别的结果返回给 Scratch。 当然，你也可以构建一个自动保存舞台状态的插件，或者自拍/美颜插件：） 需要配合 Scratch ImageData 插件中的积木使用。 提醒 在 Adapter 3.2 之前，你需要自行从 插件市场 里下载 Stage 插件。 源码地址 运行 Stage 插件（当前插件的功能是把图像保存到 Adapter Home 目录 ）,你可以通过修改插件做其他事情。 如果你想使用 OpenCV 或 Tensorflow 处理图像，需要自定义 Adapter Node","text_tokens":[",","的","可以","一个","事情","你","如果","自定义","（","做","自拍","往","区","像头","功能","发","指","scratch","需要","adapter","自动","以","在","市场","处理","或","神经网络","下载","extension","摄像","美颜","诸如","舞台","网络","home","/","自定","将","目录","当前","中","从","想","通过","当然","3.2","提醒","保存","。","：","也","给","，","或者","opencv","摄像头","状态","构建","定义","base64","运行","把","允许","神经网","返回","自行","其他","）","图像","imagedata","配合","里","tensorflow","程序","结果","识别","自","之前","插件","定","使用","积木","node","格式"," ","图像处理","修改","源码","是","到","神经","stage","地址"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/stage/#demo","text":"stage image","text_tokens":["image","stage"," "],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/switch/","text":"Switch ¶ 我们之前的演示案例是利用 Toy-Con Garage 做的。 任天堂没有开放接口。 我们通过捕获 Toy-Con Garage 的视觉输出做的连接。","text_tokens":["的","-","接口","没有","。","开放","之前","捕获","con","我们","利用","视觉"," ","garage","做","连接","switch","任天堂","toy","输出","是","通过","演示","案例","¶","天堂"],"title":"Switch","title_tokens":["switch"]},{"location":"extension_guide/switch/#switch","text":"我们之前的演示案例是利用 Toy-Con Garage 做的。 任天堂没有开放接口。 我们通过捕获 Toy-Con Garage 的视觉输出做的连接。","text_tokens":["的","-","接口","没有","开放","。","之前","捕获","con","我们","利用","视觉"," ","garage","做","连接","任天堂","toy","输出","是","通过","演示","案例","天堂"],"title":"Switch","title_tokens":["switch"]},{"location":"extension_guide/teachable_machine/","text":"Tutorial ¶ 介绍 ¶ CodeLab Adapter 接入 Teachable Machine 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Teachable Machine ¶ Longan团队已经将Teachable Machine部署到国内: Longan Teachable Machine , 并且内置支持CodeLab Adapter， 开箱可用！ 提醒 海外用户参考文末操作 表示已经将 Teachable Machine 接入 CodeLab Adapter 了。 接下来，可以开始你的 Teachable Machine 之旅途。 我们来展示一个例子。 步骤 3：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 接着在 Scratch 中拿到 Teachable Machine 的训练结果，构建一个简单应用。 在线打开它 tm_scratch_demo Tips 来自Teachable Machine的消息，源源不断流过来，有时候你并不希望重复触发同一件事。可以参考以下例子 Scratch-tm-latest-class 。 提醒 Teachable Machine 的网页不能在后台运行，需要和 Scratch 一起并列在桌面上，否则程序不会运行。 海外用户 ¶ 如果你是海外用户，建议使用 Google 官方的 teachablemachine ， 你需要搭配以下插件。 安装 Chrome 浏览器插件： Tampermonkey 。 点击安装 Tampermonkey 脚本 Teachablemachine_Result.user.js 。 运行Adapter之后如何页面弹出，已连接Adapter，则说明一切正常","text_tokens":[",","的","步骤","用户","安装","可以","一个","应用","上","你","google","demo","接下来","内置","如果","绿色","1","我们","简单","longan","一切正常","tutorial","说明","一起","浏览器","正常","这儿","桌面上","弹","下来","scratch","需要","js","现阶段",".","为","启动","codelab","否则","介绍","adapter","了","搭配","machine","接着","接入","点击","已经","teachablemachine","小圆点","-","其设","流过来",":","在","重复","时候","箭头","ui","来自","之后","参考","链接","效果","拿到","和","有时","/","将","来","圆点","_","过来","官方","中","chrome","双击","2","支持","提醒","网页","并且","陆续","出","呈现","展示","之","表示","并","浏览","如何","有时候","建议","例子","。","：","打开","3","一切","firefox","，","或者","页面","web","tm","不会","可用","希望","scratch3","接下","连接","构建","脚本","不能","开始","一件","latest","运行","多","同","以下","！","如下","源源","桌面","tampermonkey","文末","¶","触发","默认","训练","已","在线","国内","则","阶段","版本","结果","程序","并列","class","开箱","源源不断","操作","teachable","插件","使用","更","部署"," ","事","后台","它","海外","流过","面上","与","tips","不","图中","user","到","是","团队","result","旅途","不断","消息","scratch3.0","所指","目前","最佳"],"title":"Teachable Machine","title_tokens":["machine"," ","teachable"]},{"location":"extension_guide/teachable_machine/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/teachable_machine/#_1","text":"CodeLab Adapter 接入 Teachable Machine 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","teachable","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","machine","目前","接入","陆续","阶段"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/teachable_machine/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/teachable_machine/#2-teachable-machine","text":"Longan团队已经将Teachable Machine部署到国内: Longan Teachable Machine , 并且内置支持CodeLab Adapter， 开箱可用！ 提醒 海外用户参考文末操作 表示已经将 Teachable Machine 接入 CodeLab Adapter 了。 接下来，可以开始你的 Teachable Machine 之旅途。 我们来展示一个例子。","text_tokens":[",","展示","的","之","用户","表示","可以",":","一个","你","例子","。","接下来","开箱","内置","操作","teachable","我们","，","longan","部署","可用","参考"," ","接下","开始","海外","接入","将","来","！","下来","到","团队","旅途","codelab","文末","adapter","了","国内","machine","支持","提醒","并且","已经"],"title":"步骤 2：打开 Teachable Machine","title_tokens":["teachable","步骤","2"," ","machine","：","打开"]},{"location":"extension_guide/teachable_machine/#3-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 接着在 Scratch 中拿到 Teachable Machine 的训练结果，构建一个简单应用。 在线打开它 tm_scratch_demo Tips 来自Teachable Machine的消息，源源不断流过来，有时候你并不希望重复触发同一件事。可以参考以下例子 Scratch-tm-latest-class 。 提醒 Teachable Machine 的网页不能在后台运行，需要和 Scratch 一起并列在桌面上，否则程序不会运行。","text_tokens":[",","的","应用","一个","可以","上","你","demo","绿色","简单","说明","一起","正常","这儿","桌面上","scratch","需要","codelab","否则","adapter","machine","接着","点击","小圆点","-","流过来",":","在","重复","时候","箭头","ui","来自","参考","链接","拿到","和","将","圆点","_","过来","中","提醒","网页","呈现","并","有时候","例子","。","打开","，","或者","页面","web","tm","不会","希望","scratch3","连接","构建","不能","一件","latest","运行","同","以下","如下","源源","桌面","触发","训练","在线","结果","程序","并列","class","源源不断","teachable"," ","事","后台","它","流过","面上","与","tips","不","图中","不断","消息","scratch3.0","所指","有时"],"title":"步骤 3：打开 Codelab Scratch3","title_tokens":["3","步骤","codelab","scratch3"," ","：","打开"]},{"location":"extension_guide/teachable_machine/#_2","text":"如果你是海外用户，建议使用 Google 官方的 teachablemachine ， 你需要搭配以下插件。 安装 Chrome 浏览器插件： Tampermonkey 。 点击安装 Tampermonkey 脚本 Teachablemachine_Result.user.js 。 运行Adapter之后如何页面弹出，已连接Adapter，则说明一切正常","text_tokens":["的","用户","安装","浏览","如何","你","建议","google","。","：","如果","插件","一切","使用","，","页面","之后","一切正常"," ","说明","连接","脚本","浏览器","海外","正常","运行","_","以下","弹","官方","user","是","需要","js","result",".","chrome","tampermonkey","adapter","搭配","已","则","点击","出","teachablemachine"],"title":"海外用户","title_tokens":["用户","海外"]},{"location":"extension_guide/tello/","text":"DJI Tello ¶ Tello 请使用 tello2.0 提醒 Tello 会占用 wifi，导致电脑无法联网。有两种方式在 CodeLab Scratch 使用它: 1. 打开 https://scratch-beta.codelab.club?adapter_host=127.0.0.1 2. 使用 CodeLab Adapter 的离线模式： FAQ：离线使用 (在 >=3.4.0 的版本中可用) 以下是在线版使用教程，离线版基本相似。 步骤 1：打开 CodeLab Scratch ¶ 运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 第一次运行请点击 verify 积木，信任该网站。(离线版不需要) 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。 步骤 2：连接 Tello ¶ 将电脑连上 Tello 的 wifi 热点。（操作细节可以参考 Tello 说明书） 步骤 3：开始使用 ¶ 选择 scratch3 中的 Tello 插件： 运行 Tello 插件。 之后依次点击 控制飞机 、 起飞 起飞吧！ 一些案例: ¶ DJI Tello x Leap Motion ¶ DJI Tello x Switch Labo ¶ DJI Tello x Switch Joy-Con ¶ 改进 ¶ 目前 Tello 的插件都已开源，很久没更新，稳定性不高，大家可以一起改进它 extension_tello scratch3_tello 提醒 如果你希望做一些更复杂的事，建议直接使用社区里的 Python SDK与 设备交互，之后使用 Adapter Node 将其接入Adapter环境中。 Tello api 文档 ¶ SDK 2.0 DJITelloPy <!-- TelloPy Tello-Python → multi_robot_drone_example","text_tokens":["的","步骤","(","可以","看到","上","你","wifi","起飞","其","如果","绿色","1",">","（","club","做","基本","说明","beta","说明书","一起","正常","tellopy","离线","社区","sdk","设备","→","平台","scratch","需要","模式",".","codelab","adapter","tello","网站","会","点击","接入","-",":","在","版","https","两种","3.4","第一次","定性","改进","大家","之后","extension","参考","第一","成功","0.1",")","更新","example","/","将","很久没","python","_","中","吧","、","案例","2","?","复杂","提醒","tello2.0","drone","联网","!","方式","host","<","建议","。","：","文档","0","稳定性","打开","con","3","x","无法","，","faq","multi","可用","希望","scratch3","细节","dji","确保","连接","motion","直接","开始","switch","相似","2.0","教程","信任","开源","运行","以下","！","该","请","有","¶","交互","127.0","指示","在线","已","api","）","电脑","稳定","代表","版本","里","占用","很久","leap","一次","导致","指示灯","操作","插件","使用","积木","飞机","=","更","node"," ","事","它","显示","joy","与","热点","都","不","一些","连","依次","djitellopy","adapte","是","环境","verify","robot","labo","不高","选择","目前","控制"],"title":"Tello","title_tokens":["tello"]},{"location":"extension_guide/tello/#dji-tello","text":"Tello 请使用 tello2.0 提醒 Tello 会占用 wifi，导致电脑无法联网。有两种方式在 CodeLab Scratch 使用它: 1. 打开 https://scratch-beta.codelab.club?adapter_host=127.0.0.1 2. 使用 CodeLab Adapter 的离线模式： FAQ：离线使用 (在 >=3.4.0 的版本中可用) 以下是在线版使用教程，离线版基本相似。","text_tokens":["联网","的","-","方式","(","版本",":","在","host","版","占用","wifi","两种","https","3.4","。","：","0","导致","打开","1","无法","使用","，","faq",">","=","可用","club"," ","基本","0.1","beta","它",")","相似","离线","教程","/","_","以下","中","是","scratch","请","有","模式",".","codelab","adapter","tello","2","?","127.0","在线","提醒","tello2.0","会","电脑"],"title":"DJI Tello","title_tokens":[" ","dji","tello"]},{"location":"extension_guide/tello/#1-codelab-scratch","text":"运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 第一次运行请点击 verify 积木，信任该网站。(离线版不需要) 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。","text_tokens":["代表","(","版","看到","第一次","。","一次","指示灯","绿色","，","积木","第一"," ","成功","连接","确保",")","显示","正常","离线","信任","与","运行","不","该","adapte","平台","需要","请","verify","scratch","codelab","adapter","网站","指示","在线","点击"],"title":"步骤 1：打开 CodeLab Scratch","title_tokens":["1","步骤","codelab"," ","：","scratch","打开"]},{"location":"extension_guide/tello/#2-tello","text":"将电脑连上 Tello 的 wifi 热点。（操作细节可以参考 Tello 说明书）","text_tokens":["说明书","操作","的","可以","将","tello","（","上","热点","参考","wifi"," ","细节","连","说明","。","）","电脑"],"title":"步骤 2：连接 Tello","title_tokens":["步骤","2","tello"," ","连接","："]},{"location":"extension_guide/tello/#3","text":"选择 scratch3 中的 Tello 插件： 运行 Tello 插件。 之后依次点击 控制飞机 、 起飞 起飞吧！","text_tokens":["的","起飞","。","：","插件","飞机","之后","scratch3"," ","运行","中","吧","！","依次","、","tello","选择","点击","控制"],"title":"步骤 3：开始使用","title_tokens":["开始","3","步骤","使用"," ","："]},{"location":"extension_guide/tello/#_1","text":"","text_tokens":[],"title":"一些案例:","title_tokens":[":","一些","案例"]},{"location":"extension_guide/tello/#dji-tello-x-leap-motion","text":"","text_tokens":[],"title":"DJI Tello x Leap Motion","title_tokens":["x","tello"," ","dji","leap","motion"]},{"location":"extension_guide/tello/#dji-tello-x-switch-labo","text":"","text_tokens":[],"title":"DJI Tello x Switch Labo","title_tokens":["x","switch","labo","tello"," ","dji"]},{"location":"extension_guide/tello/#dji-tello-x-switch-joy-con","text":"","text_tokens":[],"title":"DJI Tello x Switch Joy-Con","title_tokens":["con","x","switch","-","joy","tello"," ","dji"]},{"location":"extension_guide/tello/#_2","text":"目前 Tello 的插件都已开源，很久没更新，稳定性不高，大家可以一起改进它 extension_tello scratch3_tello 提醒 如果你希望做一些更复杂的事，建议直接使用社区里的 Python SDK与 设备交互，之后使用 Adapter Node 将其接入Adapter环境中。","text_tokens":["的","可以","里","你","很久","建议","定性","。","其","稳定性","如果","改进","插件","使用","，","大家","更","extension","之后","希望","node","scratch3"," ","事","做","它","直接","更新","一起","社区","sdk","开源","设备","将","与","很久没","python","_","都","一些","中","环境","adapter","不高","tello","复杂","交互","已","提醒","目前","接入","稳定"],"title":"改进","title_tokens":["改进"]},{"location":"extension_guide/tello/#tello-api","text":"SDK 2.0 DJITelloPy <!-- TelloPy Tello-Python → multi_robot_drone_example","text_tokens":["!","tellopy","robot","-","2.0","example","sdk","multi","tello","python","<","_"," ","→","djitellopy","drone"],"title":"Tello api 文档","title_tokens":["文档","tello"," ","api"]},{"location":"extension_guide/tello2/","text":"Tello 2.0 ¶ Tello 插件的 2.0 版本， 基于 DJITelloPy 库。 支持Tello、Tello Edu 和 Tello TT。 提醒 Tello 会占用 wifi，导致电脑无法联网，请使用 CodeLab Adapter 的离线模式: FAQ：离线使用 (在 >=3.4.0 的版本中可用)。 更好的方式可能是将Tello接入路由器上，或者使用USB无线网卡，避免电脑无法上网。 以下是在线版使用教程，离线版基本相似。 步骤 1：打开 CodeLab Scratch ¶ 运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。 步骤 2：连接 Tello ¶ 将电脑连上 Tello 的 wifi 热点。（操作细节可以参考 Tello 说明书） 步骤 3：开始使用 ¶ 选择 scratch3 中的 Tello2.0 插件. 运行 Tello2.0 插件。 之后依次点击 连接tello 、 起飞 起飞吧！ 一些案例: ¶ DJI Tello x Leap Motion ¶ DJI Tello x Switch Labo ¶ DJI Tello x Switch Joy-Con ¶ 进阶 ¶ 你可以在 Tello 广播积木里调用 api ！形如: tello.flip_left() 利用API，你也可以与停机坪(机器视觉)交互( get_mission_pad_id ).API里有很多与停机坪相关的函数。 如果你希望做一些更复杂的事，建议直接使用社区里的 DJITelloPy 与 设备交互（ api ），之后使用 Adapter Node 将其接入Adapter环境中。 Tello api 文档 ¶ DJITelloPy SDK 2.0 multi_robot_drone_example","text_tokens":["的","步骤","(","可以","上","看到","你","wifi","起飞","其","如果","绿色","1","利用",">","（","做","基本","说明","停机","flip","说明书","正常","离线","社区","sdk","设备","相关","平台","scratch","模式",".","codelab","adapter","usb","tello","调用","机器","会","接入","点击","-","基于","可能",":","在","版","3.4","之后","参考","成功","和",")","get","example","更好","路由器","将","_","中","吧","形","停机坪","、","案例","2","id","复杂","支持","提醒","tello2.0","进阶","如","联网","drone","方式","函数","建议","。","：","上网","0","很多","pad","文档","打开","con","3","x","无法","库","也","，","faq","路由","或者","视觉","multi","可用","希望","scratch3","细节","dji","tt","确保","连接","motion","直接","开始","switch","相似","2.0","教程","运行","以下","！","广播","请","避免","有","left","¶","交互","指示","在线","api","）","电脑","无线","代表","版本","里","占用","leap","mission","导致","指示灯","操作","插件","使用","积木","=","更","node"," ","事","显示","joy","与","edu","热点","一些","连","依次","djitellopy","adapte","是","环境","网卡","robot","labo","选择"],"title":"Tello2.0","title_tokens":["tello2.0"]},{"location":"extension_guide/tello2/#tello-20","text":"Tello 插件的 2.0 版本， 基于 DJITelloPy 库。 支持Tello、Tello Edu 和 Tello TT。 提醒 Tello 会占用 wifi，导致电脑无法联网，请使用 CodeLab Adapter 的离线模式: FAQ：离线使用 (在 >=3.4.0 的版本中可用)。 更好的方式可能是将Tello接入路由器上，或者使用USB无线网卡，避免电脑无法上网。 以下是在线版使用教程，离线版基本相似。","text_tokens":["联网","的","版本","(","基于","方式","可能",":","在","版","上","占用","wifi","3.4","。","：","上网","0","导致","无法","插件","库","使用","，","faq",">","=","路由","或者","可用"," ","基本","tt","和",")","相似","2.0","离线","教程","更好","路由器","将","edu","以下","中","djitellopy","是","请","避免","模式",".","网卡","、","codelab","adapter","usb","tello","在线","支持","提醒","会","接入","电脑","无线"],"title":"Tello 2.0","title_tokens":["tello","2.0"," "]},{"location":"extension_guide/tello2/#1-codelab-scratch","text":"运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。","text_tokens":["代表","看到","。","指示灯","绿色","，"," ","成功","连接","确保","显示","正常","与","运行","adapte","平台","scratch","codelab","adapter","指示","在线"],"title":"步骤 1：打开 CodeLab Scratch","title_tokens":["1","步骤","codelab"," ","：","scratch","打开"]},{"location":"extension_guide/tello2/#2-tello","text":"将电脑连上 Tello 的 wifi 热点。（操作细节可以参考 Tello 说明书）","text_tokens":["说明书","操作","的","可以","将","tello","（","上","热点","参考","wifi"," ","细节","连","说明","。","）","电脑"],"title":"步骤 2：连接 Tello","title_tokens":["步骤","2","tello"," ","连接","："]},{"location":"extension_guide/tello2/#3","text":"选择 scratch3 中的 Tello2.0 插件. 运行 Tello2.0 插件。 之后依次点击 连接tello 、 起飞 起飞吧！","text_tokens":["的","。","起飞","插件","之后","scratch3"," ","连接","运行","中","吧","！","依次",".","、","tello","tello2.0","选择","点击"],"title":"步骤 3：开始使用","title_tokens":["开始","3","步骤","使用"," ","："]},{"location":"extension_guide/tello2/#_1","text":"","text_tokens":[],"title":"一些案例:","title_tokens":[":","一些","案例"]},{"location":"extension_guide/tello2/#dji-tello-x-leap-motion","text":"","text_tokens":[],"title":"DJI Tello x Leap Motion","title_tokens":["x","tello"," ","dji","leap","motion"]},{"location":"extension_guide/tello2/#dji-tello-x-switch-labo","text":"","text_tokens":[],"title":"DJI Tello x Switch Labo","title_tokens":["x","switch","labo","tello"," ","dji"]},{"location":"extension_guide/tello2/#dji-tello-x-switch-joy-con","text":"","text_tokens":[],"title":"DJI Tello x Switch Joy-Con","title_tokens":["con","x","switch","-","joy","tello"," ","dji"]},{"location":"extension_guide/tello2/#_2","text":"你可以在 Tello 广播积木里调用 api ！形如: tello.flip_left() 利用API，你也可以与停机坪(机器视觉)交互( get_mission_pad_id ).API里有很多与停机坪相关的函数。 如果你希望做一些更复杂的事，建议直接使用社区里的 DJITelloPy 与 设备交互（ api ），之后使用 Adapter Node 将其接入Adapter环境中。","text_tokens":["的","(","可以","里","在",":","函数","你","建议","。","其","很多","mission","pad","如果","也","利用","使用","，","积木","视觉","更","（","之后","希望","node"," ","事","做","停机","flip",")","直接","get","社区","设备","将","与","_","！","一些","中","形","相关","djitellopy","广播","环境","有",".","left","停机坪","调用","adapter","tello","id","交互","复杂","api","机器","接入","）","如"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/tello2/#tello-api","text":"DJITelloPy SDK 2.0 multi_robot_drone_example","text_tokens":["robot","example","2.0","sdk","multi","_"," ","djitellopy","drone"],"title":"Tello api 文档","title_tokens":["文档","tello"," ","api"]},{"location":"extension_guide/tello3/","text":"Tello 3.0 ¶ Tello 插件的 3.0 版本， 基于 DJI 官方的 SDK: RoboMaster SDK 库。 能够充分利用设备的能力。 相比于 Tello 2.0 插件 ，3.0能够 控制 LED 使用说明 ¶ 目前该插件并未内置到 Adapter 中（因其复杂的打包依赖，而且跨平台兼容性不好）。 我们目前将插件构建为 Adapter Node ，可以在Adapter外部以普通Python文件运行，一旦运行起来，与普通Adapter插件是一样的，能够与Adapter体系的所有事物交互。 Python环境 ¶ 首先你本地需要有 Python 环境（ Python>=3.6 ） 你可以到 Python 官方 下载，也可以使用 CodeLab放在 国内的版本(Python3.7) 提醒 Mac 用户和 Linux 本地很可能内置了 Python3 安装依赖 ¶ pip install robomaster codelab_adapter_client --upgrade 开始！ ¶ 提醒 Tello 会占用 wifi，导致电脑无法联网，请使用 CodeLab Adapter 的离线模式: FAQ：离线使用 (在 >=3.4.0 的版本中可用)。 更好的方式可能是将Tello接入路由器上，或者使用USB无线网卡，避免电脑无法上网。 步骤 1：打开 CodeLab Scratch ¶ 运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。 步骤 1：运行 node_tello3.py ¶ 将 node_tello3.py 插件下载到本地（随便放在一个文件夹里），在命令行中进入到这个文件夹，使用 python node_tello3.py 运行它。 步骤 2：连接 Tello ¶ 将电脑连上 Tello 的 wifi 热点。（操作细节可以参考 Tello 说明书） 步骤 3: 起飞吧! ¶ 选择 scratch3 中的 EIM 插件. 以下是一个简单 demo: tello3-demo 起飞吧！ 进阶 ¶ 更多API参考文档: RoboMaster SDK","text_tokens":["的","步骤","(","用户","可以","安装","一个","上","看到","相比","你","并未","wifi","demo","起飞","其","内置","pip","绿色","容性","1","我们","利用","而且","简单",">","（","事物","说明","说明书","于","正常","离线","sdk","设备","平台","需要","scratch","模式",".","为","兼容","codelab","随便","充分利用","adapter","tello","3.6","了","一样","usb","以","所有","充分","会","接入","-","本地","一旦","基于","可能","跨平台",":","led","在","py","3.4","install","下载","参考","成功","文件","和",")","普通","更好","路由器","将","python","_","官方","中","吧","件夹","首先","linux","2","复杂","提醒","进阶","eim","联网","!","能够","方式","依赖","兼容性","外部","。","：","上网","不好","0","文档","体系","打开","3","无法","库","也","，","faq","路由","或者","可用","scratch3","细节","dji","构建","确保","连接","tello3","放在","开始","起来","2.0","运行","进入","多","以下","！","该","命令","python3","请","有","因","很","避免","¶","交互","指示","在线","国内","打包","client","api","）","upgrade","电脑","无线","代表","版本","robomaster","文件夹","里","占用","分利","导致","指示灯","操作","插件","使用","python3.7","=","node","更"," ","它","显示","命令行","与","这个","热点","连","adapte","到","是","环境","网卡","mac","3.0","能力","选择","目前","控制"],"title":"Tello3.0","title_tokens":["tello3.0"]},{"location":"extension_guide/tello3/#tello-30","text":"Tello 插件的 3.0 版本， 基于 DJI 官方的 SDK: RoboMaster SDK 库。 能够充分利用设备的能力。 相比于 Tello 2.0 插件 ，3.0能够 控制 LED","text_tokens":["的","版本","能够","基于",":","robomaster","led","相比","分利","。","插件","库","利用","，"," ","dji","于","2.0","sdk","设备","官方","充分利用","tello","3.0","能力","充分","控制"],"title":"Tello 3.0","title_tokens":["3.0","tello"," "]},{"location":"extension_guide/tello3/#_1","text":"目前该插件并未内置到 Adapter 中（因其复杂的打包依赖，而且跨平台兼容性不好）。 我们目前将插件构建为 Adapter Node ，可以在Adapter外部以普通Python文件运行，一旦运行起来，与普通Adapter插件是一样的，能够与Adapter体系的所有事物交互。","text_tokens":["的","能够","一旦","所有","可以","跨平台","在","依赖","兼容性","外部","并未","。","其","内置","不好","体系","容性","插件","而且","我们","，","（","node"," ","事物","文件","构建","起来","普通","将","与","python","运行","中","该","到","平台","是","因","为","兼容","adapter","一样","复杂","交互","打包","以","目前","）"],"title":"使用说明","title_tokens":["说明","使用"]},{"location":"extension_guide/tello3/#python","text":"首先你本地需要有 Python 环境（ Python>=3.6 ） 你可以到 Python 官方 下载，也可以使用 CodeLab放在 国内的版本(Python3.7) 提醒 Mac 用户和 Linux 本地很可能内置了 Python3","text_tokens":["的","本地","版本","(","可以","用户","可能","你","内置","也","下载","，","使用",">","=","（","python3.7"," ","和","放在",")","python","官方","到","需要","环境","python3","有","很","codelab","首先","linux","了","mac","3.6","国内","提醒","）"],"title":"Python环境","title_tokens":["环境","python"]},{"location":"extension_guide/tello3/#_2","text":"pip install robomaster codelab_adapter_client --upgrade","text_tokens":["pip","-","codelab","adapter","robomaster","_"," ","client","install","upgrade"],"title":"安装依赖","title_tokens":["安装","依赖"]},{"location":"extension_guide/tello3/#_3","text":"提醒 Tello 会占用 wifi，导致电脑无法联网，请使用 CodeLab Adapter 的离线模式: FAQ：离线使用 (在 >=3.4.0 的版本中可用)。 更好的方式可能是将Tello接入路由器上，或者使用USB无线网卡，避免电脑无法上网。","text_tokens":["联网","的","(","版本","方式","可能",":","在","上","占用","wifi","3.4","。","：","上网","0","导致","无法","使用","，","faq",">","=","路由","或者","可用"," ",")","离线","更好","路由器","将","中","是","请","避免","模式",".","网卡","codelab","adapter","usb","tello","提醒","会","接入","电脑","无线"],"title":"开始！","title_tokens":["开始","！"]},{"location":"extension_guide/tello3/#1-codelab-scratch","text":"运行CodeLab Adapter， 确保在线平台与Adapte连接正常。 看到 CodeLab Scratch 指示灯显示绿色，代表连接成功。","text_tokens":["代表","看到","。","指示灯","绿色","，"," ","成功","连接","确保","显示","正常","与","运行","adapte","平台","scratch","codelab","adapter","指示","在线"],"title":"步骤 1：打开 CodeLab Scratch","title_tokens":["1","步骤","codelab"," ","：","scratch","打开"]},{"location":"extension_guide/tello3/#1node_tello3py","text":"将 node_tello3.py 插件下载到本地（随便放在一个文件夹里），在命令行中进入到这个文件夹，使用 python node_tello3.py 运行它。","text_tokens":["本地","py","一个","文件夹","里","在","。","插件","下载","，","使用","node","（"," ","文件","tello3","放在","它","命令行","将","python","进入","_","这个","运行","中","到","命令",".","件夹","随便","）"],"title":"步骤 1：运行node_tello3.py","title_tokens":[".","1","步骤","py","node","运行","_"," ","：","tello3"]},{"location":"extension_guide/tello3/#2-tello","text":"将电脑连上 Tello 的 wifi 热点。（操作细节可以参考 Tello 说明书）","text_tokens":["说明书","操作","的","可以","将","tello","（","上","热点","参考","wifi"," ","细节","连","说明","。","）","电脑"],"title":"步骤 2：连接 Tello","title_tokens":["步骤","2","tello"," ","连接","："]},{"location":"extension_guide/tello3/#3","text":"选择 scratch3 中的 EIM 插件. 以下是一个简单 demo: tello3-demo 起飞吧！","text_tokens":["的","-","一个",":","demo","起飞","插件","简单","scratch3"," ","tello3","以下","中","吧","！","是",".","选择","eim"],"title":"步骤 3: 起飞吧!","title_tokens":["3","!","步骤",":"," ","吧","起飞"]},{"location":"extension_guide/tello3/#_4","text":"更多API参考文档: RoboMaster SDK","text_tokens":["sdk","更",":","robomaster","多","参考"," ","api","文档"],"title":"进阶","title_tokens":["进阶"]},{"location":"extension_guide/tensorflow-yolov4/","text":"Tutorial ¶ tensorflow-yolov4 ， 请参考文档，安装相应依赖。 接入方法参考 Python对象的连接器：EIM 插件 使用前请将 coco.names 和 yolov4-tiny.weights 下载到对应目录。 from codelab_adapter_client.utils import run_monitor , save_base64_to_image from yolov4.tf import YOLOv4 import cv2 import cv2 import numpy as np yolo = YOLOv4 ( tiny = True ) yolo . classes = \"/tmp/coco.names\" yolo . make_model () yolo . load_weights ( \"/tmp/yolov4-tiny.weights\" , weights_type = \"yolo\" ) def monitor ( msg ): filename = save_base64_to_image ( msg , \"/tmp/tmp_img\" ) original_image = cv2 . imread ( filename ) resized_image = cv2 . cvtColor ( original_image , cv2 . COLOR_BGR2RGB ) resized_image = yolo . resize_image ( resized_image ) resized_image = resized_image / 255 input_data = resized_image [ np . newaxis , ... ] . astype ( np . float32 ) candidates = yolo . model . predict ( input_data ) print ( candidates ) # yolo.inference(media_path=filename) run_monitor ( monitor )","text_tokens":[",","的","(","安装","tmp","data","predict","resized","tutorial","names","as","print","import","]","path","imread","make","对应",".","msg","codelab","adapter","original","接入","numpy","-","utils",":","\"","media","inference","run","下载","参考","和",")","/","将","candidates","python","目录","from","_","tiny","相应","接器","weights","astype","filename","...","yolov4","eim","前","255","依赖","。","文档","：","tf","model","resize","，","cvtcolor","to","#","连接","color","save","np","方法","base64","连接器","请","monitor","float32","true","¶","client","load","yolo","tensorflow","[","插件","使用","="," ","img","def","classes","cv2","type","bgr2rgb","到","newaxis","input","image","对象","coco"],"title":"tensorflow-yolov4","title_tokens":["tensorflow","-","yolov4"]},{"location":"extension_guide/tensorflow-yolov4/#tutorial","text":"tensorflow-yolov4 ， 请参考文档，安装相应依赖。 接入方法参考 Python对象的连接器：EIM 插件 使用前请将 coco.names 和 yolov4-tiny.weights 下载到对应目录。 from codelab_adapter_client.utils import run_monitor , save_base64_to_image from yolov4.tf import YOLOv4 import cv2 import cv2 import numpy as np yolo = YOLOv4 ( tiny = True ) yolo . classes = \"/tmp/coco.names\" yolo . make_model () yolo . load_weights ( \"/tmp/yolov4-tiny.weights\" , weights_type = \"yolo\" ) def monitor ( msg ): filename = save_base64_to_image ( msg , \"/tmp/tmp_img\" ) original_image = cv2 . imread ( filename ) resized_image = cv2 . cvtColor ( original_image , cv2 . COLOR_BGR2RGB ) resized_image = yolo . resize_image ( resized_image ) resized_image = resized_image / 255 input_data = resized_image [ np . newaxis , ... ] . astype ( np . float32 ) candidates = yolo . model . predict ( input_data ) print ( candidates ) # yolo.inference(media_path=filename) run_monitor ( monitor )","text_tokens":[",","的","(","安装","tmp","data","predict","resized","names","as","print","import","]","path","imread","make","对应",".","msg","codelab","adapter","original","接入","numpy","-","utils",":","\"","media","inference","run","下载","参考","和",")","/","将","candidates","python","目录","from","_","tiny","相应","接器","weights","astype","filename","...","yolov4","eim","前","255","依赖","。","文档","：","tf","model","resize","，","cvtcolor","to","#","连接","color","save","np","方法","base64","连接器","请","monitor","float32","true","client","load","yolo","tensorflow","[","插件","使用","="," ","img","def","classes","cv2","type","bgr2rgb","到","newaxis","input","image","对象","coco"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/tensorflow/","text":"Tensorflow ¶ 参考 运行在树莓派中的 codelab-adapter tensorflow 插件 。","text_tokens":["的","-","树莓","codelab","插件","¶","adapter","tensorflow","在","运行","参考","派"," ","中","。"],"title":"Tensorflow(正在迁移中)","title_tokens":["正在","(","tensorflow","迁移","中",")"]},{"location":"extension_guide/tensorflow/#tensorflow","text":"参考 运行在树莓派中的 codelab-adapter tensorflow 插件 。","text_tokens":["的","-","树莓","codelab","插件","adapter","tensorflow","在","运行","参考","派"," ","中","。"],"title":"Tensorflow","title_tokens":["tensorflow"]},{"location":"extension_guide/tuio/","text":"TUIO ¶","text_tokens":["¶"," ","tuio"],"title":"TUIO","title_tokens":["tuio"]},{"location":"extension_guide/tuio/#tuio","text":"","text_tokens":[],"title":"TUIO","title_tokens":["tuio"]},{"location":"extension_guide/uart_adapter/","text":"Tutorial ¶ 通用的串口(UART)积木，可从串口中读写数据。 例子 ¶ 以下例子展示 如何使用 extension_uart_adapter 插件与自定义的microbit固件交互。 microbit 固件源码 为: Scratch 与之交互的部分: 上边的例子展示了典型的 典型应用场景 ¶ 该插件的典型应用场景是，允许开发者使用Scratch与自定义的固件(支持uart)交互。","text_tokens":["展示","的","(","之","开发者","应用",":","如何","例子","通用","。","microbit","部分","典型","开发","插件","使用","，","积木","自定义","extension","上边","数据"," ","tutorial",")","可","定义","uart","自定","与","固件","_","串口","以下","从","中","该","源码","scratch","是","允许","为","¶","adapter","了","读写","交互","支持","场景"],"title":"UART Adapter","title_tokens":["adapter"," ","uart"]},{"location":"extension_guide/uart_adapter/#tutorial","text":"通用的串口(UART)积木，可从串口中读写数据。","text_tokens":["的","(","uart","积木","，","读写","串口","数据","从","中","通用","。",")","可"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/uart_adapter/#_1","text":"以下例子展示 如何使用 extension_uart_adapter 插件与自定义的microbit固件交互。 microbit 固件源码 为: Scratch 与之交互的部分: 上边的例子展示了典型的","text_tokens":["展示","的","之",":","如何","例子","典型","。","microbit","部分","插件","使用","自定义","extension","上边"," ","定义","uart","自定","与","固件","_","以下","源码","scratch","为","adapter","了","交互"],"title":"例子","title_tokens":["例子"]},{"location":"extension_guide/uart_adapter/#_2","text":"该插件的典型应用场景是，允许开发者使用Scratch与自定义的固件(支持uart)交互。","text_tokens":["的","开发者","(","应用","开发","典型","。","插件","使用","，","自定义",")","定义","uart","自定","与","固件","该","是","scratch","允许","交互","支持","场景"],"title":"典型应用场景","title_tokens":["应用","场景","典型"]},{"location":"extension_guide/usage/","text":"Usage ¶ 你可以将 extension market 中的插件下载到本地使用。 在 CodeLab Adapter 中下载插件很简单，点击 菜单>插件>下载 ，弹出输入框，将插件的 url 链接复制粘贴其中即可。 下载完成之后重启软件，即可看到插件。 所有插件列表在 codelab_adapter_extensions 。","text_tokens":["即可","的","本地","可以","在","输入","看到","列表","你","。","复制","插件","简单","下载","使用","，",">","输入框","extension","之后","软件","完成"," ","链接","重启","其中","extensions","复制粘贴","将","_","弹","中","到","很","usage","codelab","¶","adapter","market","菜单","所有","url","点击","粘贴","出"],"title":"使用(Usage)","title_tokens":["usage",")","使用","("]},{"location":"extension_guide/usage/#usage","text":"你可以将 extension market 中的插件下载到本地使用。 在 CodeLab Adapter 中下载插件很简单，点击 菜单>插件>下载 ，弹出输入框，将插件的 url 链接复制粘贴其中即可。 下载完成之后重启软件，即可看到插件。 所有插件列表在 codelab_adapter_extensions 。","text_tokens":["即可","的","本地","可以","在","输入","看到","列表","你","。","复制","插件","简单","下载","使用","，",">","输入框","extension","之后","软件","完成"," ","链接","重启","其中","extensions","复制粘贴","将","_","弹","中","到","很","codelab","adapter","market","菜单","所有","url","点击","粘贴","出"],"title":"Usage","title_tokens":["usage"]},{"location":"extension_guide/vector/","text":"Vector ¶ Anki is a company whose products always seem to delight. Codelab Adapter is a software that connect Scratch 3.0 to the open-source hardware, IoT and AI. We make a Codelab Adapter extension to connect Vector to Scratch 3.0. It just like Cozmo codelab. Now the Vector extension is built into the Codelab Adapter ! Video tutorial ¶ for Windows ¶ for MacOS/Linux ¶ Tutorial ¶ install codelab_adapter_client ¶ Python >= 3.6 Linux/MacOS user: python3 -m pip install codelab_adapter_client --upgrade --user windows user: python -m pip install codelab_adapter_client --upgrade --user Install the SDK on your system ¶ Follow Vector official tutorial: Initial Setup 提醒 如果 Vector 的 IP发生了变化（诸如将Vector 带入新的 wifi 环境），不需要重新认证(python3 -m anki_vector.configure), 只需要修本地改配置文件即可（第一次认证留下的）, 配置文件为: ~/.anki_vector/sdk_config.ini If the following code ( hello_world.py ) runs smoothly, go to the next step. ''' MacOS: /usr/local/bin/python3 hello_world.py linux: /usr/bin/python3 hello_world.py Windows: python hello_world.py ''' import anki_vector from codelab_adapter_client import AdapterNode def main (): args = anki_vector . util . parse_command_args () with anki_vector . Robot ( args . serial ) as robot : print ( \"Say 'Hello World'...\" ) robot . behavior . say_text ( \"Hello World\" ) if __name__ == \"__main__\" : main () Download Codelab Adapter ¶ Download Codelab Adapter run it Open Scratch 3.0 ¶ open CodeLab Scratch3 Open extension_vector ¶ Ok! Enjoy it :) Tip Tool for watching the camera feed and test animations of Anki's robot Vector: Vector-Explorer-Tool Here are some demo cases（just like Cozmo CodeLab）: Vector and Leap Motion ¶ Switch Labo and Vector ¶ Candy Language for Vector ¶ Advanced ¶ You can create your own custom blocks based on the exec block . Almost all Vector SDK API work.","text_tokens":[",","的","带入","(","go","step","with","next","wifi","test","demo","some","now","pip","如果","into",">","（","system","enjoy","tutorial","products","cases","anki","留下","'","发生","as","print","sdk","setup","import","tool","command","scratch","需要","make","can",".","configure","为","codelab","and","adapter","for","了","3.6","改","新","we","即可","animations","-","本地","hardware","usr","py",":","ai","~","exec","第一次","\"","cozmo","install","s","run","it","almost","delight","tip","smoothly","extension","util","create","ip","your","vector","第一","文件","诸如","camera","feed","of","advanced",")","__","whose","m","/","world","follow","将","initial","python","_","from","seem","local","linux","配置","配置文件","here","...","只","提醒","!","built","official","own","bin","，","hello","to","scratch3","work","变化","motion","config","ini","switch","always","iot","ok","认证","runs","video","python3","say","custom","code","¶","main","api","client","a","upgrade","like","）","text","download","behavior","on","args","connect","based","leap","一次","explorer","source","=","serial","are","candy"," ","language","following","software","blocks","open","def","修","all","adapternode","windows","company","the","just","不","you","watching","user","that","环境","if","block","robot","parse","name","labo","重新","3.0","is","macos"],"title":"Vector","title_tokens":["vector"]},{"location":"extension_guide/vector/#vector","text":"Anki is a company whose products always seem to delight. Codelab Adapter is a software that connect Scratch 3.0 to the open-source hardware, IoT and AI. We make a Codelab Adapter extension to connect Vector to Scratch 3.0. It just like Cozmo codelab. Now the Vector extension is built into the Codelab Adapter !","text_tokens":[",","!","-","hardware","ai","built","connect","is","cozmo","now","it","source","into","delight","extension","to"," ","vector","software","products","anki","open","whose","always","iot","company","the","seem","just","that","scratch","make",".","codelab","and","adapter","3.0","a","we","like"],"title":"Vector","title_tokens":["vector"]},{"location":"extension_guide/vector/#video-tutorial","text":"","text_tokens":[],"title":"Video tutorial","title_tokens":["tutorial"," ","video"]},{"location":"extension_guide/vector/#for-windows","text":"","text_tokens":[],"title":"for Windows","title_tokens":["for","windows"," "]},{"location":"extension_guide/vector/#for-macoslinux","text":"","text_tokens":[],"title":"for MacOS/Linux","title_tokens":["/","for","linux"," ","macos"]},{"location":"extension_guide/vector/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/vector/#install-codelab_adapter_client","text":"Python >= 3.6 Linux/MacOS user: python3 -m pip install codelab_adapter_client --upgrade --user windows user: python -m pip install codelab_adapter_client --upgrade --user","text_tokens":["-",":","install","pip",">","="," ","m","/","windows","python","_","upgrade","user","python3","codelab","linux","adapter","3.6","client","macos"],"title":"install codelab_adapter_client","title_tokens":["codelab","adapter","_"," ","client","install"]},{"location":"extension_guide/vector/#install-the-sdk-on-your-system","text":"Follow Vector official tutorial: Initial Setup 提醒 如果 Vector 的 IP发生了变化（诸如将Vector 带入新的 wifi 环境），不需要重新认证(python3 -m anki_vector.configure), 只需要修本地改配置文件即可（第一次认证留下的）, 配置文件为: ~/.anki_vector/sdk_config.ini If the following code ( hello_world.py ) runs smoothly, go to the next step. ''' MacOS: /usr/local/bin/python3 hello_world.py linux: /usr/bin/python3 hello_world.py Windows: python hello_world.py ''' import anki_vector from codelab_adapter_client import AdapterNode def main (): args = anki_vector . util . parse_command_args () with anki_vector . Robot ( args . serial ) as robot : print ( \"Say 'Hello World'...\" ) robot . behavior . say_text ( \"Hello World\" ) if __name__ == \"__main__\" : main ()","text_tokens":[",","的","带入","(","go","step","with","next","wifi","如果","（","tutorial","anki","留下","'","发生","as","print","sdk","setup","import","command","需要",".","configure","为","codelab","了","改","adapter","新","即可","-","本地","usr","py",":","~","第一次","\"","smoothly","util","ip","第一","vector","文件","诸如",")","__","m","/","world","follow","将","initial","python","_","from","local","配置","linux","配置文件","...","只","提醒","official","bin","，","hello","to","变化","config","ini","认证","runs","python3","say","code","main","client","）","text","behavior","args","一次","=","serial"," ","following","def","修","adapternode","windows","the","不","环境","if","robot","parse","name","重新","macos"],"title":"Install the SDK on your system","title_tokens":["sdk","on","system","your"," ","the","install"]},{"location":"extension_guide/vector/#download-codelab-adapter","text":"Download Codelab Adapter run it","text_tokens":["it","codelab","adapter"," ","download","run"],"title":"Download Codelab Adapter","title_tokens":["adapter"," ","download","codelab"]},{"location":"extension_guide/vector/#open-scratch-30","text":"open CodeLab Scratch3","text_tokens":["scratch3","codelab"," ","open"],"title":"Open Scratch 3.0","title_tokens":["3.0"," ","scratch","open"]},{"location":"extension_guide/vector/#open-extension_vector","text":"Ok! Enjoy it :) Tip Tool for watching the camera feed and test animations of Anki's robot Vector: Vector-Explorer-Tool Here are some demo cases（just like Cozmo CodeLab）:","text_tokens":["animations","!","-",":","like","demo","cozmo","s","some","it","explorer","tip","（","enjoy","are"," ","camera","of","vector","cases","feed","anki",")","'","）","ok","tool","the","just","watching","robot","codelab","for","and","here","test"],"title":"Open extension_vector","title_tokens":["extension","_","vector"," ","open"]},{"location":"extension_guide/vector/#vector-and-leap-motion","text":"","text_tokens":[],"title":"Vector and Leap Motion","title_tokens":["and","vector"," ","leap","motion"]},{"location":"extension_guide/vector/#switch-labo-and-vector","text":"","text_tokens":[],"title":"Switch Labo and Vector","title_tokens":["switch","and","labo"," ","vector"]},{"location":"extension_guide/vector/#candy-language-for-vector","text":"","text_tokens":[],"title":"Candy Language for Vector","title_tokens":["for","candy","vector"," ","language"]},{"location":"extension_guide/vector/#advanced","text":"You can create your own custom blocks based on the exec block . Almost all Vector SDK API work.","text_tokens":["on","exec","own","based","almost","create","work","your"," ","vector","blocks","all","sdk","you","the","can","block",".","custom","api"],"title":"Advanced","title_tokens":["advanced"]},{"location":"extension_guide/webserver/","text":"web server ¶ 插件介绍 ¶ 通过启用 extension_webserver 插件，允许用户将 CodeLab Adapter 当作 web 服务器，构建自己的网站。 基于 bottle Tips 网站运行在 18080 端口。 可以使用 ngrok 、 花生壳 等工具，将你刚制作的网站公布到 互联网上。","text_tokens":["联网","的","用户","基于","webserver","可以","在","上","你","。","公布","插件","使用","，","web","extension"," ","当作","花生","构建","互联网","bottle","18080","端口","工具","互联","将","自己","花生壳","tips","运行","启用","_","服务","等","刚","ngrok","制作","服务器","到","通过","server","允许","codelab","务器","、","¶","介绍","adapter","网站"],"title":"webserver","title_tokens":["webserver"]},{"location":"extension_guide/webserver/#web-server","text":"","text_tokens":[],"title":"web server","title_tokens":["server","web"," "]},{"location":"extension_guide/webserver/#_1","text":"通过启用 extension_webserver 插件，允许用户将 CodeLab Adapter 当作 web 服务器，构建自己的网站。 基于 bottle Tips 网站运行在 18080 端口。 可以使用 ngrok 、 花生壳 等工具，将你刚制作的网站公布到 互联网上。","text_tokens":["联网","的","用户","基于","webserver","可以","在","上","你","。","公布","插件","使用","，","web","extension"," ","当作","花生","构建","互联网","bottle","18080","端口","工具","互联","将","自己","花生壳","tips","运行","启用","_","服务","等","刚","ngrok","制作","服务器","到","通过","允许","codelab","务器","、","adapter","网站"],"title":"插件介绍","title_tokens":["介绍","插件"]},{"location":"extension_guide/wechat/","text":"Tutorial ¶ 依赖 ¶ 安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器. 步骤 1：打开 Codelab Adapter ¶ 双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。 步骤 2：打开 Codelab Scratch3 ¶ 点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常 步骤 3：加载 CodeLab Adapter 微信插件 ¶ 在 Web UI 中点击加载 extension_wechat 插件: 插件运行后，会弹出二维码，用微信扫码即可登陆。 在 Scratch 3.0 中使用微信插件 ¶ 演示 ¶","text_tokens":[",","的","步骤","扫码","安装","上","绿色","1","二维","tutorial","说明","用","浏览器","正常","这儿","后","scratch","现阶段",".","为","启动","codelab","adapter","点击","即可","小圆点","其设",":","在","二维码","箭头","ui","wechat","微信","之后","extension","链接","效果","/","将","圆点","_","官方","中","登陆","演示","chrome","双击","2","支持","陆续","出","呈现","浏览","依赖","建议","。","：","打开","3","firefox","，","或者","页面","web","scratch3","连接","会弹","加载","运行","多","如下","¶","默认","阶段","版本","插件","使用","更"," ","与","图中","团队","scratch3.0","3.0","所指","目前","最佳"],"title":"wechat","title_tokens":["wechat"]},{"location":"extension_guide/wechat/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/wechat/#_1","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"依赖","title_tokens":["依赖"]},{"location":"extension_guide/wechat/#1-codelab-adapter","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"步骤 1：打开 Codelab Adapter","title_tokens":["1","步骤","codelab","adapter"," ","：","打开"]},{"location":"extension_guide/wechat/#2-codelab-scratch3","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常","text_tokens":[",","小圆点","呈现","的",":","上","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"步骤 2：打开 Codelab Scratch3","title_tokens":["步骤","codelab","2","scratch3"," ","：","打开"]},{"location":"extension_guide/wechat/#3-codelab-adapter","text":"在 Web UI 中点击加载 extension_wechat 插件: 插件运行后，会弹出二维码，用微信扫码即可登陆。","text_tokens":["即可","扫码",":","在","二维码","。","ui","插件","wechat","，","二维","微信","web","extension"," ","用","会弹","加载","运行","_","中","后","登陆","点击","出"],"title":"步骤 3：加载 CodeLab Adapter 微信插件","title_tokens":["3","插件","步骤","codelab","微信","加载","adapter"," ","："]},{"location":"extension_guide/wechat/#scratch-30","text":"","text_tokens":[],"title":"在 Scratch 3.0 中使用微信插件","title_tokens":["插件","使用","微信","在","3.0"," ","中","scratch"]},{"location":"extension_guide/wechat/#_2","text":"","text_tokens":[],"title":"演示","title_tokens":["演示"]},{"location":"extension_guide/yanshee/","text":"Tutorial ¶ 介绍 ¶ Yanshee 是一个开源人形机器人教学平台， 面向高中和大学生开发，提供专业开源学习软件。 Yanshee 是一个开放的硬件平台，采用Raspberry Pi + STM32 开放式硬件平台架构，内嵌陀螺仪，开放GPIO接口。 采用基于Linux的开源软件架构，支持用户直接调用并集成海量的Raspberry Pi的开源软件模块 Demo ¶ Scratch-Yanshee","text_tokens":["架构","的","-","提供","raspberry","基于","用户","一个","接口","人形","机器人","教学","并","集成","开发","。","开放","demo","学生","海量","，","软件","硬件","采用","开放式"," ","pi","stm32","tutorial","和","直接","gpio","开源","模块","yanshee","内嵌","陀螺仪","软件架构","平台","是","scratch","陀螺","¶","介绍","linux","调用","硬件平台","学习","大学生","+","支持","面向","机器","大学","专业","高中"],"title":"Yanshee","title_tokens":["yanshee"]},{"location":"extension_guide/yanshee/#tutorial","text":"","text_tokens":[],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"extension_guide/yanshee/#_1","text":"Yanshee 是一个开源人形机器人教学平台， 面向高中和大学生开发，提供专业开源学习软件。 Yanshee 是一个开放的硬件平台，采用Raspberry Pi + STM32 开放式硬件平台架构，内嵌陀螺仪，开放GPIO接口。 采用基于Linux的开源软件架构，支持用户直接调用并集成海量的Raspberry Pi的开源软件模块","text_tokens":["架构","的","提供","raspberry","基于","用户","一个","接口","人形","机器人","教学","并","集成","开发","。","开放","学生","海量","，","软件","硬件","采用","开放式"," ","pi","stm32","和","直接","gpio","开源","模块","yanshee","内嵌","陀螺仪","软件架构","平台","是","机器","陀螺","linux","调用","硬件平台","学习","+","支持","面向","大学生","大学","专业","高中"],"title":"介绍","title_tokens":["介绍"]},{"location":"extension_guide/yanshee/#demo","text":"Scratch-Yanshee","text_tokens":["-","scratch","yanshee"],"title":"Demo","title_tokens":["demo"]},{"location":"extension_guide/yeelight/","text":"yeelight ¶ 使用 Adapter 直接驱动 yeelight，不需要 Home Assistant/LonganHub 插件源码: node_yeelight.py Scratch Demo ¶ Scratch EIM demo 社区版 文档 ¶ yeelight yeelight 速率限制为每分钟60个。如果你想解除限制，则需要使用: Music mode : bulb.start_music()","text_tokens":["(","py",":","版","你","demo","文档","。","分钟","mode","如果","插件","使用","，","node","longanhub","速率"," ",")","直接","个","home","社区","/","_","解除","不","想","bulb","源码","需要","yeelight","驱动","scratch","music",".","为","每分钟","assistant","¶","adapter","限制","start","则","eim","解除限制","60"],"title":"yeelight","title_tokens":["yeelight"]},{"location":"extension_guide/yeelight/#yeelight","text":"使用 Adapter 直接驱动 yeelight，不需要 Home Assistant/LonganHub 插件源码: node_yeelight.py","text_tokens":["py",":","插件","使用","，","node","longanhub"," ","直接","home","/","_","不","源码","需要","yeelight","驱动",".","assistant","adapter"],"title":"yeelight","title_tokens":["yeelight"]},{"location":"extension_guide/yeelight/#scratch-demo","text":"Scratch EIM demo 社区版","text_tokens":["社区","版"," ","eim","demo","scratch"],"title":"Scratch Demo","title_tokens":[" ","scratch","demo"]},{"location":"extension_guide/yeelight/#_1","text":"yeelight yeelight 速率限制为每分钟60个。如果你想解除限制，则需要使用: Music mode : bulb.start_music()","text_tokens":["(",":","你","。","分钟","mode","如果","使用","，","速率"," ",")","个","_","解除","想","bulb","yeelight","需要","music",".","为","每分钟","限制","start","则","解除限制","60"],"title":"文档","title_tokens":["文档"]},{"location":"extension_guide/yolo/","text":"Tutorial ¶ hello world","text_tokens":["world","¶","hello"," ","tutorial"],"title":"yolo","title_tokens":["yolo"]},{"location":"extension_guide/yolo/#tutorial","text":"hello world","text_tokens":["world"," ","hello"],"title":"Tutorial","title_tokens":["tutorial"]},{"location":"get_start/gs_adapter_intro/","text":"Codelab Adapter 概览 ¶ 大家可能会好奇， 魔杖一挥 是怎么将所有灯都关闭的，又是怎么做到将手抬起， 窗帘就顺应而升 的? 其实这些神奇的场景都是在Adapter的帮助下完成的。 Adapter使用 扩展 将两个事物连接起来，在魔杖亮灯的场景中，Adapter将魔杖和灯连接起来，我们在创作平台中利用Adapter提供的扩展对魔杖和灯进行编程，之后用魔杖画出相应的手势，灯就亮起来了。 Adapter的核心组件 ¶ Adapter的扩展分为 插件 和 节点 ，有小伙伴会问到：“为什么都是扩展，还要区分为不同的两个东西啊？” 这主要是因为插件和节点所需要的依赖不同，相比于插件，节点需要的依赖会更多也更复杂，比如说用手势控制窗帘升降用到的扩展就是节点。 如果想进一步了解请看 插件和节点的区别 在简单介绍Adatper的具体组件后，我们进入安装环节。","text_tokens":["的","扩展","“","所","安装","又","窗帘","伙伴","相比","比如说","如果","我们","就","利用","简单","为什么","事物","亮灯","比如","用","于","是因为","什么","这些","后","平台","需要","”","为","codelab","怎么","adapter","了","介绍","环节","画出","下","所有","会","因为","区别","分为","可能","小伙伴","在","好奇","抬起","主要","一步","两个","手势","区分","大家","之后","灯","和","核心","将","中","相应","想","对","组件","?","复杂","场景","依赖","。","：","东西","也","，","一挥","完成","亮","就是","用到","不同","连接","起来","看","顺应","接起","？","这","其实","多","进入","问到","请","有","¶","神奇","进行","提供","魔杖","小伙","概览","关闭","而升","插件","使用","更","创作"," ","编程","进一步","啊","做到","都","节点","升降","连接起来","是","adatper","还要","帮助","手","了解","具体","控制"],"title":"Adapter简介","title_tokens":["adapter","简介"]},{"location":"get_start/gs_adapter_intro/#codelab-adapter","text":"大家可能会好奇， 魔杖一挥 是怎么将所有灯都关闭的，又是怎么做到将手抬起， 窗帘就顺应而升 的? 其实这些神奇的场景都是在Adapter的帮助下完成的。 Adapter使用 扩展 将两个事物连接起来，在魔杖亮灯的场景中，Adapter将魔杖和灯连接起来，我们在创作平台中利用Adapter提供的扩展对魔杖和灯进行编程，之后用魔杖画出相应的手势，灯就亮起来了。","text_tokens":["的","提供","扩展","可能","在","好奇","魔杖","又","抬起","窗帘","关闭","。","两个","而升","下","手势","我们","就","使用","，","大家","利用","一挥","之后","完成","亮","创作","灯"," ","事物","亮灯","连接","和","用","编程","起来","顺应","将","做到","接起","其实","都","中","相应","这些","连接起来","是","场景","平台","对","怎么","adapter","帮助","手","神奇","了","?","画出","所有","会","进行"],"title":"Codelab Adapter 概览","title_tokens":["adapter"," ","概览","codelab"]},{"location":"get_start/gs_adapter_intro/#adapter","text":"Adapter的扩展分为 插件 和 节点 ，有小伙伴会问到：“为什么都是扩展，还要区分为不同的两个东西啊？” 这主要是因为插件和节点所需要的依赖不同，相比于插件，节点需要的依赖会更多也更复杂，比如说用手势控制窗帘升降用到的扩展就是节点。 如果想进一步了解请看 插件和节点的区别 在简单介绍Adatper的具体组件后，我们进入安装环节。","text_tokens":["的","扩展","“","所","安装","小伙伴","在","依赖","伙伴","小伙","主要","相比","窗帘","一步","比如说","区别","。","：","两个","东西","手势","如果","插件","区分","也","，","简单","我们","为什么","更","就是"," ","比如","不同","用到","和","用","于","看","进一步","啊","？","这","多","进入","是因为","都","节点","什么","具体","想","升降","问到","后","是","需要","请","adatper","有","还要","”","为","adapter","介绍","组件","环节","复杂","了解","会","因为","分为","控制"],"title":"Adapter的核心组件","title_tokens":["adapter","的","核心","组件"]},{"location":"get_start/gs_install/","text":"安装 Codelab Adapter ¶ 版本介绍 ¶ 经过Adapter的概览，我们了解了Adapter的大致功能，以及插件和节点的功能。 下面我们来安装CodeLab Adapter（简称Adapter）。 目前 CodeLab Adapter v3 可以在Mac、 Windows、 Linux、Raspbian（树莓派） 平台上正常运行。Adapter目前有分为两个版本可供小伙伴们选择 完整版 和 精简版 。这两个版本该如何选择呢？ 版本 Adapter Extension（插件） Adapter Node（节点） 目标用户 完整版 Yes Yes 初学者 精简版 Yes No(需要Python依赖) 喜欢折腾和自定义的用户 附：Adpater完整版所用到的 Python第三方库 Codelab Adapter下载链接 ¶ 最新版本: 4.1.0 操作系统 完整版 精简版 系统要求 安装注意事项 macOS macFull.zip 无 macOS 10.13.5（64位）+ mac安装步骤 Windows winFull.zip 无 Win 7 /8 /10 （32位/64位） win安装步骤 Linux 无 linux.zip(4.0.0) 经测试发行版Ubuntu、Kail、ArchLinux linux安装步骤 Raspbian（树莓派） 无 rpi.zip(3.7.4) 低于buster的版本可能无法运行 树莓派安装步骤 附:各个版本的哈希值(Sha256) 在Mac中安装Adapter ¶ 下载 双击.zip格式文件就会得到可执行的Adapter 点击右键打开，会出现 点击打开就会弹出Adapter的浏览器页面 到此在Mac中安装Adapter完成。 温馨提示：在 macOS 10.15 打开软件可能会比较慢(有时需要3-5秒)，问题目前在定位中，但在打开后不影响使用。 在Windows中安装Adapter ¶ 下载 右键解压,然后进入解压后的文件夹, 双击 CodeLab-Adapter 文件。（提醒: 最好不要重命名文件夹，如果要重命名，确保名字中没有中文和空格） 运行Adapter，会自动弹出默认浏览器（推荐使用Firefox或者Chrome浏览器）。 如果出现防火墙的警报，点击允许访问就好了。 看到一下界面就说明安装成功了。 温馨提示：Windows 7下最好以管理员权限运行。 Linux中安装Adapter ¶ 下载 用unzip命令解压 在命令行中运行Adapter就会自动弹出 温馨提示： 无法运行请赋予可执行权限 chmod u+x Adapter软件名 在Ubuntu 16.04下可能无法自动打开浏览器。建议在命令行下启动它，你将看到 https://codelab-adapter.codelab.club:12358/ , 这个链接即是 WebUI 当前经测试的发行版有Ubuntu，Kali，ArchLinux 在Raspbian中安装Adapter(build中...) ¶ 下载 解压 赋予运行权限： chmod +x Adapter软件名 ，再双击运行 也可以右键修改文件权限，使其可运行 界面概览 ¶ 在安装完Adapter之后，我们来看看Adapter的使用界面。 围绕着两个核心组件来看， 整个Adapter的界面就是关于 插件 和 节点 的管理。比如说，在控制台里， 我们可以查看插件和节点的启用状态，以及打开和关闭我们的插件。然后在创作平台中去使用它们。 以extension开头的就是插件，以node开头的就是节点。 接下来我们将进入使用Adapter的环节，通过两个例子看看Adapter可以做些什么吧。 在安装中如果遇到问题，欢迎 在Codelab社区 中提出。","text_tokens":[",","的","步骤","(","32","用户","安装","可以","最新","上","伙伴","目标","提示","呢","看到","赋予","你","10.13","比如说","其","接下来","执行","如果","防火墙","我们","rpi","自定义","就","软件","（","4.1","精简版","club","下面","比如","说明","完整版","问题","用","浏览器","正常","关于","社区","会自","kail","功能","buster","u","什么","下来","后","平台","需要",".","测试","格式文件","启动","codelab","build","去","adapter","介绍","了","火墙","环节","第三","得到","+","自动","要","以","下","会","ubuntu","点击","分为","值","-","可能","小伙伴",":","在","低于","重命名","看看","整版","https","没有","两个","kali","经过","经","操作系统","要求","下载","位","extension","之后","一下","8","派","成功","链接","文件","简称","3.7","和",")","有时","unzip","发行","折腾","核心","三方","自定","/","命名","来","注意","将","python","当前","启用","macfull","中","吧","空格","管理","名字","来看","解压","通过","winfull","件夹","、","chrome","webui","linux","双击","组件","整个","然后","大致","raspbian","...","yes","提醒","查看","出","它们","遇到","浏览","依赖","sha256","秒","如何","管理员","16.04","建议","64","好","着","。","：","哈希","0","防火","例子","打开","3","x","无法","库","树莓","发行版","，","zip","页面","较慢","推荐","v3","firefox","完成","或者","就是","状态","确保","此","接下","做些","可","供","会弹","定义","这","运行","？","进入","精简","系统","该","命令","请","有","所用","注意事项","比较慢","允许","权限","使","¶","以及","archlinux","比较","警报","默认","访问","也","4.0","win","）","定位","围绕","学者","版本","动弹","初学者","文件夹","界面","里","欢迎","小伙","7","10","概览","4","关闭","无","初学","chmod","自","再","各个","操作","喜欢","出现","插件","名","使用","12358","node","右键","格式","创作"," ","adpater","10.15","它","但","中文","提出","控制台","命令行","windows","不要","就会弹","这个","节点","完整","no","事项","温馨","不","影响","修改","到","是","最好","5","mac","即","们","了解","完","选择","附","目前","开头","macos","第三方","控制"],"title":"安装Adapter","title_tokens":["安装","adapter"]},{"location":"get_start/gs_install/#codelab-adapter","text":"","text_tokens":[],"title":"安装 Codelab Adapter","title_tokens":["安装"," ","codelab","adapter"]},{"location":"get_start/gs_install/#_1","text":"经过Adapter的概览，我们了解了Adapter的大致功能，以及插件和节点的功能。 下面我们来安装CodeLab Adapter（简称Adapter）。 目前 CodeLab Adapter v3 可以在Mac、 Windows、 Linux、Raspbian（树莓派） 平台上正常运行。Adapter目前有分为两个版本可供小伙伴们选择 完整版 和 精简版 。这两个版本该如何选择呢？ 版本 Adapter Extension（插件） Adapter Node（节点） 目标用户 完整版 Yes Yes 初学者 精简版 Yes No(需要Python依赖) 喜欢折腾和自定义的用户 附：Adpater完整版所用到的 Python第三方库","text_tokens":["的","(","用户","安装","可以","上","伙伴","目标","呢","我们","自定义","（","精简版","下面","完整版","正常","功能","平台","需要","codelab","adapter","了","第三","分为","小伙伴","在","整版","两个","经过","extension","派","简称","和",")","折腾","三方","自定","来","python","、","linux","大致","raspbian","yes","依赖","如何","。","：","库","树莓","，","v3","可","供","定义","这","运行","？","精简","该","有","所用","以及","）","学者","版本","初学者","小伙","概览","初学","喜欢","插件","node"," ","adpater","windows","节点","完整","no","到","mac","们","了解","选择","附","目前","第三方"],"title":"版本介绍","title_tokens":["介绍","版本"]},{"location":"get_start/gs_install/#download","text":"最新版本: 4.1.0 操作系统 完整版 精简版 系统要求 安装注意事项 macOS macFull.zip 无 macOS 10.13.5（64位）+ mac安装步骤 Windows winFull.zip 无 Win 7 /8 /10 （32位/64位） win安装步骤 Linux 无 linux.zip(4.0.0) 经测试发行版Ubuntu、Kail、ArchLinux linux安装步骤 Raspbian（树莓派） 无 rpi.zip(3.7.4) 低于buster的版本可能无法运行 树莓派安装步骤 附:各个版本的哈希值(Sha256)","text_tokens":["值","的","步骤","版本","32","(","安装","低于",":","可能","最新","sha256","整版","7","10","64","10.13","4","无","哈希","0","经","操作系统","操作","要求","无法","发行版","树莓","rpi","zip","各个","位","（","4.1","8","精简版","派"," ","3.7","完整版",")","发行","）","/","windows","注意","kail","运行","macfull","精简","完整","buster","事项","系统","注意事项",".","测试","winfull","ubuntu","、","linux","5","mac","archlinux","raspbian","+","附","4.0","win","macos"],"title":"Codelab Adapter下载链接","title_tokens":["codelab","下载","adapter"," ","链接"]},{"location":"get_start/gs_install/#mac","text":"下载 双击.zip格式文件就会得到可执行的Adapter 点击右键打开，会出现 点击打开就会弹出Adapter的浏览器页面 到此在Mac中安装Adapter完成。 温馨提示：在 macOS 10.15 打开软件可能会比较慢(有时需要3-5秒)，问题目前在定位中，但在打开后不影响使用。","text_tokens":["的","-","(","安装","可能","浏览","在","提示","秒","。","：","执行","打开","3","出现","就","下载","zip","，","页面","软件","较慢","右键","格式","完成","使用"," ","文件","此","目前","10.15",")","问题","可","但","浏览器","会弹","就会弹","定位","不","中","温馨","影响","后","到","需要","比较慢",".","格式文件","双击","adapter","5","mac","比较","得到","会","点击","macos","有时","出"],"title":"在Mac中安装Adapter","title_tokens":["安装","adapter","mac","在","中"]},{"location":"get_start/gs_install/#win","text":"下载 右键解压,然后进入解压后的文件夹, 双击 CodeLab-Adapter 文件。（提醒: 最好不要重命名文件夹，如果要重命名，确保名字中没有中文和空格） 运行Adapter，会自动弹出默认浏览器（推荐使用Firefox或者Chrome浏览器）。 如果出现防火墙的警报，点击允许访问就好了。 看到一下界面就说明安装成功了。 温馨提示：Windows 7下最好以管理员权限运行。","text_tokens":[",","的","-","动弹","安装","文件夹",":","重命名","浏览","看到","界面","提示","7","管理员","好","没有","。","防火","：","如果","防火墙","出现","推荐","下载","，","使用","firefox","或者","（","右键","就","一下"," ","成功","文件","说明","确保","和","中文","浏览器","命名","windows","不要","会自","运行","进入","中","温馨","后","空格","管理","名字","解压","允许","权限","件夹","chrome","codelab","最好","双击","adapter","火墙","警报","访问","然后","默认","了","提醒","要","以","下","点击","）","出"],"title":"在Windows中安装Adapter","title_tokens":["windows","安装","adapter","在","中"]},{"location":"get_start/gs_install/#linux","text":"下载 用unzip命令解压 在命令行中运行Adapter就会自动弹出 温馨提示： 无法运行请赋予可执行权限 chmod u+x Adapter软件名 在Ubuntu 16.04下可能无法自动打开浏览器。建议在命令行下启动它，你将看到 https://codelab-adapter.codelab.club:12358/ , 这个链接即是 WebUI 当前经测试的发行版有Ubuntu，Kali，ArchLinux","text_tokens":[",","的","-","动弹","可能",":","在","赋予","16.04","提示","浏览","你","看到","https","建议","。","：","chmod","经","自","kali","执行","打开","x","无法","名","就","下载","软件","，","12358","发行版","club"," ","链接","它","用","unzip","可","浏览器","发行","命令行","/","将","运行","这个","当前","u","中","温馨","是","命令","请","有","解压","权限","启动",".","测试","codelab","webui","adapter","archlinux","即","+","自动","下","会","ubuntu","出"],"title":"Linux中安装Adapter","title_tokens":["linux","安装","中","adapter"]},{"location":"get_start/gs_install/#rpi","text":"下载 解压 赋予运行权限： chmod +x Adapter软件名 ，再双击运行 也可以右键修改文件权限，使其可运行","text_tokens":["可以","赋予","：","chmod","其","再","x","名","也","下载","软件","，","右键"," ","文件","可","运行","修改","解压","权限","使","双击","adapter","+"],"title":"在Raspbian中安装Adapter(build中...)","title_tokens":["build","(","安装","adapter","在","raspbian","...","中",")"]},{"location":"get_start/gs_install/#_2","text":"在安装完Adapter之后，我们来看看Adapter的使用界面。 围绕着两个核心组件来看， 整个Adapter的界面就是关于 插件 和 节点 的管理。比如说，在控制台里， 我们可以查看插件和节点的启用状态，以及打开和关闭我们的插件。然后在创作平台中去使用它们。 以extension开头的就是插件，以node开头的就是节点。 接下来我们将进入使用Adapter的环节，通过两个例子看看Adapter可以做些什么吧。 在安装中如果遇到问题，欢迎 在Codelab社区 中提出。","text_tokens":["的","它们","遇到","安装","可以","界面","在","看看","里","欢迎","比如说","着","例子","。","两个","关闭","接下来","打开","如果","我们","插件","使用","，","之后","extension","node","就是","创作"," ","比如","状态","接下","和","做些","问题","提出","控制台","关于","核心","社区","将","来","进入","启用","节点","什么","中","下来","吧","管理","平台","来看","通过","去","codelab","adapter","组件","整个","以及","然后","环节","完","查看","以","开头","控制","围绕"],"title":"界面概览","title_tokens":["界面","概览"]},{"location":"get_start/gs_microbit/","text":"Adapter插件——Micro:bit say：“Hello” ¶ 在上一个项目中，我们使用了Adapter插件让小猫帮我们打开了网页，这一次 我们用Adapter插件将创作平台和Micro:bit连接起来。让我们在创作平台操控Micro:bit。 Micro:bit概览 ¶ Micro:bit是一个小型的可编程计算机，旨在使学习与教学变得轻松有趣 Micro:bit就是一块小小的电路板，我们可以用它显示一个爱心和各种好玩的图案，还可以用它来控制创作平台的小猫。当然它功能远不止这些。想了解更多可以到 Micro:bit学习资源 。 Micro:bit：“Hello” ¶ 现在我们开始使用Adapter来连接Micro:bit，让Micro:bit显示出“Hello”。 第一步：连接Micro:bit ¶ 使用数据线将 micro:bit 接入电脑，这时候会看到Micro:bit的黄灯闪烁一会，就停止了。随后打开Codelab Adapter。 温馨提示：Windows 7 用户注意，为了能发现并连接 micro:bit，需要 安装驱动 （下载后运行即可） 第二步：添加MicroBit扩展 ¶ 如果是第一次连接，会自动刷入固件，刷入固件是将看到Micro:bit背面的LED灯快速闪烁， 稍等片刻，固件就刷好了。 刷完之后，重新连接，连接之后，你应该看到 micro:bit 背后的信号灯高频闪烁，这时我们就将创作平台和Micro:bit连接起来了。 温馨提示：Linux 非root用户注意，在刷入固件之前，使用 usb 串口需要做权限设置： sudo chmod 666 /dev/ttyACM0 。 第三步：开始编程 ¶ 我们尝试用积木块使Micro:bit say：“Hello” 在点击积木块后，Micro:bit就会显示出“Hello”了。 还可以做些什么呢？我们还可以尝试显示一个爱心。还可以。。。请你发挥你的想象力吧! 最后 ¶ 我们尝试用Adapter将创作平台和Micro:bit连接起来，并让Micro:bit Say：“Hello”。 Adapter还可以做些什么呢？ 让我们接下来跟着探索吧。","text_tokens":["的","算机","“","扩展","用户","小小的","一个","可以","安装","这时","上","教学","看到","提示","为了","第二","你","呢","接下来","如果","探索","现在","我们","就","（","片刻","root","想象","数据","做","bit","用","非","图案","sudo","固件","功能","应该","什么","下来","这些","后","平台","需要","”","codelab","adapter","了","usb","旨在","第三","设置","背后","自动","刷","会","接入","点击","即可","让",":","在","led","跟着","一步","时候","第一次","ttyacm0","刷入","随后","还","各种","下载","发现","之后","灯","第一","不止","发挥","和","电路","添加","/","将","来","注意","第二步","中","想","吧","背面","计算机","dev","当然","linux","网页","爱心","电路板","出","块","最后","!","小小","并","远不止","尝试","好","micro","。","：","microbit","打开","好玩","，","数据线","停止","hello","可编程","就是","连接","接下","做些","开始","起来","快速","这","接起","多","黄灯","运行","二步","串口","？","操控","驱动","请","资源","say","一块","一会","权限","使","信号","变得","¶","小型","轻松","项目","）","电脑","这时候","第一步","想象力","7","概览","一次","chmod","之前","—","闪烁","插件","稍等片刻","使用","积木","更","帮","创作"," ","它","显示","编程","能","666","windows","与","可编","温馨","连接起来","是","到","有趣","小猫","计算","第三步","重新","学习","了解","完","信号灯","高频","三步","控制"],"title":"入门案例2","title_tokens":["入门","2","案例"]},{"location":"get_start/gs_microbit/#adaptermicrobit-sayhello","text":"在上一个项目中，我们使用了Adapter插件让小猫帮我们打开了网页，这一次 我们用Adapter插件将创作平台和Micro:bit连接起来。让我们在创作平台操控Micro:bit。","text_tokens":["让","一个",":","在","上","micro","。","一次","打开","我们","插件","使用","，","帮","创作"," ","连接","和","bit","用","起来","将","这","接起","中","操控","连接起来","平台","小猫","了","adapter","网页","项目"],"title":"Adapter插件——Micro:bit say：“Hello”","title_tokens":["say","”","—","插件","“","adapter",":","hello"," ","micro","：","bit"]},{"location":"get_start/gs_microbit/#microbit","text":"Micro:bit是一个小型的可编程计算机，旨在使学习与教学变得轻松有趣 Micro:bit就是一块小小的电路板，我们可以用它显示一个爱心和各种好玩的图案，还可以用它来控制创作平台的小猫。当然它功能远不止这些。想了解更多可以到 Micro:bit学习资源 。","text_tokens":["的","算机","小小","小小的","一个",":","可以","教学","远不止","micro","。","还","我们","各种","好玩","，","更","可编程","就是","创作"," ","不止","和","电路","bit","它","用","编程","显示","图案","与","来","多","功能","可编","想","这些","计算机","是","平台","到","资源","一块","有趣","使","小猫","计算","变得","当然","小型","轻松","旨在","学习","了解","爱心","电路板","控制"],"title":"Micro:bit概览","title_tokens":["概览",":","bit","micro"]},{"location":"get_start/gs_microbit/#microbithello","text":"现在我们开始使用Adapter来连接Micro:bit，让Micro:bit显示出“Hello”。","text_tokens":["开始","让","”","现在","我们","使用","，","“","adapter","来","micro",":","hello","连接","。","bit","出","显示"],"title":"Micro:bit：“Hello”","title_tokens":["”","“",":","hello","micro","：","bit"]},{"location":"get_start/gs_microbit/#microbit_1","text":"使用数据线将 micro:bit 接入电脑，这时候会看到Micro:bit的黄灯闪烁一会，就停止了。随后打开Codelab Adapter。 温馨提示：Windows 7 用户注意，为了能发现并连接 micro:bit，需要 安装驱动 （下载后运行即可）","text_tokens":["这时候","即可","的","用户","安装","并",":","这时","看到","提示","为了","7","时候","micro","。","：","随后","打开","闪烁","就","使用","，","下载","数据线","发现","停止","（","数据"," ","连接","bit","能","windows","将","注意","黄灯","运行","温馨","后","需要","驱动","一会","codelab","了","adapter","会","接入","）","电脑"],"title":"第一步：连接Micro:bit","title_tokens":["第一步",":","micro","一步","第一","连接","：","bit"]},{"location":"get_start/gs_microbit/#microbit_2","text":"如果是第一次连接，会自动刷入固件，刷入固件是将看到Micro:bit背面的LED灯快速闪烁， 稍等片刻，固件就刷好了。 刷完之后，重新连接，连接之后，你应该看到 micro:bit 背后的信号灯高频闪烁，这时我们就将创作平台和Micro:bit连接起来了。 温馨提示：Linux 非root用户注意，在刷入固件之前，使用 usb 串口需要做权限设置： sudo chmod 666 /dev/ttyACM0 。","text_tokens":["的","用户",":","led","这时","看到","提示","在","你","第一次","好","micro","。","：","一次","chmod","刷入","之前","ttyacm0","如果","闪烁","稍等片刻","就","我们","，","使用","之后","片刻","root","创作","灯","第一"," ","做","连接","和","bit","非","起来","快速","666","/","将","注意","固件","接起","sudo","串口","应该","温馨","背面","连接起来","是","平台","需要","dev","权限","信号","linux","了","usb","重新","完","背后","信号灯","自动","高频","刷","设置","会"],"title":"第二步：添加MicroBit扩展","title_tokens":["microbit","扩展","第二","第二步","二步","：","添加"]},{"location":"get_start/gs_microbit/#_1","text":"我们尝试用积木块使Micro:bit say：“Hello” 在点击积木块后，Micro:bit就会显示出“Hello”了。 还可以做些什么呢？我们还可以尝试显示一个爱心。还可以。。。请你发挥你的想象力吧!","text_tokens":["!","的","想象力","“","可以","一个",":","在","尝试","你","呢","micro","。","：","还","我们","就","，","积木","hello","想象","发挥"," ","bit","做些","用","显示","出","？","什么","吧","后","请","say","”","使","了","爱心","会","点击","块"],"title":"第三步：开始编程","title_tokens":["开始","第三步","第三","三步","：","编程"]},{"location":"get_start/gs_microbit/#_2","text":"我们尝试用Adapter将创作平台和Micro:bit连接起来，并让Micro:bit Say：“Hello”。 Adapter还可以做些什么呢？ 让我们接下来跟着探索吧。","text_tokens":["让","“","可以","并",":","跟着","尝试","呢","micro","。","：","接下来","还","探索","我们","，","hello","创作"," ","连接","接下","和","bit","做些","用","起来","将","接起","？","什么","下来","吧","连接起来","平台","say","”","adapter"],"title":"最后","title_tokens":["最后"]},{"location":"get_start/gs_pyproject/","text":"Adapter插件——让小猫来打开网站 ¶ 在前一小节，我们介绍了Adapter的整体界面，现在我们开始使用Adapter去扩展创作平台的能力。 Adapter插件可以让创作平台拥有更多的能力，我们可以用创作平台让小猫自由的旋转，让小猫去追捕小鱼，那有没有想过 让小猫去帮我们打开CodeLab的网站呢？ 接下来，我们来尝试点击小猫，让小猫为我们打开CodeLab网站。 让我们开始吧！ 第一步：启用Python插件 ¶ 首先，我们打开Adapter，并打开创作平台，然后在创作平台中，我们可以看到右上方的小球是绿色的，如果没有，请重启Adapter，再次打开Python插件。 接下来我们将Python扩展添加到创作平台中，点击左下角的添加扩展。 在添加扩展页面找到并点击Python扩展 到这里，第一步：添加Python扩展就完成了。 第二步：开始编程 ¶ 在这里我们将启用Python扩展，并且 利用扩展将Codelab的主页和小猫连接起来。 首先，让我们编程， 点击绿旗的时候，就启动Python扩展 。 随后我们将创造一个属于自己的积木，在创造一个积木时，我们先给积木取个名字，然后将我们想要赋予积木的功能拖到自定义积木的下方。 要赋予自定义积木打开网站的能力，只需要将 PyHelper.open_url(\"https://codelab.club\") 复制并粘贴到python积木块中, 这样一来我们就赋予了自定义积木块打开Codelab网站的能力了。 到这里好像可以结束了，可是我们的目标是让小猫来打开网站。接下来我们将积木的能力赋予给小猫。 第三步：让小猫来打开网站 ¶ 到这里，我们已经将所有的工作做完了，现在我们将点击绿旗，再点击小猫。看看会发生什么？ 如果在操作过程遇到困难，可以直接参考 项目源码 最后 ¶ 到这里我们已经成功的让小猫帮我们打开网站了，有的小伙伴会说我能打开自己喜欢的网站吗？ 当然可以，我们可以尝试将Python积木块中的网址替换一下？也许打开的就是你喜欢的网站了。 在这个项目中，我们做了非常简单的三件事情 启动Adapter的Python插件(extension_python) 创造了一个拥有打开网站能力的积木 将打开网站的能力赋予给了小猫 接下来我们将继续扩展创作平台的能力，连接Microbit。","text_tokens":[",","想过","的","绿旗","扩展","时","(","可以","一个","吗","赋予","看到","目标","第二","伙伴","呢","替换","你","事情","取个","接下来","如果","我","绿色","现在","我们","就","利用","自定义","简单","club","做","重启","拥有","用","发生","说","功能","什么","下来","右上","平台","需要",".","去","为","启动","codelab","adapter","介绍","了","网站","小节","那","第三","要","所有","会","点击","上方","已经","让","小伙伴",":","在","看看","一步","https","时候","也许","没有","\"","一来","想要","随后","非常","整体","复制","非常简单","网址","extension","一下","参考","第一","成功","和",")","添加","/","自定","将","来","下角","自己","python","启用","第二步","_","作过","中","吧","过程","名字","再次","这里","首先","当然","可是","然后","只","前","并且","块","追捕","小鱼","工作","最后","属于","好像","遇到","并","尝试","。","：","microbit","打开","给","，","页面","主页","有没有","完成","这样一来","就是","旋转","接下","连接","创造","下方","直接","开始","起来","定义","自由","？","接起","多","二步","！","找到","请","小球","有","¶","继续","url","项目","粘贴","第一步","界面","左下","小伙","先给","一","再","操作过程","操作","—","喜欢","插件","使用","积木","更","左下角","帮","创作"," ","pyhelper","open","编程","遇到困难","能","结束","这个","连接起来","是","到","源码","三件","小猫","第三步","完","困难","拖","三步","能力","这样","右上方"],"title":"入门案例1","title_tokens":["入门","1","案例"]},{"location":"get_start/gs_pyproject/#adapter","text":"在前一小节，我们介绍了Adapter的整体界面，现在我们开始使用Adapter去扩展创作平台的能力。 Adapter插件可以让创作平台拥有更多的能力，我们可以用创作平台让小猫自由的旋转，让小猫去追捕小鱼，那有没有想过 让小猫去帮我们打开CodeLab的网站呢？ 接下来，我们来尝试点击小猫，让小猫为我们打开CodeLab网站。 让我们开始吧！","text_tokens":["让","想过","的","扩展","可以","界面","在","尝试","呢","没有","。","接下来","一","打开","整体","现在","我们","插件","使用","，","更","有没有","帮","创作"," ","旋转","接下","拥有","用","开始","自由","来","？","多","！","下来","吧","平台","去","为","codelab","小猫","介绍","了","adapter","小节","网站","那","能力","前","点击","追捕","小鱼"],"title":"Adapter插件——让小猫来打开网站","title_tokens":["让","—","插件","小猫","adapter","来","网站","打开"]},{"location":"get_start/gs_pyproject/#python","text":"首先，我们打开Adapter，并打开创作平台，然后在创作平台中，我们可以看到右上方的小球是绿色的，如果没有，请重启Adapter，再次打开Python插件。 接下来我们将Python扩展添加到创作平台中，点击左下角的添加扩展。 在添加扩展页面找到并点击Python扩展 到这里，第一步：添加Python扩展就完成了。","text_tokens":["的","第一步","扩展","可以","并","在","看到","左下","一步","没有","。","接下来","：","打开","如果","绿色","我们","插件","就","，","页面","左下角","完成","创作","第一"," ","接下","重启","添加","将","下角","python","中","下来","找到","右上","是","平台","请","到","小球","再次","这里","首先","adapter","了","然后","点击","上方","右上方"],"title":"第一步：启用Python插件","title_tokens":["第一步","插件","python","启用","一步","第一","："]},{"location":"get_start/gs_pyproject/#_1","text":"在这里我们将启用Python扩展，并且 利用扩展将Codelab的主页和小猫连接起来。 首先，让我们编程， 点击绿旗的时候，就启动Python扩展 。 随后我们将创造一个属于自己的积木，在创造一个积木时，我们先给积木取个名字，然后将我们想要赋予积木的功能拖到自定义积木的下方。 要赋予自定义积木打开网站的能力，只需要将 PyHelper.open_url(\"https://codelab.club\") 复制并粘贴到python积木块中, 这样一来我们就赋予了自定义积木块打开Codelab网站的能力了。 到这里好像可以结束了，可是我们的目标是让小猫来打开网站。接下来我们将积木的能力赋予给小猫。","text_tokens":[",","的","绿旗","扩展","时","(","可以","一个","赋予","目标","取个","接下来","我们","利用","就","自定义","club","功能","下来","需要",".","启动","codelab","了","网站","要","点击","让",":","在","https","时候","\"","一来","想要","随后","复制","和",")","/","自定","将","自己","来","python","启用","_","中","名字","这里","首先","可是","然后","只","并且","块","属于","好像","并","。","打开","给","，","主页","这样一来","连接","接下","创造","下方","起来","定义","接起","url","粘贴","先给","积木"," ","pyhelper","open","编程","结束","连接起来","到","是","小猫","拖","能力","这样"],"title":"第二步：开始编程","title_tokens":["开始","第二","第二步","二步","：","编程"]},{"location":"get_start/gs_pyproject/#_2","text":"到这里，我们已经将所有的工作做完了，现在我们将点击绿旗，再点击小猫。看看会发生什么？ 如果在操作过程遇到困难，可以直接参考 项目源码","text_tokens":["的","绿旗","遇到","可以","看看","在","。","再","如果","操作过程","操作","现在","我们","，","已经","参考"," ","做","直接","遇到困难","发生","将","？","什么","作过","过程","到","源码","这里","小猫","了","完","困难","所有","会","项目","点击","工作"],"title":"第三步：让小猫来打开网站","title_tokens":["让","第三步","小猫","来","网站","第三","三步","：","打开"]},{"location":"get_start/gs_pyproject/#_3","text":"到这里我们已经成功的让小猫帮我们打开网站了，有的小伙伴会说我能打开自己喜欢的网站吗？ 当然可以，我们可以尝试将Python积木块中的网址替换一下？也许打开的就是你喜欢的网站了。 在这个项目中，我们做了非常简单的三件事情 启动Adapter的Python插件(extension_python) 创造了一个拥有打开网站能力的积木 将打开网站的能力赋予给了小猫 接下来我们将继续扩展创作平台的能力，连接Microbit。","text_tokens":["让","的","(","扩展","可以","小伙伴","一个","吗","替换","在","伙伴","小伙","尝试","你","事情","赋予","也许","。","接下来","microbit","打开","我","非常","喜欢","我们","简单","插件","，","积木","非常简单","给","网址","extension","帮","一下","就是","创作","成功"," ","做","接下","连接","创造",")","拥有","说","能","将","自己","？","python","这个","_","中","下来","到","平台","有","启动","这里","三件","小猫","当然","了","adapter","网站","继续","能力","会","项目","块","已经"],"title":"最后","title_tokens":["最后"]},{"location":"help/","text":"帮助 ¶ 如果遇到问题，欢迎到 CodeLab论坛 里交流讨论","text_tokens":["codelab","，","遇到","¶","帮助","欢迎","里","交流","论坛","讨论"," ","到","问题","如果"],"title":"论坛","title_tokens":["论坛"]},{"location":"help/#_1","text":"如果遇到问题，欢迎到 CodeLab论坛 里交流讨论","text_tokens":["codelab","，","遇到","欢迎","里","交流","论坛","讨论"," ","到","问题","如果"],"title":"帮助","title_tokens":["帮助"]},{"location":"project_tutorial/eim_pt/","text":"Python对象的连接器：EIM 插件 ¶ 好事多磨，经过 对象和消息 的介绍我们终于来到第一个项目案例： EIM。 教程目的 ¶ 我们将使用 EIM 插件 去获得 操作系统 的信息。其中涉及 Python 代码编辑器： Jupyterlab 的操作。 你可能会感到头大，什么是 EIM ，什么又是 操作系统 ？莫头疼，让我们一一细看。 我们非常鼓励 打开浏览器去搜索你不懂的词汇 ，比如操作系统。 概念解释 ¶ 操作系统 ¶ 什么是操作系统呢？维基百科的定义如下 操作系统（英语：Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。 ——维基百科 这个定义很复杂，牵扯到计算机硬件，软件，以及编程等话题。我们在这里不详细展开。 在直观的认识中，我们使用的 Windows ， macOS 和 Unix类系统 等就是 操作系统 ，我们可以在 Windows 上运行浏览器进行 Scratch 编程，也可以在上面运行 腾讯QQ 等通讯软件和朋友聊天，少不了的是我们可以玩各种各样的电子游戏，可以做的事情还有很多。。。 到此为止，我们有上述直观的了解就够了，而 Python 这门编程语言就可以扩展我们和操作系统交互的能力。做一些除了玩游戏以外的事情。比如做一款属于自己的游戏，搭建一个属于自己的网页。 EIM 插件 ¶ 在 Adapter 中， EIM 是 Everything Is a Message 缩写，即 对象之间流动的一切皆消息 。 在Adapter所连接的 对象 之间，流动的就是 消息 ，而不同的 对象 可以各自根据 消息 做出不同的反应。 EIM插件 的作用是： 在Adapter中传递 Scratch对象 和 Python对象 之间的消息 。 你可能一下就反应过来了，这里的消息不就类似于小猫和小熊间的对话吗？只是 小猫 和 小熊 变成了 Scratch对象 和 Python对象 而已。Adatper 只不过是让这个“对话”在不同层面的对象之间得以发生， 就像声音的传播需要空气一样，Scratch 和 Python 之间的消息传递需要 Adapter插件：EIM （除了由衷对你聪明的赞许，我无话可说 :)） 消息流动示意图 案例：获取操作系统信息 ¶ 现在 我们尝试使用 Python 获取计算机操作系统的信息，然后通过 Adapter 发送到 Scratch 中，让小猫说出来。 以此为例扩展Scratch的能力，尝试触达计算机操作系统中的信息。 有的小伙伴又有疑问了： 我没有学过 Python 怎么办？ 莫慌，这里涉及的代码非常简单，并且提供的是一个模板，容许你稍加修改就可以达到你想要的效果，在这个过程中，更需要的是你的想象力。 第一步：编写 Python 代码 ¶ Jupyterlab 是一个写 Python 代码的环境，我们在上面修改和运行代码。 打开 Codelab Adapter （不记得如何打开的同学请回看 安装Adapter ）。 编写 Python 代码 我们将以下代码复制到一个 Python Notebook 中并运行他们。请注意阅读代码中的注释，帮助我们了解代码在干什么。 # “#”井号后面是注释，不作为代码运行 from codelab_adapter_client.utils import run_monitor , send_simple_message import platform # 上面两句代码的意思是导入代码运行需要的依赖 def monitor ( msg ): # 这里定义了一个函数，参数 msg 是 Scratch 中发送过来的消息，就是 Scratch 和 Python对象 说的话。 print ( msg ) return \"我的操作系统是：\" + str ( platform . platform ()) # 定义了返回给Scratch的系统信息，就是 Python对象 要对Scratch 说的话。 # send_simple_message(\"hello\") run_monitor ( monitor ) # 发送消息给Scratch ps：Linux用户，在第一次打开 Jupyter 插件时，会帮你自动下载并打开，操作不如上图也没关系，请给点耐心。 第二步：在 Scratch 中编程 ¶ 完成第一步操作后，我们在 Scratch 中，使用积木向 Python对象 发消息，和接收来自 Python对象 的消息。 所用到的积木块 广播消息积木 收消息积木 在 Scratch 中启动EIM扩展 发送和接收消息 我们在广播消息积木中输入发送给 Python对象 的消息：“ 我的操作系统是什么 ？” 随后让小猫说出获取的 操作系统信息 。演示用到的系统为 Linux系统 。 现在回到 Jupyterlab 中，我们可以看到，从下方的红框显示了 Scratch对象 发送过来的消息。 如果我们修改了上述代码，需要重新运行Python程序，点击红框中的 方块 ，再点击 运行箭头 ，就可以了。若实在不行，刷新一下页面，重新运行程序。 原理解释 ¶ 运行 Python 程序后，我们启动了 Python对象 ， Python对象 会持续地接收来自 Scratch对象 发送过来的消息。通过 run_monitor(monitor) 函数，我们将处理后的消息返回到 Scratch对象 中。我们可以看到，在这里 Python对象 其实就是一个 Python程序 启发与想象力 ¶ 在上述的教程中，我们观察到了， Scratch对象 是如何与 Python对象 进行沟通的. 这样一来， 我们就可以利用Python语言的能力，去处理来自 Scratch 的消息，并返回到Scratch中。 那么，我们还可以用到 Python语言 的哪些能力去处理 Scratch 的消息呢？比如： 在 Python对象 中使用AI自然语言处理，去理解小猫说的话，制作一个自动回复的机器人。 聊天机器人项目 在 Python对象 中使用图像识别，让小猫去理解摄像头的事物是什么？ 图像识别项目 比如。。。","text_tokens":[",","的","一个","解释","事情","又","上","吗","第二","看到","到此为止","除了","比如","做","事物","说","维基百科","os","什么","制作","scratch","需要","编辑","为","作为","上图","哪些","可说","让","电子","utils","在","机器人","得以","一步","子游","赞许","随后","复制","缩写","非常简单","干什么","来自","就够","第一","一一","少不了","搜索","获得","过程","而已","计算机","对","玩游","接器","游戏","做出","复杂","记得","发送","eim","实在","属于","并","函数","上面","页面","聪明","不同","阅读","小熊","下方","为例","模板","等","连接器","如下","学过","monitor","所用","返回","¶","耐心","而","方块","a","第一步","间","小伙","感到","qq","好事","详细","插件","如上图"," ","持续","怎么办","到","发送到","的话","帮助","话题","即","出来","牵扯","算机","扩展","接收","所","说出","伙伴","简单","利用","软件","观察","获取","想象","浏览器","编写","print","只不过","import","内核","头大","空气","”",".","公共","启动","不了","怎么","+","自动","要","机器","关系","点击","不行","对话","可能","基石","后面","第一次","鼓励","操作系统","英语","两句","下载","硬件","效果",")","来","第二步","过来","运用","演示","、","头疼","案例","收","回到","莫","并且","其中","懂","str","电子游戏","无话可说","依赖","。","很多","打开","玩","一切","相互","摄像头","hello","platform","刷新","用到","一组","第一个","看","message","细看","皆","以下","二步","疑问","请","有","启发","向","机系统","client","项目","）","提供","程序","识别","主管","一次","再","操作","帮","计算机硬件","各自","与","代码","一些","everything","消息","朋友","能力","控制","以外","系统软件","(","用户","可以","输入","呢","意思","我","如果","现在","发消息","公共服务","概念","地","发生","直观","反应","一款","无话","他们","腾讯","上述","介绍","一样","关联","送到","simple",":","如上","由衷","处理","若","没有","箭头","自然语言","run","还","各种","语言","玩游戏","和","将","注意","python","from","_","中","从","维基","传播","通过","这里","变成","声音","linux","网页","百科","点","莫慌","图像识别","：","没关","给","这样一来","就是","注释","operating","井号","教程","这门","？","运行","jupyterlab","服务","系统","资源","很","涉及","自然","交互","不过","回复","参数","进行","那么","信息","作用","—","积木","更","组织","达到","聊天","红框","为止","编程","触达","windows","这个","环境","adatper","ps","计算","重新","了解","原理","对象","沟通","送给","macos","代码运行","这样","“","时","消息传递","安装","你","我们","就","类似","（","system","之间","send","notebook","来到","计算机操作","导入","词汇","于","像头","示意图","编辑器","示意","后","目的","msg","去","codelab","unix","只是","了","adapter","此为","会","搭建","小伙伴","好事多磨","ai","\"","一来","经过","根据","想要","非常","还有","编程语言","一下","jupyter","摄像","类","稍加","流动","意图","自己","计算机系统","发送给","回","然后","终于","维基百","块","同学","浏览","传递","尝试","如何","认识","也","，","完成","#","连接","定义","其实","广播","没关系","以及","写","通讯","图像","想象力","展开","以此","像","理解","使用","复制到","显示","return","def","容许","不","各种各样","修改","层面","是","软件资源","小猫","各样","同时","is"],"title":"Python对象连接器：EIM","title_tokens":["接器","python","对象","连接器","连接","eim","："]},{"location":"project_tutorial/eim_pt/#pythoneim","text":"好事多磨，经过 对象和消息 的介绍我们终于来到第一个项目案例： EIM。","text_tokens":["的","一个","好事多磨","好事","。","：","经过","我们","，","第一"," ","来到","和","第一个","案例","介绍","消息","对象","eim","项目","终于"],"title":"Python对象的连接器：EIM 插件","title_tokens":["的","接器","插件","python"," ","对象","连接器","连接","eim","："]},{"location":"project_tutorial/eim_pt/#_1","text":"我们将使用 EIM 插件 去获得 操作系统 的信息。其中涉及 Python 代码编辑器： Jupyterlab 的操作。 你可能会感到头大，什么是 EIM ，什么又是 操作系统 ？莫头疼，让我们一一细看。 我们非常鼓励 打开浏览器去搜索你不懂的词汇 ，比如操作系统。","text_tokens":["让","的","可能","浏览","又","你","感到","信息","鼓励","。","：","打开","操作系统","操作","非常","我们","插件","使用","，"," ","一一","比如","浏览器","词汇","搜索","细看","将","编辑器","代码","？","python","jupyterlab","获得","什么","不","系统","头大","是","编辑","涉及","去","头疼","莫","eim","会","其中","懂"],"title":"教程目的","title_tokens":["目的","教程"]},{"location":"project_tutorial/eim_pt/#_2","text":"","text_tokens":[],"title":"概念解释","title_tokens":["概念","解释"]},{"location":"project_tutorial/eim_pt/#_3","text":"什么是操作系统呢？维基百科的定义如下 操作系统（英语：Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。 ——维基百科 这个定义很复杂，牵扯到计算机硬件，软件，以及编程等话题。我们在这里不详细展开。 在直观的认识中，我们使用的 Windows ， macOS 和 Unix类系统 等就是 操作系统 ，我们可以在 Windows 上运行浏览器进行 Scratch 编程，也可以在上面运行 腾讯QQ 等通讯软件和朋友聊天，少不了的是我们可以玩各种各样的电子游戏，可以做的事情还有很多。。。 到此为止，我们有上述直观的了解就够了，而 Python 这门编程语言就可以扩展我们和操作系统交互的能力。做一些除了玩游戏以外的事情。比如做一款属于自己的游戏，搭建一个属于自己的网页。","text_tokens":["的","算机","系统软件","扩展","用户","可以","一个","事情","上","呢","到此为止","除了","我们","就","软件","公共服务","（","system","计算机操作","比如","做","浏览器","直观","维基百科","os","一款","内核","什么","scratch","腾讯","公共","上述","unix","不了","了","此为","搭建","关联","电子","基石","在","子游","操作系统","各种","英语","还有","缩写","语言","硬件","编程语言","就够","玩游戏","类","少不了","和","来","自己","python","运用","中","维基","计算机","这里","计算机系统","、","玩游","游戏","复杂","网页","百科","维基百","电子游戏","属于","并","浏览","认识","。","：","上面","很多","也","玩","，","相互","就是","一组","定义","operating","这门","？","运行","服务","等","系统","如下","资源","很","有","以及","交互","机系统","而","进行","）","通讯","提供","展开","程序","qq","主管","操作","—","详细","使用","组织","聊天"," ","为止","编程","计算机硬件","windows","与","这个","不","各种各样","一些","macos","是","软件资源","到","计算","话题","朋友","各样","了解","同时","能力","牵扯","控制","以外"],"title":"操作系统","title_tokens":["操作系统","操作","系统"]},{"location":"project_tutorial/eim_pt/#eim","text":"在 Adapter 中， EIM 是 Everything Is a Message 缩写，即 对象之间流动的一切皆消息 。 在Adapter所连接的 对象 之间，流动的就是 消息 ，而不同的 对象 可以各自根据 消息 做出不同的反应。 EIM插件 的作用是： 在Adapter中传递 Scratch对象 和 Python对象 之间的消息 。 你可能一下就反应过来了，这里的消息不就类似于小猫和小熊间的对话吗？只是 小猫 和 小熊 变成了 Scratch对象 和 Python对象 而已。Adatper 只不过是让这个“对话”在不同层面的对象之间得以发生， 就像声音的传播需要空气一样，Scratch 和 Python 之间的消息传递需要 Adapter插件：EIM （除了由衷对你聪明的赞许，我无话可说 :)） 消息流动示意图","text_tokens":["的","“","所","可以","消息传递","吗","你","除了","我","就","类似","（","之间","于","发生","示意图","只不过","示意","反应","无话","scratch","需要","空气","”","只是","adapter","了","一样","可说","让","对话","可能",":","在","得以","由衷","赞许","根据","缩写","一下","和",")","流动","意图","python","过来","中","而已","传播","对","这里","变成","声音","做出","eim","无话可说","传递","。","：","一切","，","就是","聪明","不同","连接","小熊","message","？","皆","而","不过","a","）","间","作用","像","插件"," ","各自","这个","不","everything","层面","是","adatper","小猫","消息","即","对象","is"],"title":"EIM 插件","title_tokens":[" ","插件","eim"]},{"location":"project_tutorial/eim_pt/#_4","text":"现在 我们尝试使用 Python 获取计算机操作系统的信息，然后通过 Adapter 发送到 Scratch 中，让小猫说出来。 以此为例扩展Scratch的能力，尝试触达计算机操作系统中的信息。 有的小伙伴又有疑问了： 我没有学过 Python 怎么办？ 莫慌，这里涉及的代码非常简单，并且提供的是一个模板，容许你稍加修改就可以达到你想要的效果，在这个过程中，更需要的是你的想象力。","text_tokens":["让","的","想象力","算机","送到","扩展","提供","可以","小伙伴","一个","以此","在","又","尝试","小伙","伙伴","你","信息","没有","。","：","莫慌","想要","我","操作系统","操作","非常","现在","我们","简单","使用","，","就","非常简单","更","获取","达到","想象"," ","效果","为例","稍加","触达","容许","说","怎么办","代码","？","python","这个","模板","中","系统","修改","过程","计算机","是","scratch","疑问","学过","通过","有","涉及","发送到","这里","需要","小猫","计算","adapter","了","怎么","然后","出来","发送","能力","并且"],"title":"案例：获取操作系统信息","title_tokens":["操作系统","操作","案例","获取","系统","信息","："]},{"location":"project_tutorial/eim_pt/#python","text":"Jupyterlab 是一个写 Python 代码的环境，我们在上面修改和运行代码。 打开 Codelab Adapter （不记得如何打开的同学请回看 安装Adapter ）。 编写 Python 代码 我们将以下代码复制到一个 Python Notebook 中并运行他们。请注意阅读代码中的注释，帮助我们了解代码在干什么。 # “#”井号后面是注释，不作为代码运行 from codelab_adapter_client.utils import run_monitor , send_simple_message import platform # 上面两句代码的意思是导入代码运行需要的依赖 def monitor ( msg ): # 这里定义了一个函数，参数 msg 是 Scratch 中发送过来的消息，就是 Scratch 和 Python对象 说的话。 print ( msg ) return \"我的操作系统是：\" + str ( platform . platform ()) # 定义了返回给Scratch的系统信息，就是 Python对象 要对Scratch 说的话。 # send_simple_message(\"hello\") run_monitor ( monitor ) # 发送消息给Scratch ps：Linux用户，在第一次打开 Jupyter 插件时，会帮你自动下载并打开，操作不如上图也没关系，请给点耐心。","text_tokens":[",","的","“","(","用户","安装","一个","时","你","意思","我","我们","（","send","notebook","导入","编写","说","print","import","什么","需要","scratch","他们","msg","”",".","codelab","作为","adapter","了","上图","+","自动","要","会","关系","simple","utils",":","在","如上","后面","第一次","\"","run","操作系统","复制","两句","下载","干什么","jupyter","第一","和",")","将","注意","python","from","_","过来","中","对","这里","linux","回","记得","发送","str","同学","点","并","函数","依赖","如何","。","：","上面","没关","打开","也","给","，","hello","就是","#","platform","阅读","注释","看","message","定义","井号","运行","jupyterlab","以下","系统","请","monitor","没关系","返回","耐心","参数","写","client","）","信息","一次","操作","插件","复制到","帮","如上图"," ","return","def","代码","不","修改","是","环境","ps","的话","帮助","消息","了解","对象","代码运行"],"title":"第一步：编写 Python 代码","title_tokens":["编写","第一步","代码","python","一步","第一"," ","："]},{"location":"project_tutorial/eim_pt/#scratch","text":"完成第一步操作后，我们在 Scratch 中，使用积木向 Python对象 发消息，和接收来自 Python对象 的消息。 所用到的积木块 广播消息积木 收消息积木 在 Scratch 中启动EIM扩展 发送和接收消息 我们在广播消息积木中输入发送给 Python对象 的消息：“ 我的操作系统是什么 ？” 随后让小猫说出获取的 操作系统信息 。演示用到的系统为 Linux系统 。 现在回到 Jupyterlab 中，我们可以看到，从下方的红框显示了 Scratch对象 发送过来的消息。 如果我们修改了上述代码，需要重新运行Python程序，点击红框中的 方块 ，再点击 运行箭头 ，就可以了。若实在不行，刷新一下页面，重新运行程序。","text_tokens":["的","接收","扩展","“","可以","说出","输入","看到","我","如果","现在","我们","就","发消息","获取","什么","后","scratch","需要","”","启动","为","上述","了","点击","不行","让","在","一步","若","箭头","随后","操作系统","来自","一下","第一","和","python","过来","中","从","演示","发送给","linux","收","发送","eim","回到","块","实在","。","：","，","页面","完成","刷新","用到","下方","？","运行","jupyterlab","系统","广播","所用","向","方块","第一步","程序","信息","再","操作","使用","积木"," ","红框","显示","代码","修改","到","是","小猫","消息","重新","对象","送给"],"title":"第二步：在 Scratch 中编程","title_tokens":["在","第二","第二步","二步"," ","中","：","scratch","编程"]},{"location":"project_tutorial/eim_pt/#_5","text":"运行 Python 程序后，我们启动了 Python对象 ， Python对象 会持续地接收来自 Scratch对象 发送过来的消息。通过 run_monitor(monitor) 函数，我们将处理后的消息返回到 Scratch对象 中。我们可以看到，在这里 Python对象 其实就是一个 Python程序","text_tokens":["的","接收","(","可以","一个","函数","在","程序","看到","处理","。","run","我们","，","来自","地","就是","持续"," ",")","将","python","运行","_","过来","其实","中","后","到","scratch","monitor","通过","启动","这里","返回","了","消息","对象","发送","会"],"title":"原理解释","title_tokens":["原理","解释"]},{"location":"project_tutorial/eim_pt/#_6","text":"在上述的教程中，我们观察到了， Scratch对象 是如何与 Python对象 进行沟通的. 这样一来， 我们就可以利用Python语言的能力，去处理来自 Scratch 的消息，并返回到Scratch中。 那么，我们还可以用到 Python语言 的哪些能力去处理 Scratch 的消息呢？比如： 在 Python对象 中使用AI自然语言处理，去理解小猫说的话，制作一个自动回复的机器人。 聊天机器人项目 在 Python对象 中使用图像识别，让小猫去理解摄像头的事物是什么？ 图像识别项目 比如。。。","text_tokens":["那么","图像","的","让","可以","并","一个","在","机器人","ai","识别","如何","呢","处理","。","：","一来","自然语言","图像识别","还","我们","就","利用","，","观察","语言","来自","使用","理解","摄像头","这样一来","聊天"," ","用到","比如","摄像","事物","项目","说","像头","教程","与","？","python","什么","中","制作","是","到","scratch",".","去","上述","返回","小猫","了","消息","的话","机器","自然","自动","对象","能力","沟通","回复","哪些","进行","这样"],"title":"启发与想象力","title_tokens":["与","想象力","启发","想象"]},{"location":"project_tutorial/microbit_pt/","text":"Micro:bit Radio 与 Adapter ¶ 在 入门案例2 中，我们通过 Micro:bit 插件 ， 在 Scratch 中对 Micro:bit 编程，但如果要充分使用 Micro:bit生态 的能力， 一块 Micro:bit 无法满足我们表达想法的需求。比如在 Fire!:投石器 项目中我们用到了 三块Micro:bit 。 而 Micro:bit Radio 插件 可以连接多块 Micro:bit ，并将 Scratch 和 Python语言 的能力结合到 Micro:bit 中。 教程目的 ¶ 在本篇教程中，我们将使用 Adapter 的 Micro:bit Radio 插件 连接两块 Micro:bit ，其中一个为 消息中转板 ，另一个为 功能板 。通过实现 无线控制小猫的案例，展示 Micro:bit 生态 与 Scratch 的连接。 原理解释 ¶ 在案例开始前，我们先介绍一些基本知识，以便了解 Micro:bit生态 能做什么，以及 Micro:bit Radio 插件的工作方式。 Micro:bit 生态能做什么 ¶ 在 入门案例2 中， 我们简单介绍了 Micro:bit 是什么？ 那 Micro:bit 生态 能做什么呢？ ，链接中的视频，向我们展示了 Micro:bit 能为我们按下快门，为小花浇水等一大堆有趣的事情。 不熟悉 Micro:bit 的小伙伴，我们推荐 micro:bit 官方社区 和 中文社区 ，社区里有丰富的教程与案例，供大家参考。 Micro:bit Radio 插件 ¶ Micro:bit Radio 使用了 Micro:bit 内置的无线通信模块，使得多块 Micro:bit 可以互相通信。 这需要 一块 Micro:bit 作为 消息中转站 ， Micro:bit 消息中转站 (简称 中转站 ）需要用USB线与计算机相连， 而其他 Micro:bit 作为 功能板 就通过 中转站 与计算机进行连接。 再建立以上连接之后，我们就可以通过 Scratch 对 功能板 Micro:bit (简称 功能板 ）进行编程，比如用 功能板 控制小猫的移动。 小伙伴可能会问： “我一块 Micro:bit 也能控制小猫的移动呀，为什么要用两块呢？” 在这里，只是想用一个简单的案例，说明多个 Micro:bit 连接的方式，为连接多个 Micro:bit 提供一个案例，以便我们利用多个 Micro:bit 表达我们的想法。 案例：无线控制小猫移动 ¶ 第一步：为 Micro:bit功能板 编程 ¶ 用USB线，将 功能板 连入计算机中 首先我们先在 makecode 中为 Micro:bit功能板 定义向 Micro:bit中转站 发送消息的按键 映射 按钮 “A” 和 “B” 分别发送字符串“a” 和 “b” 到中转站。 定义收到 Micro:bit中转站 消息的行为 即当 功能板 收到字符 “c” 时，显示爱心 我们将这 功能板 makecode代码 （文件后缀名为.hex)下载到计算机本地文件中，并拖入到 Micro:bit 文件夹中，完成代码的导入。 第二步：为 Micro:bit中转站 编程 ¶ 在 makecode 为 中转站 编程 定义向 Adapter 收发消息的功能 定义向 Micro:bit功能板 收发消息的功能 和第一步一样，下载 消息中转站 makecode代码 ，并烧入中转站。 以上的代码，看不懂是没关系的，只要我们知道相应的模块是做什么的就好了。 眼尖的小伙伴发现，上述步骤的关键，在于将 中转站 和 功能板 置于同一个 无线设置组 。使得它们彼此之间可以相互通信交流。 第三步：Scratch 环境初始化 ¶ 完成上述两步后，我们保持 中转站 与 计算机 的连接。并为 功能板 持续供电。 比如像这样的 打开 Adapter 在 Scratch 中启用 Micro:bit插件 ps：对这部分不熟悉的同学，请回看 入门案例：microbit 第四步：在 Scratch 中为功能板编程 ¶ 经过前三步，我们已经为两块 Micro:bit 和 Scratch 建立起连接。 现在， 我们要在 Scratch 中为 功能板 定义行为，用 A 和 B 按键来控制小猫的移动。 Scratch 代码如图所示： Micro:bit Radio项目 点击绿旗，再按下 功能板 的按键，小猫是不是如你所愿地前进和后退了呢？ 在 Scratch中 点击发送字符 “c” 的积木块，我们就可以在 功能板 上看到一个爱心了。 消息流动的过程 ¶ 在这个案例中，一共涉及了 三个对象 在沟通和交流。 Scratch，Micro:bit中转站 和 Micro:bit功能板 。 对象之间的消息传递如下图所示： 启发与想象力 ¶ 通过这个案例，我们可以看到， Adapter 可以将不同的对象连接起来，让不同对象可以彼此交互， 不仅仅是单一 Micro:bit 可以与 Scratch 进行交互，而且是整个 Micro:bit 生态 。 通过修改 功能板 的 makecode代码 ，以及 Scratch中的代码 我们可以使用 Micro:bit 更多的传感器来触发 我们想要发送的消息 。 比如人和人之间表示友好，不仅可以通过言语问候，也可以通过握手。 我们可以定义 Micro:bit 接收到特定的消息时，所作出的反应。 如果配合 Micro:bit 各种功能各异的扩展板，也许我们就可以构建出一个属于自己的计算机实体乐园了。 以上可能还不能满足一些好奇小伙伴的野心： 我能用其他对象（比如Python对象）去和 Micro:bit 生态 进行交互吗？这样我就可以让 Micro:bit 获得更多可自定义的行为了。 当然可以啦！接下来我们将用 Scratch PPT 的例子，展示 Python对象，Scratch对象 和 Micro:bit 的交流协作，去制作一个扩展多功能的独特 PPT 。","text_tokens":["的","绿旗","一个","解释","事情","两步","上","第二","看到","吗","内置","互相","比如","做","说明","radio","协作","小花","什么","四步","一共","制作","scratch","通信","需要","为","作为","usb","那","本篇","充分","已经","让","生态","在","石器","一步","入门","基本知识","发现","第一","呀","获得","过程","计算机","对","分别","2","发送","以便","工作","!","感器","属于","方式","并","同一个","中转站","彼此","不同","构建","图","初始","这","等","！","如下","多块","一块","后退","¶","触发","而","a","三个","按键","投","所愿","第一步","小伙","插件","hex","只要","持续"," ","但","大堆","多功能","到","线","即当","算机","接收","扩展","所","映射","伙伴","行为","作出","部分","简单","利用","而且","想象","友好","问","下来","按下","”",".","第三","要","关系","点击","以上","可能","各异","两块","交流","下载","一大堆","握手","是不是",")","板","结合","相连","来","按","按钮","第二步","想","c","传感","传感器","案例","前","其中","出","它们","表示","好","。","ppt","打开","收到","相互","实体","用到","开始","看","二步","眼尖","乐园","请","启发","有","向","拖入","看不懂","项目","）","独特","无线","提供","文件夹","字符串","再","另","供电","无线通信","组","与","能为","代码","一些","丰富","第三步","消息","能力","如你所愿","想法","表达","控制","步骤","(","不仅","可以","呢","不仅仅","知识","如果","我","现在","地","bit","用","同一","反应","功能","上述","关键","仅仅","介绍","一样","野心","下","这部","对象连接",":","也许","b","还","不是","各种","大家","语言","之后","fire","如图所示","参考","文件","和","自定","将","python","中","官方","通过","这里","首先","整个","建立","收发","熟悉","展示","转站","例子","：","microbit","所示","没关","供","不能","我能","教程","前三步","？","彼此之间","需求","这部分","涉及","中转","交互","字符","进行","里","置于","问候","起","积木","更","一大","视频","中文","编程","能","这个","环境","满足","ps","保持","计算","了解","原理","三步","对象","沟通","这样","移动","“","时","消息传递","后缀","快门","接下来","后缀名","三块","我们","就","多个","自定义","为什么","（","之间","基本","单一","导入","社区","中为","在于","后","目的","去","只是","adapter","了","设置","会","特定","本地","小伙伴","第四","实现","好奇","前进","经过","想要","链接","简称","流动","自己","启用","相应","件夹","当然","回","爱心","啦","块","同学","知道","传递","makecode","micro","人","初始化","无法","也","推荐","，","完成","烧入","连接","接下","可","浇水","起来","定义","模块","多","没关系","以及","其他","使得","想象力","连入","配合","像","使用","显示","先","不","修改","是","言语","有趣","小猫","第四步"],"title":"无线Micro:bit：Radio","title_tokens":["radio",":","micro","：","bit","无线"]},{"location":"project_tutorial/microbit_pt/#microbit-radio-adapter","text":"在 入门案例2 中，我们通过 Micro:bit 插件 ， 在 Scratch 中对 Micro:bit 编程，但如果要充分使用 Micro:bit生态 的能力， 一块 Micro:bit 无法满足我们表达想法的需求。比如在 Fire!:投石器 项目中我们用到了 三块Micro:bit 。 而 Micro:bit Radio 插件 可以连接多块 Micro:bit ，并将 Scratch 和 Python语言 的能力结合到 Micro:bit 中。","text_tokens":["!","投","的","生态","可以","并",":","在","石器","micro","。","入门","如果","三块","无法","我们","插件","使用","，","语言","fire"," ","比如","用到","连接","和","bit","但","编程","radio","结合","将","python","需求","中","多块","scratch","到","对","通过","一块","满足","案例","了","2","而","要","能力","充分","项目","想法","表达"],"title":"Micro:bit Radio 与 Adapter","title_tokens":["radio","adapter",":","与"," ","micro","bit"]},{"location":"project_tutorial/microbit_pt/#_1","text":"在本篇教程中，我们将使用 Adapter 的 Micro:bit Radio 插件 连接两块 Micro:bit ，其中一个为 消息中转板 ，另一个为 功能板 。通过实现 无线控制小猫的案例，展示 Micro:bit 生态 与 Scratch 的连接。","text_tokens":["展示","的","生态","一个",":","在","两块","实现","micro","。","另","我们","插件","使用","，"," ","连接","bit","板","radio","教程","将","与","功能","中","scratch","通过","为","小猫","案例","adapter","消息","中转","本篇","其中","控制","无线"],"title":"教程目的","title_tokens":["目的","教程"]},{"location":"project_tutorial/microbit_pt/#_2","text":"在案例开始前，我们先介绍一些基本知识，以便了解 Micro:bit生态 能做什么，以及 Micro:bit Radio 插件的工作方式。","text_tokens":["的","方式","生态",":","在","知识","micro","。","基本知识","我们","插件","，"," ","做","基本","bit","开始","先","能","radio","什么","一些","案例","介绍","以及","了解","前","以便","工作"],"title":"原理解释","title_tokens":["原理","解释"]},{"location":"project_tutorial/microbit_pt/#microbit","text":"在 入门案例2 中， 我们简单介绍了 Micro:bit 是什么？ 那 Micro:bit 生态 能做什么呢？ ，链接中的视频，向我们展示了 Micro:bit 能为我们按下快门，为小花浇水等一大堆有趣的事情。 不熟悉 Micro:bit 的小伙伴，我们推荐 micro:bit 官方社区 和 中文社区 ，社区里有丰富的教程与案例，供大家参考。","text_tokens":["熟悉","展示","的","生态","小伙伴",":","在","事情","里","伙伴","小伙","呢","快门","micro","。","入门","我们","简单","推荐","，","一大堆","大家","参考"," ","链接","做","一大","和","视频","bit","中文","供","浇水","大堆","能","社区","教程","与","能为","？","等","小花","什么","中","不","官方","按下","丰富","是","有","为","有趣","案例","介绍","了","2","向","那"],"title":"Micro:bit 生态能做什么","title_tokens":["能","生态",":"," ","什么","做","micro","bit"]},{"location":"project_tutorial/microbit_pt/#microbit-radio","text":"Micro:bit Radio 使用了 Micro:bit 内置的无线通信模块，使得多块 Micro:bit 可以互相通信。 这需要 一块 Micro:bit 作为 消息中转站 ， Micro:bit 消息中转站 (简称 中转站 ）需要用USB线与计算机相连， 而其他 Micro:bit 作为 功能板 就通过 中转站 与计算机进行连接。 再建立以上连接之后，我们就可以通过 Scratch 对 功能板 Micro:bit (简称 功能板 ）进行编程，比如用 功能板 控制小猫的移动。 小伙伴可能会问： “我一块 Micro:bit 也能控制小猫的移动呀，为什么要用两块呢？” 在这里，只是想用一个简单的案例，说明多个 Micro:bit 连接的方式，为连接多个 Micro:bit 提供一个案例，以便我们利用多个 Micro:bit 表达我们的想法。","text_tokens":["的","算机","(","“","可以","一个","伙伴","呢","内置","我","我们","就","简单","多个","利用","互相","为什么","比如","说明","bit","用","radio","问","功能","什么","需要","通信","scratch","”","为","只是","作为","了","usb","要","会","以上","可能","小伙伴",":","两块","在","之后","简称","呀","板","相连","想","计算机","对","通过","这里","案例","以便","建立","方式","转站","micro","。","中转站","：","也","，","连接","模块","这","？","多块","一块","其他","使得","中转","而","进行","）","无线","提供","小伙","再","使用"," ","编程","无线通信","能","与","线","小猫","计算","消息","想法","表达","控制","移动"],"title":"Micro:bit Radio 插件","title_tokens":["插件","radio",":"," ","micro","bit"]},{"location":"project_tutorial/microbit_pt/#_3","text":"","text_tokens":[],"title":"案例：无线控制小猫移动","title_tokens":["移动","小猫","案例","：","控制","无线"]},{"location":"project_tutorial/microbit_pt/#microbit_1","text":"用USB线，将 功能板 连入计算机中 首先我们先在 makecode 中为 Micro:bit功能板 定义向 Micro:bit中转站 发送消息的按键 映射 按钮 “A” 和 “B” 分别发送字符串“a” 和 “b” 到中转站。 定义收到 Micro:bit中转站 消息的行为 即当 功能板 收到字符 “c” 时，显示爱心 我们将这 功能板 makecode代码 （文件后缀名为.hex)下载到计算机本地文件中，并拖入到 Micro:bit 文件夹中，完成代码的导入。","text_tokens":["按键","的","算机","“","时","连入","本地","并",":","在","文件夹","映射","后缀","转站","makecode","字符串","行为","micro","中转站","。","后缀名","b","收到","我们","下载","，","hex","（","完成"," ","文件","和",")","bit","用","显示","导入","先","板","定义","将","代码","这","中为","按钮","功能","中","c","计算机","线","到","”","为",".","件夹","分别","计算","usb","首先","向","消息","拖入","中转","字符","爱心","发送","a","即当"],"title":"第一步：为 Micro:bit功能板 编程","title_tokens":["为","板","第一步",":","一步","第一"," ","功能","micro","：","bit","编程"]},{"location":"project_tutorial/microbit_pt/#microbit_2","text":"在 makecode 为 中转站 编程 定义向 Adapter 收发消息的功能 定义向 Micro:bit功能板 收发消息的功能 和第一步一样，下载 消息中转站 makecode代码 ，并烧入中转站。 以上的代码，看不懂是没关系的，只要我们知道相应的模块是做什么的就好了。 眼尖的小伙伴发现，上述步骤的关键，在于将 中转站 和 功能板 置于同一个 无线设置组 。使得它们彼此之间可以相互通信交流。","text_tokens":["的","第一步","步骤","知道","它们","以上","可以","并",":","在","小伙伴","一个","伙伴","小伙","一步","转站","makecode","同一个","好","无线","micro","中转站","。","交流","没关","置于","我们","就","下载","，","发现","相互","彼此","之间","只要","烧入","第一"," ","做","和","bit","编程","定义","板","同一","模块","将","组","代码","功能","彼此之间","眼尖","什么","相应","在于","是","通信","为","上述","没关系","关键","向","adapter","消息","了","一样","中转","使得","设置","看不懂","关系","收发"],"title":"第二步：为 Micro:bit中转站 编程","title_tokens":["为",":","中转","第二","第二步","二步"," ","转站","micro","中转站","：","bit","编程"]},{"location":"project_tutorial/microbit_pt/#scratch","text":"完成上述两步后，我们保持 中转站 与 计算机 的连接。并为 功能板 持续供电。 比如像这样的 打开 Adapter 在 Scratch 中启用 Micro:bit插件 ps：对这部分不熟悉的同学，请回看 入门案例：microbit","text_tokens":["熟悉","同学","的","这部","算机","并",":","在","两步","转站","像","。","中转站","micro","：","部分","入门","microbit","打开","我们","插件","，","完成","供电","持续"," ","比如","连接","bit","看","板","与","启用","功能","不","中","后","计算机","scratch","这部分","对","请","为","上述","ps","保持","案例","计算","adapter","回","中转","这样"],"title":"第三步：Scratch 环境初始化","title_tokens":["第三步","初始","第三"," ","三步","：","scratch","环境","初始化"]},{"location":"project_tutorial/microbit_pt/#scratch_1","text":"经过前三步，我们已经为两块 Micro:bit 和 Scratch 建立起连接。 现在， 我们要在 Scratch 中为 功能板 定义行为，用 A 和 B 按键来控制小猫的移动。 Scratch 代码如图所示： Micro:bit Radio项目 点击绿旗，再按下 功能板 的按键，小猫是不是如你所愿地前进和后退了呢？ 在 Scratch中 点击发送字符 “c” 的积木块，我们就可以在 功能板 上看到一个爱心了。","text_tokens":["按键","所愿","的","绿旗","“","可以","一个",":","两块","在","上","看到","控制","呢","行为","前进","micro","。","所示","：","经过","再","b","现在","我们","起","不是","，","积木","块","就","地","如图所示"," ","是不是","连接","和","bit","用","如你所愿","板","定义","radio","前三步","来","代码","按","中为","？","功能","中","c","scratch","”","为","后退","小猫","了","字符","三步","要","发送","下","a","项目","点击","爱心","建立","移动","已经"],"title":"第四步：在 Scratch 中为功能板编程","title_tokens":["板","第四","在","第四步","中为","功能"," ","四步","：","scratch","编程"]},{"location":"project_tutorial/microbit_pt/#_4","text":"在这个案例中，一共涉及了 三个对象 在沟通和交流。 Scratch，Micro:bit中转站 和 Micro:bit功能板 。 对象之间的消息传递如下图所示：","text_tokens":["的","消息传递",":","在","交流","传递","转站","micro","。","中转站","所示","：","，","之间"," ","和","bit","板","图","这个","功能","中","一共","如下","scratch","涉及","案例","了","消息","中转","对象","沟通","三个"],"title":"消息流动的过程","title_tokens":["过程","消息","的","流动"]},{"location":"project_tutorial/microbit_pt/#_5","text":"通过这个案例，我们可以看到， Adapter 可以将不同的对象连接起来，让不同对象可以彼此交互， 不仅仅是单一 Micro:bit 可以与 Scratch 进行交互，而且是整个 Micro:bit 生态 。 通过修改 功能板 的 makecode代码 ，以及 Scratch中的代码 我们可以使用 Micro:bit 更多的传感器来触发 我们想要发送的消息 。 比如人和人之间表示友好，不仅可以通过言语问候，也可以通过握手。 我们可以定义 Micro:bit 接收到特定的消息时，所作出的反应。 如果配合 Micro:bit 各种功能各异的扩展板，也许我们就可以构建出一个属于自己的计算机实体乐园了。 以上可能还不能满足一些好奇小伙伴的野心： 我能用其他对象（比如Python对象）去和 Micro:bit 生态 进行交互吗？这样我就可以让 Micro:bit 获得更多可自定义的行为了。 当然可以啦！接下来我们将用 Scratch PPT 的例子，展示 Python对象，Scratch对象 和 Micro:bit 的交流协作，去制作一个扩展多功能的独特 PPT 。","text_tokens":["的","接收","不仅","时","所","可以","扩展","一个","算机","吗","看到","伙伴","不仅仅","行为","作出","接下来","如果","我","我们","而且","就","自定义","（","之间","比如","bit","单一","用","友好","反应","功能","协作","下来","制作","scratch","去","仅仅","adapter","了","野心","特定","让","对象连接","生态","以上","各异","可能",":","小伙伴","交流","好奇","也许","想要","还","各种","握手","和","板","自定","将","来","自己","python","获得","中","传感","计算机","传感器","通过","案例","当然","整个","发送","啦","出","展示","感器","属于","表示","makecode","例子","micro","。","：","人","ppt","也","，","实体","彼此","不同","连接","构建","接下","可","不能","起来","我能","定义","？","多","！","乐园","以及","触发","其他","交互","进行","）","独特","配合","小伙","问候","使用","更"," ","多功能","与","代码","这个","一些","修改","是","到","言语","满足","计算","消息","对象","这样"],"title":"启发与想象力","title_tokens":["与","想象力","启发","想象"]},{"location":"project_tutorial/object_illustrate/","text":"对象和消息 ¶ 在开始进入具体项目前，我们先来看一看什么是对象和消息？ Scratch中的对象和消息 ¶ 在Scratch中，如果我们想要不同的 动画角色 能够互相交流，可以怎么做呢？比如 小熊快跑 项目（鼓励狂点链接查看源码） 在这个例子中，小猫向小熊大喊了一句： “Yo！小熊快跑” ，然后当小熊听到小猫的喊话后，小熊边跑边大喊： “Yo！小猫跟上啊！” ，小猫随即跟上了小熊的步伐。 现在我们来回答： 什么是消息？ 消息是不同对象之间的“对话”，对象之间通过不断“对话”彼此交流和协作 。 在Scratch中让不同动画角色相互对话的过程中， 对象 就是 动画角色 。 小猫和小熊之间的对话是通过 广播消息 和 接收消息 积木完成的。小猫和小熊分别接收对方发送的消息，然后作出相应的反应。 广播消息积木 接收消息积木 Adapter中的对象和消息 ¶ 在 Adapter 中，我们通过不同的 插件 ，去连接不同的 对象 ， 通过 Adapter 连接的 对象 就是通过 消息 进行交流和互动的。 在这里，我们可以先简单的将消息理解为 不同形式的“对话” 就好了。 对象的特性 ¶ 好奇的同学可能会问：“小熊一定要那么听话向前跑吗？” 当然可以说不啦！上面案例的小熊其实是 熊出没 里的熊二，熊二很可能会这样回答小猫： “俺太胖啦，跑不动啊 :( ”，然后就站在原地动也不动。 我们可以看到对象有一个很重要的特性： 对象可以完全不对消息作出反应，继续做自己的事 。比如：你在打游戏，妈妈叫你写作业啦，你不听，继续玩多一会 :) 我们可以利用这个特性做什么呢？别急，先卖个关子，我们在后续的教程中我们再详细讲述。 在理解了什么是对象和消息后，我们将进入第一项目教程： EIM插件 。","text_tokens":["的","接收","“","(","可以","一个","吗","听话","看到","你","呢","作出","如果","跑","现在","我们","简单","就","向前","叫","互相","利用","（","之间","原地","听","比如","做","说","问","反应","协作","什么","后","scratch","一看","”","去","为","重要","怎么","了","adapter","要","会","大喊","让","对话","可能",":","在","交流","好奇","鼓励","动","边","想要","打游戏","俺","第一","链接","形式","讲述","和",")","关子","别急","将","来","自己","yo","太胖","中","相应","过程","步伐","来看","通过","对","这里","分别","当然","案例","游戏","然后","作业","查看","当","发送","eim","前","啦","同学","快","能够","例子","好","。","一句","：","上面","动画","也","熊二","玩","，","听到","相互","彼此","完成","就是","不同","跟上","小熊","连接","出没","喊话","开始","教程","？","进入","其实","随即","！","对方","广播","狂点","很","有","一会","¶","向","继续","写","项目","进行","）","那么","作出反应","里","回答","多一会","跑不动","互动","一定","再","详细","插件","理解","积木","先卖个"," ","事","先","站","啊","后续","这个","妈妈","不","是","源码","熊出没","角色","完全","小猫","不断","消息","不动","对象","特性","具体","这样"],"title":"对象与消息","title_tokens":["消息","与","对象"]},{"location":"project_tutorial/object_illustrate/#_1","text":"在开始进入具体项目前，我们先来看一看什么是对象和消息？","text_tokens":["开始","一看","先","和","我们","，","消息","在","？","进入","什么","前","对象","具体","项目","是","来看"],"title":"对象和消息","title_tokens":["和","消息","对象"]},{"location":"project_tutorial/object_illustrate/#scratch","text":"在Scratch中，如果我们想要不同的 动画角色 能够互相交流，可以怎么做呢？比如 小熊快跑 项目（鼓励狂点链接查看源码） 在这个例子中，小猫向小熊大喊了一句： “Yo！小熊快跑” ，然后当小熊听到小猫的喊话后，小熊边跑边大喊： “Yo！小猫跟上啊！” ，小猫随即跟上了小熊的步伐。 现在我们来回答： 什么是消息？ 消息是不同对象之间的“对话”，对象之间通过不断“对话”彼此交流和协作 。 在Scratch中让不同动画角色相互对话的过程中， 对象 就是 动画角色 。 小猫和小熊之间的对话是通过 广播消息 和 接收消息 积木完成的。小猫和小熊分别接收对方发送的消息，然后作出相应的反应。 广播消息积木 接收消息积木","text_tokens":["的","接收","“","可以","呢","作出","如果","跑","现在","我们","互相","（","之间","比如","做","反应","协作","什么","后","scratch","”","怎么","了","大喊","让","对话","在","交流","鼓励","边","想要","链接","和","来","yo","中","相应","过程","步伐","通过","分别","然后","查看","当","发送","快","能够","例子","。","一句","：","动画","，","听到","相互","彼此","完成","就是","不同","跟上","小熊","喊话","？","随即","！","对方","广播","狂点","向","项目","）","回答","积木"," ","啊","这个","源码","是","角色","小猫","不断","消息","对象"],"title":"Scratch中的对象和消息","title_tokens":["的","消息","对象","中","和","scratch"]},{"location":"project_tutorial/object_illustrate/#adapter","text":"在 Adapter 中，我们通过不同的 插件 ，去连接不同的 对象 ， 通过 Adapter 连接的 对象 就是通过 消息 进行交流和互动的。 在这里，我们可以先简单的将消息理解为 不同形式的“对话” 就好了。","text_tokens":["的","“","对话","可以","在","交流","好","互动","。","我们","插件","简单","，","理解","就","就是"," ","不同","形式","连接","和","先","将","中","通过","”","去","这里","为","adapter","消息","了","对象","进行"],"title":"Adapter中的对象和消息","title_tokens":["的","adapter","消息","中","对象","和"]},{"location":"project_tutorial/object_illustrate/#_2","text":"好奇的同学可能会问：“小熊一定要那么听话向前跑吗？” 当然可以说不啦！上面案例的小熊其实是 熊出没 里的熊二，熊二很可能会这样回答小猫： “俺太胖啦，跑不动啊 :( ”，然后就站在原地动也不动。 我们可以看到对象有一个很重要的特性： 对象可以完全不对消息作出反应，继续做自己的事 。比如：你在打游戏，妈妈叫你写作业啦，你不听，继续玩多一会 :) 我们可以利用这个特性做什么呢？别急，先卖个关子，我们在后续的教程中我们再详细讲述。 在理解了什么是对象和消息后，我们将进入第一项目教程： EIM插件 。","text_tokens":["的","“","(","可以","一个","吗","听话","看到","你","呢","作出","跑","向前","就","我们","叫","利用","原地","听","比如","做","说","问","反应","什么","后","”","重要","了","要","会","可能",":","在","好奇","动","打游戏","俺","第一","讲述","和",")","关子","别急","将","自己","太胖","中","对","案例","当然","游戏","然后","作业","eim","啦","同学","。","：","上面","也","熊二","玩","，","小熊","出没","教程","？","进入","其实","！","有","很","一会","继续","写","项目","那么","作出反应","里","回答","多一会","跑不动","一定","再","详细","插件","理解","先卖个"," ","事","站","啊","后续","妈妈","这个","不","是","熊出没","完全","小猫","消息","不动","对象","特性","这样"],"title":"对象的特性","title_tokens":["的","对象","特性"]},{"location":"project_tutorial/scratch_ppt/","text":"制作一个多功能 Scratch PPT ¶ 经过前两个教程，我们已经将 Scratch 创作表达的环境延伸到了 计算机系统 以及 Micro:bit 生态 。 可别忘了， Adapter 可以 连接多个对象 ，并让 对象们 彼此沟通，由此构成一个 可理解 和 可扩展 的编程环境 。 我们作为创作主体，在这个编程环境中，自由地表达我们的想法，让想象成为可能。 现在，我们开始进入由多个对象构成的创作环境中编程。 案例思考 ¶ 我们知道， Scratch 可以制作 PPT（幻灯片） 。美中不足的是，这个 PPT 缺乏一些可扩展的功能比如： 打开计算机本地的视频 PPT 换页只能依靠点击鼠标 。。。 而在之前的案例中，我们尝试 使用 Ptyhon对象 获得了 计算机操作系统 的信息 使用 无线Micro:bit 去控制 Scratch小猫 移动。 咦！这不恰好可以用之前尝试过的案例用于改进 Scratch PPT 了吗？ 案例：改进一个 Scratch PPT ¶ 在这里我们尝试在已有的 Codelab演讲PPT (点击链接，打开项目) 上进行改进，为其添加以下功能 无线Micro:bit 作为翻页笔 可以打开任意网站视频（以 Codelab官网 为例） PPT 源码 ¶ 在 help_tool角色 中代码定义了 翻页功能 ，以及 打开本地文件 和 打开网页链接 的自定义积木。（见图注） 值得一提的是： 这里引入 Python对象 能力的方式与 Eim插件教程 不一样，用到的是 Python插件 。在 入门教程1 中有示例如何使用。 这里简单解释一下插件工作的原理，在 Python插件 代码文件中，定义了 PyHelper类 ，在该类中定义了用于打开连接的 open_url 方法 。Scratch积木块通过广播一条 代码语句 ： PyHelper.open_url(url) 给 Python对象 ，然后 Python对象 就会执行这段代码，打开相应的链接了。 提醒 PyHelper类中还有一个方法很实用: open , 这个方法以系统默认的方式打开任何东西: 诸如文本、图片、视频、软件...只要传入想打开的东西的 绝对系统路径 即可。诸如打开Chrome浏览器: PyHelper.open(\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\") python广播积木 ps： python插件 和 eim插件 的区别需要小伙伴先具备一些Python语言知识，我们将会在插件开发手册中详细解释两者的具体区别。 另外两个角色的代码定义了一个翻页动画，我们将会在动画结束后，利用自定义积木自动弹出 Codelab 的介绍视频。 无线 Microbit 作为翻页笔 ¶ 第一步：准备两块 Micro:bit ¶ 我们按照上一篇教程： Micro:bit Raio ，在 madecode 中定义好 功能板 和 中转板 的行为。让我们可以在 Scratch中使用 功能板 的 A键 （左上方按钮） 和 B键 （右上方按钮）。 第二步：绑定翻页功能 ¶ 我们将 功能板 的 A键 绑定到 向前翻页 ， B键 绑定到 向后翻页 。 现在尝试按下 Micro:bit 功能板 的 A / B 键 ， PPT 开始翻页了！ 翻页动画打开 Codelab官网 ¶ 当翻页到 Codelab 标志时，会有一个动画介绍 Codelab 概况。 现在，我们在动画结束后，自动转到介绍 Codelab视频 中。 我们先来看看 角色introduction 的代码 在这个角色收到 show_codelab_introduction 的消息时，开始出场动画，然后 Codelab介绍信息 就显示出来了。 那么要在动画结束打开一个网页，就非常简单了，我们只需要 在 introduction角色 中自定义 open_url 积木 使用 open_url 积木 代码如下： 现在尝试一下，是否能在翻页动画结束后，自动转到 Codelab官网 呢？ 完整项目代码 启发与想象力 ¶ 增强 Scratch PPT 的例子就此完结了，不知道大家有没有发现，在 Adapter 的帮助下， 我们很容易实现不同对象之间的交互 在 Micro:bit Radio项目 的基础上，无需对Micro:Bit 做任何硬编码（即使用makecode去定义按键的具体功能）， 通过两个积木块，就可以赋予 Micro:Bit 翻页笔的功能 将 Python对象打开网址的能力， 即刻赋予给翻页动画 根据消息的沟通随时绑定对象 ，正是 Adapter 的最核心特性。 前面提到的 对象可以根据自己的需要去响应来自其他的对象的消息 在这里得以体现，如果我不想用 Micro:bit 翻页，换成眼动仪，也就是拖动两个积木块的事情。这时候， Micro:bit 就可以去控制其他东西了，在 Neverland 中可以是 窗帘的升降 或是 灯光的亮灭 或是。。。现实已经不会成为你想象力的天花板了。 项目教程结语 ¶ 到此为止，项目教程向大家展示了 Adapter 的核心概念：对象 和 消息 Adapter 的基本使用方法 Adapter 的核心特性 核心特性包括 灵活地连接各种实体硬件生态（如 Micro:bit) 拓展 Scratch 使用 计算机操作系统 的能力 不同对象之间的可以灵活地绑定 最重要的是，我们的想法可以在 Adapter 创建出的丰富可编程环境中任意表达了 接下来就是发挥大家想象力的时候了，非常欢迎大家继续跟随 Adapter文档 去探索更多编程的可能性！","text_tokens":[",","的","一个","吗","解释","上","事情","第二","绝对","到此为止","类中","开发","1","向前","help","最","比如","做","硬","radio","拖动","键","构成","制作","scratch","需要","application","为","重要","作为","入门教程","已经","即可","让","生态","在","看看","由此","得以","一步","入门","改进","非常简单","发现","来自","第一","任意","添加","任何","获得","计算机","灵活","对","主体","当","eim","工作","如","方式","并","缺乏","exe","彼此","有没有","不同","为例","另外","方法","这","基础","！","如下","概况","延伸","¶","结语","而","跟随","a","按键","第一步","正是","动弹","体现","小伙","具备","自","详细","插件","咦","标志","只要"," ","多功能","完整","到","演讲","不足","角色","帮助","即","值得一提的是","出来","show","madecode","特性","右上方","算机","扩展","伙伴","行为","鼠标","其","天花板","执行","探索","简单","利用","软件","眼动仪","提到","想象","一篇","浏览器","天花","下来","按下",".","自动","要","点击","上方","可能","两块","操作系统","硬件","翻页",")","板","增强","核心","该类","来","按钮","按照","第二步","换成","想","c","、","案例","提醒","或是","前","出","好","。","幻灯","东西","ppt","打开","收到","不会","实体","段","用到","前面","文本","开始","进入","以下","二步","解释一下","将会","启发","有","向","机系统","继续","项目","）","无线","这时候","已有","完结","操作","只能","创作","pyhelper","思考","与","代码","一些","丰富","introduction","美中","消息","包括","转","能力","具体","想法","表达","控制","创建","(","可以","赋予","这时","窗帘","呢","google","知识","如果","我","现在","\\","地","概念","随时","bit","用","别忘了","功能","tool","右上","左上","中有","介绍","一样","下",":","没有","两个","b","各种","大家","语言","文件","诸如","和","可能性","/","自定","将","python","_","中","路径","通过","示例","这里","chrome","见","只","网页","program","展示","用于","例子","文档","：","microbit","笔","给","由","官网","就是","可编程","恰好","依靠","自由","教程","？","系统","很","默认","中转","交互","url","进行","那么","欢迎","即刻","信息","之前","积木","更","语句","两者","无需","视频","open","为止","编程","能","结束","出场","这个","升降","源码","环境","拓展","ps","计算","们","原理","对象","沟通","图片","移动","一条","时","你","左上方","接下来","我们","就","多个","自定义","灯光","（","之间","基本","files","换页","后","成为","去","codelab","了","adapter","网站","此为","以","会","区别","值得","本地","小伙伴","实现","raio","时候","\"","经过","根据","非常","还有","不想","网址","一下","发挥","链接","类","手册","幻灯片","响应","自己","相应","计算机系统","然后","...","块","就此","是否","知道","浏览","ptyhon","尝试","如何","makecode","micro","动画","也","，","现实","亮","灭","连接","接下","引入","可","定义","编码","多","广播","绑定","以及","其他","neverland","想象力","实用","理解","使用","准备","显示","先","美中不足","图注","可编","不","是","传入","过","小猫","容易"],"title":"多对象交互：Scratch PPT","title_tokens":["交互","多"," ","对象","：","scratch","ppt"]},{"location":"project_tutorial/scratch_ppt/#scratch-ppt","text":"经过前两个教程，我们已经将 Scratch 创作表达的环境延伸到了 计算机系统 以及 Micro:bit 生态 。 可别忘了， Adapter 可以 连接多个对象 ，并让 对象们 彼此沟通，由此构成一个 可理解 和 可扩展 的编程环境 。 我们作为创作主体，在这个编程环境中，自由地表达我们的想法，让想象成为可能。 现在，我们开始进入由多个对象构成的创作环境中编程。","text_tokens":["让","的","算机","扩展","生态","可以","并",":","一个","在","由此","可能","micro","。","两个","经过","现在","我们","理解","多个","，","彼此","地","由","想象","创作"," ","连接","和","bit","可","编程","开始","别忘了","自由","教程","将","这个","构成","进入","中","系统","计算机","到","scratch","环境","成为","主体","延伸","计算机系统","计算","了","以及","adapter","作为","机系统","们","对象","沟通","前","想法","表达","已经"],"title":"制作一个多功能 Scratch PPT","title_tokens":["多功能","一个","功能"," ","制作","scratch","ppt"]},{"location":"project_tutorial/scratch_ppt/#_1","text":"我们知道， Scratch 可以制作 PPT（幻灯片） 。美中不足的是，这个 PPT 缺乏一些可扩展的功能比如： 打开计算机本地的视频 PPT 换页只能依靠点击鼠标 。。。 而在之前的案例中，我们尝试 使用 Ptyhon对象 获得了 计算机操作系统 的信息 使用 无线Micro:bit 去控制 Scratch小猫 移动。 咦！这不恰好可以用之前尝试过的案例用于改进 Scratch PPT 了吗？","text_tokens":["的","算机","知道","扩展","本地","可以",":","在","ptyhon","用于","尝试","吗","鼠标","信息","。","：","micro","幻灯","之前","ppt","打开","缺乏","操作","操作系统","改进","我们","使用","，","咦","（","只能"," ","比如","视频","换页","bit","可","幻灯片","用","恰好","依靠","美中不足","这","？","这个","功能","获得","不","一些","中","系统","！","制作","是","scratch","不足","计算机","去","过","移动","案例","计算","了","美中","小猫","而","对象","点击","）","控制","无线"],"title":"案例思考","title_tokens":["思考","案例"]},{"location":"project_tutorial/scratch_ppt/#scratch-ppt_1","text":"在这里我们尝试在已有的 Codelab演讲PPT (点击链接，打开项目) 上进行改进，为其添加以下功能 无线Micro:bit 作为翻页笔 可以打开任意网站视频（以 Codelab官网 为例）","text_tokens":["已有","的","(","可以",":","在","上","尝试","micro","其","ppt","打开","改进","我们","笔","，","（","官网","翻页"," ","链接","任意",")","bit","视频","添加","为例","功能","以下","演讲","为","这里","codelab","作为","网站","点击","以","项目","进行","）","无线"],"title":"案例：改进一个 Scratch PPT","title_tokens":["改进","案例","一个"," ","：","scratch","ppt"]},{"location":"project_tutorial/scratch_ppt/#ppt","text":"在 help_tool角色 中代码定义了 翻页功能 ，以及 打开本地文件 和 打开网页链接 的自定义积木。（见图注） 值得一提的是： 这里引入 Python对象 能力的方式与 Eim插件教程 不一样，用到的是 Python插件 。在 入门教程1 中有示例如何使用。 这里简单解释一下插件工作的原理，在 Python插件 代码文件中，定义了 PyHelper类 ，在该类中定义了用于打开连接的 open_url 方法 。Scratch积木块通过广播一条 代码语句 ： PyHelper.open_url(url) 给 Python对象 ，然后 Python对象 就会执行这段代码，打开相应的链接了。 提醒 PyHelper类中还有一个方法很实用: open , 这个方法以系统默认的方式打开任何东西: 诸如文本、图片、视频、软件...只要传入想打开的东西的 绝对系统路径 即可。诸如打开Chrome浏览器: PyHelper.open(\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\") python广播积木 ps： python插件 和 eim插件 的区别需要小伙伴先具备一些Python语言知识，我们将会在插件开发手册中详细解释两者的具体区别。 另外两个角色的代码定义了一个翻页动画，我们将会在动画结束后，利用自定义积木自动弹出 Codelab 的介绍视频。","text_tokens":[",","的","一条","(","一个","解释","伙伴","google","绝对","知识","类中","开发","执行","1","\\","我们","简单","自定义","就","软件","利用","（","help","files","浏览器","功能","tool","后","scratch","需要","application",".","中有","codelab","了","介绍","一样","入门教程","以","会","区别","值得","即可","本地","小伙伴",":","在","\"","入门","两个","还有","语言","一下","翻页","链接","文件","类","诸如","和",")","手册","自定","任何","该类","python","_","中","相应","想","路径","c","通过","示例","这里","chrome","、","见","然后","...","网页","提醒","eim","program","块","出","工作","方式","用于","浏览","如何","。","：","东西","打开","动画","给","，","exe","段","用到","连接","引入","文本","另外","定义","方法","教程","这","系统","解释一下","广播","将会","很","以及","默认","url","）","实用","动弹","小伙","具备","自","详细","插件","使用","积木","只要","语句","两者"," ","视频","pyhelper","open","先","结束","与","代码","图注","这个","不","一些","是","角色","传入","ps","值得一提的是","原理","对象","能力","具体","图片"],"title":"PPT 源码","title_tokens":[" ","源码","ppt"]},{"location":"project_tutorial/scratch_ppt/#microbit","text":"","text_tokens":[],"title":"无线 Microbit 作为翻页笔","title_tokens":["笔","作为","翻页"," ","microbit","无线"]},{"location":"project_tutorial/scratch_ppt/#microbit_1","text":"我们按照上一篇教程： Micro:bit Raio ，在 madecode 中定义好 功能板 和 中转板 的行为。让我们可以在 Scratch中使用 功能板 的 A键 （左上方按钮） 和 B键 （右上方按钮）。","text_tokens":["让","的","可以",":","在","上","raio","行为","好","左上方","micro","。","：","b","我们","使用","，","（","一篇"," ","和","bit","定义","板","教程","键","按钮","按照","功能","中","右上","左上","scratch","中转","madecode","a","）","上方","右上方"],"title":"第一步：准备两块 Micro:bit","title_tokens":["第一步",":","准备","两块","一步","第一"," ","micro","：","bit"]},{"location":"project_tutorial/scratch_ppt/#_2","text":"我们将 功能板 的 A键 绑定到 向前翻页 ， B键 绑定到 向后翻页 。 现在尝试按下 Micro:bit 功能板 的 A / B 键 ， PPT 开始翻页了！","text_tokens":["的",":","尝试","micro","。","ppt","b","现在","我们","向前","，","翻页"," ","bit","开始","板","/","将","键","功能","！","按下","后","到","绑定","向","了","a"],"title":"第二步：绑定翻页功能","title_tokens":["第二","第二步","二步","翻页","功能","：","绑定"]},{"location":"project_tutorial/scratch_ppt/#codelab","text":"当翻页到 Codelab 标志时，会有一个动画介绍 Codelab 概况。 现在，我们在动画结束后，自动转到介绍 Codelab视频 中。 我们先来看看 角色introduction 的代码 在这个角色收到 show_codelab_introduction 的消息时，开始出场动画，然后 Codelab介绍信息 就显示出来了。 那么要在动画结束打开一个网页，就非常简单了，我们只需要 在 introduction角色 中自定义 open_url 积木 使用 open_url 积木 代码如下： 现在尝试一下，是否能在翻页动画结束后，自动转到 Codelab官网 呢？ 完整项目代码","text_tokens":["那么","是否","的","时","一个","在","看看","尝试","呢","信息","。","：","打开","收到","非常","动画","现在","我们","就","标志","，","简单","非常简单","自定义","积木","使用","一下","官网","翻页"," ","项目","视频","open","显示","开始","先","定义","能","结束","自定","url","来","代码","出场","？","这个","_","完整","中","如下","概况","后","到","需要","introduction","有","角色","codelab","介绍","消息","了","然后","转","只","自动","当","show","出来","会","要","网页"],"title":"翻页动画打开 Codelab官网","title_tokens":["动画","codelab","官网","翻页"," ","打开"]},{"location":"project_tutorial/scratch_ppt/#_3","text":"增强 Scratch PPT 的例子就此完结了，不知道大家有没有发现，在 Adapter 的帮助下， 我们很容易实现不同对象之间的交互 在 Micro:bit Radio项目 的基础上，无需对Micro:Bit 做任何硬编码（即使用makecode去定义按键的具体功能）， 通过两个积木块，就可以赋予 Micro:Bit 翻页笔的功能 将 Python对象打开网址的能力， 即刻赋予给翻页动画 根据消息的沟通随时绑定对象 ，正是 Adapter 的最核心特性。 前面提到的 对象可以根据自己的需要去响应来自其他的对象的消息 在这里得以体现，如果我不想用 Micro:bit 翻页，换成眼动仪，也就是拖动两个积木块的事情。这时候， Micro:bit 就可以去控制其他东西了，在 Neverland 中可以是 窗帘的升降 或是 灯光的亮灭 或是。。。现实已经不会成为你想象力的天花板了。","text_tokens":["的","可以","赋予","上","事情","这时","窗帘","你","天花板","如果","我","我们","就","灯光","眼动仪","（","之间","提到","想象","最","做","硬","随时","bit","用","天花","radio","拖动","功能","成为","scratch","需要","去","了","adapter","下","已经",":","在","实现","得以","时候","没有","两个","根据","大家","发现","来自","网址","不想","翻页","响应","增强","核心","任何","将","自己","python","换成","中","对","通过","这里","或是","块","就此","知道","makecode","例子","micro","。","东西","ppt","打开","动画","笔","给","也","，","现实","不会","有没有","亮","就是","灭","不同","前面","定义","编码","基础","绑定","很","其他","交互","neverland","项目","）","按键","这时候","正是","想象力","即刻","体现","完结","使用","积木","无需"," ","沟通","不","升降","是","帮助","消息","即","对象","能力","特性","具体","控制","容易"],"title":"启发与想象力","title_tokens":["与","想象力","启发","想象"]},{"location":"project_tutorial/scratch_ppt/#_4","text":"到此为止，项目教程向大家展示了 Adapter 的核心概念：对象 和 消息 Adapter 的基本使用方法 Adapter 的核心特性 核心特性包括 灵活地连接各种实体硬件生态（如 Micro:bit) 拓展 Scratch 使用 计算机操作系统 的能力 不同对象之间的可以灵活地绑定 最重要的是，我们的想法可以在 Adapter 创建出的丰富可编程环境中任意表达了 接下来就是发挥大家想象力的时候了，非常欢迎大家继续跟随 Adapter文档 去探索更多编程的可能性！","text_tokens":["的","算机","可以","到此为止","接下来","探索","我们","（","概念","地","之间","想象","最","基本","bit","下来","scratch","去","重要","了","adapter","此为","生态","可能",":","在","时候","操作系统","非常","各种","大家","硬件","发挥","和","任意",")","核心","可能性","中","计算机","灵活","出","如","展示","micro","文档","：","，","实体","可编程","就是","不同","连接","接下","方法","教程","多","！","系统","绑定","向","继续","跟随","项目","想象力","欢迎","操作","使用","更"," ","为止","编程","可编","丰富","是","环境","拓展","计算","消息","包括","对象","能力","特性","想法","表达","创建"],"title":"项目教程结语","title_tokens":["结语","项目","教程"]},{"location":"project_tutorial/welcome_pt/","text":"教程开篇 ¶ 在快速入门中我们介绍了两个案例： 小猫打开网页 ，我们使用Adapter将小猫和网页连接起来，让小猫打开不同的网页。 Micro：bit say: “hello” ，我们使用Adapter将micro：bit连入创作平台，让Micro：bit 说 “Hello”。 有些小伙伴可能察觉到 我们的创作环境不仅仅局限于创作平台的舞台区了，通过Adapter，我们能够进行编程的事物更多了。 Adapter为创作平台引入了Python能力，积木块可以运行 python 代码去使用计算机操作系统中的功能，比如打开网页。 我们开始触达计算机的编程世界，让我们知道打开网页的方式并不只有一种。 Adapter将Micro：bit与创作平台连接，用积木块就可以控制Micro：bit。 我们建立与硬件沟通的途径，让触手可及的实物理解我们想要表达的想法。 在接下来的教程中，我们将尝试一些有趣的案例，希望我们能够体会到，Adapter最重要的两个核心概念： 对象 和 消息 。 ps： 在进入项目教程之前，建议安装使用 完整版 Adapter","text_tokens":["的","算机","“","不仅","可以","安装","伙伴","不仅仅","接下来","我们","就","概念","最","事物","比如","完整版","bit","用","察觉到","区","说","功能","下来","平台","”","为","去","重要","仅仅","介绍","了","adapter","让","体会","可能","小伙伴",":","在","整版","局限","两个","入门","触手","想要","操作系统","硬件","一种","实物","触手可及","世界","和","舞台","核心","将","python","中","计算机","通过","案例","网页","块","建立","能够","知道","方式","并","尝试","察觉","建议","micro","。","：","打开","，","途径","希望","hello","局限于","不同","连接","接下","引入","开始","起来","快速","教程","接起","运行","多","进入","开篇","只有","系统","say","¶","限于","项目","进行","连入","小伙","之前","操作","理解","使用","积木","更","创作"," ","编程","触达","与","代码","完整","不","一些","连接起来","到","环境","有趣","ps","小猫","计算","消息","能力","对象","沟通","有些","想法","表达","控制"],"title":"教程开篇","title_tokens":["开篇","教程"]},{"location":"project_tutorial/welcome_pt/#_1","text":"在快速入门中我们介绍了两个案例： 小猫打开网页 ，我们使用Adapter将小猫和网页连接起来，让小猫打开不同的网页。 Micro：bit say: “hello” ，我们使用Adapter将micro：bit连入创作平台，让Micro：bit 说 “Hello”。 有些小伙伴可能察觉到 我们的创作环境不仅仅局限于创作平台的舞台区了，通过Adapter，我们能够进行编程的事物更多了。 Adapter为创作平台引入了Python能力，积木块可以运行 python 代码去使用计算机操作系统中的功能，比如打开网页。 我们开始触达计算机的编程世界，让我们知道打开网页的方式并不只有一种。 Adapter将Micro：bit与创作平台连接，用积木块就可以控制Micro：bit。 我们建立与硬件沟通的途径，让触手可及的实物理解我们想要表达的想法。 在接下来的教程中，我们将尝试一些有趣的案例，希望我们能够体会到，Adapter最重要的两个核心概念： 对象 和 消息 。 ps： 在进入项目教程之前，建议安装使用 完整版 Adapter","text_tokens":["的","算机","“","不仅","可以","安装","伙伴","不仅仅","接下来","我们","就","概念","最","事物","比如","完整版","bit","用","察觉到","区","说","功能","下来","平台","”","为","去","重要","仅仅","介绍","了","adapter","让","体会","可能","小伙伴",":","在","整版","局限","两个","入门","触手","想要","操作系统","硬件","一种","实物","触手可及","世界","和","舞台","核心","将","python","中","计算机","通过","案例","网页","块","建立","能够","知道","方式","并","尝试","察觉","建议","micro","。","：","打开","，","途径","希望","hello","局限于","不同","连接","接下","引入","开始","起来","快速","教程","接起","运行","多","进入","只有","系统","say","限于","项目","进行","连入","小伙","之前","操作","理解","使用","积木","更","创作"," ","编程","触达","与","代码","完整","不","一些","连接起来","到","环境","有趣","ps","小猫","计算","消息","能力","对象","沟通","有些","想法","表达","控制"],"title":"教程开篇","title_tokens":["开篇","教程"]},{"location":"scratch_extensions/home_assistant/","text":"Home Assistant ¶","text_tokens":["¶"," ","home","assistant"],"title":"Home Assistant","title_tokens":[" ","home","assistant"]},{"location":"scratch_extensions/home_assistant/#home-assistant","text":"","text_tokens":[],"title":"Home Assistant","title_tokens":[" ","home","assistant"]},{"location":"scratch_extensions/introduction/","text":"介绍 ¶ 欢迎来到 CodeLab Scratch 插件文档。","text_tokens":["插件","codelab","¶","介绍","欢迎","。"," ","来到","文档","scratch"],"title":"介绍(introduction)","title_tokens":["介绍",")","introduction","("]},{"location":"scratch_extensions/introduction/#_1","text":"欢迎来到 CodeLab Scratch 插件文档。","text_tokens":["插件","codelab","欢迎","。","来到"," ","文档","scratch"],"title":"介绍","title_tokens":["介绍"]},{"location":"user_guide/FAQ/","text":"FAQ ¶ 与官方的 Scratch Link 有什么差异？ ¶ 兼容性方面： Scratch Link 目前有以下依赖： Windows 10 version 1709+ macOS 10.13+ Bluetooth 4.0 CodeLab Adapter 对平台和操作系统没有这么高的要求，我们支持： Windows 7、Windows 8、Windows 10（32 位/64 位都支持） macOS 大多数版本 Ubuntu 树莓派 其他 linux 发行版 Scratch Link ； 在连接能力上， Scratch Link 目前只支持 BLE，CodeLab Adapter 支持任何的连接： USB WIFI Bluetooth 2.0/Bluetooth 4.0 大多数的协议（http/websocket/mqtt/ZeroMQ/socket……） ... CodeLab Adapter killer 特性之一是允许普通用户（Scratcher） 使用 Python 拓展 Scratch 的能力 。 CodeLab Adapter killer 特性之二是允许开发者和公司使用 Python 构建自定义的插件，轻松将任何硬件/AI/IOT 设备接入到 Scratch 3.0 中。 Scratch 官方计划开源 Scratch Link ，一旦它们开源，我们将在 CodeLab Adapter 通过插件实现 Scratch Link 的所有功能。 如果你目前要使用以下三种硬件，我们推荐你先使用 Scratch Link。未来我们会和官方的功能完全一样。 Wedo2.0 micro:bit EV3 Scratch Link 和 CodeLab Adapter 可以协同工作。 CodeLab Adapter 致力于提供更好的跨平台支持和开放的 插件系统 ，CodeLab Adapter 的目标是连接万物，不只是连接教育硬件。 CodeLab Adapter 与 CodeLab Scratch3 是否连接成功？ ¶ CodeLab Adapter 启动之后，可以看到 CodeLab Scratch3 指示灯显示绿色，代表连接成功。 启动 CodeLab Adapter 后，与 scratch3 无法通信怎么办？ ¶ 检查下是不是打开了科学上网的软件， 不要使用全局模式。 CodeLab Adapter 可以支持其他平台吗？ ¶ CodeLab Adapter 可以支持其他编程平台吗？而不只是在 CodeLab 的平台上使用。 可以的！ CodeLab Adapter 几乎支持任何平台，无论是 Scratch 3.0 构建的还是 blockly 构建的（如 Tynker 和 code.org）的，或者你用其他什么黑魔法构建的，都没问题！ 这是目前的接入文档： codelab-adapter 支持第三方平台 。 相关的合作条款我们正在构建中。 期待接入 CodeLab Adapter 的公司或组织，欢迎联系我们： wuwenjie718@gmail.com 来信请注明公司/组织的一些基本信息，以及你们正在做的事情 ：） Python 版本(CodeLab Adapter 3.7.0) ¶ 我们在不同操作系统打包时，使用的 Python 版本不同。 Windows：3.7 macOS：3.8 Raspbian：3.7 Ubuntu：3.7 详情可以查看WebUI菜单里的 环境 > 查看 如何使用 Python 拓展 Scratch 的能力？ ¶ Python对象的连接器：EIM 插件 hello world(Adapter Extension) Adapter Node 如何找到 Adapter 主目录 ¶ Adapter 主目录，也是 Adapter 的日志目录，这儿存放了 Adapter 运行时使用的数据。 Mac/Linux 用户的 Adapter 主目录在： ~/codelab_adapter ，如果找不到插件目录（如 Windows 用户），可以通过 CodeLab Adapter Web UI 工具栏里的 插件->打开插件目录 打开它。 如何找到插件目录 ¶ Mac/Linux 用户的插件目录在： ~/codelab_adapter/extensions ，如果找不到插件目录（如 Windows 用户），可以通过 CodeLab Adapter Web UI 工具栏里的 插件->打开扩展目录 打开它，之后找到 extensions 文件夹。 用户配置文件放在哪儿 ¶ ~/codelab_adapter/user_settings.py . Windows 用户如果找不到用户配置文件目录，可以通过 CodeLab Adapter Web UI 工具栏里的 插件->打开插件目录 先打开插件目录，用户配置文件在它的外层。 CodeLab Adapter 网址是什么 ¶ scratch-beta.codelab.club ，你不需要记住， 可以在 Web UI 中打开它。 目前都支持哪些插件 ¶ codelab_adapter_extensions 。 支持移动端吗（iPad/手机） ¶ Adapter 无法直接运行在移动端（可以运行在安卓的linux模拟器（如Termux）上） 在移动端上使用 Adapter 的方式是，将 Adapter 运行在计算机(如树莓派)上，之后通过url参数指向它: https://scratch-beta.codelab.club/?adapter_host=192.168.31.140 但由于不同平台对 https 的限制策略不同，可能需要一些处理技巧。 这是一个 例子 。 自定义存储目录 ¶ 使用环境变量 ADAPTER_HOME_PATH 来软件 home 目录， 例子： ADAPTER_HOME_PATH=/tmp/my_adapter_home ./codelab-adapter --cli 离线使用 ¶ CodeLab Adapter 支持离线使用，目前有 3 种方式使用它。 (推荐) 修改host，添加一条 127.0.0.1 codelab-adapter.codelab.club , 详情 配合 CodeLab Scratch Desktop（离线版） 使用。 将 Web UI 里的 codelab-adapter.codelab.club 替换为 127.0.0.1 ，形如 https://codelab-adapter.codelab.club:12358/?token=YOUR_TOKEN ，重新刷新页面。 推荐使用 方法 1 。 典型的应用场景是在电脑无法联网时，诸如使用 Tello 时。 查看本地环境 ¶ 你将看到: 其中包含了当前 Adapter 所处的计算机环境相关的信息。 软件意外退出 ¶ 当最后一个 client(webui) 关闭时，Adapter将退出。 所以你在刷新webui时也能导致它退出(刷新意味着某个时刻断开) 分布式使用 CodeLab Adapter ¶ @在梦里 同学 提到在树莓派里运行 Scratch 比较卡(需要WebGL)。 CodeLab Adapter 有很好的分布式支持: Adapter Node 可以与 CodeLab Adapter 分布式协同 CodeLab Adapter 可以与 Scratch 分布式协同 为了解决 树莓派里运行 Scratch 比较卡 的问题，我们 可以让Adapter 运行在树莓派里，Scratch 则运行在本机上。 首先在树莓派中运行CodeLab Adapter，复制 WebUI 的URL, 形如: https://codelab-adapter.codelab.club:12358/?token=765b3d2901ef47a0 将 codelab-adapter.codelab.club 修改为 树莓派的 IP 地址: https://192.168.21.104:12358/?token=765b3d2901ef47a0 。 现在你可以在 PC 里打开 树莓派里的 Adapter(需要安全校验) : 接着让我们在 CodeLab Scratch 里使用它, 打开: https://scratch-beta.codelab.club/?adapter_host=192.168.21.104 (adapter_host 是 adapter 所在计算机的 IP，即树莓派的 IP， 它甚至可以运行在互联网的任何设备，任何位置！包括手机！) Tips 考虑到隐私，CodeLab Neverland 自建了聊天服务器，利用的正是以上机制，CodeLab办公室里的计算机都接入 树莓派上的 Adapter。 如何在离网状态下使用CodeLab Adapter ¶ 在某些情况下，可能处于离网状态（诸如控制 tello 时，需要连接到tello网络) @RedYin 给出了一个技巧: 修改hosts 添加如下host规则: 127.0.0.1 codelab-adapter.codelab.club 以下是不同系统的hosts文件所在位置 Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Android: /system/etc/hosts Mac/Linux: /etc/hosts iPhone: /etc/hosts Windows 系统常见文件 ¶ 提示 缺少Python3 ¶ 可能是你把 Adapter 当到了带有 空格 的文件夹里了。 如何获取文件路径 ¶ 以下是windows 10 下的操作: 右键目标文件 -> 属性","text_tokens":["这么",",","的","一个","吗","事情","上","目标","看到","为了","布式","开发","典型","所处","容性","1","来信","数据","做","version","这儿","settings","工具","什么","相关","scratch","通信","需要","模式","为","兼容","usb","限制","1709","规则","接着","ubuntu","哪些","让","-","在","版","机制","hosts","复制","extension","765b3d2901ef47a0","…","3.7","0.1","差异","某些","添加","网络","termux","任何","更好","包含","目录","计算机","期待","对","某个","考虑","接器","环境变量","三种","当","eim","场景","工作","如","方式","faq","或者","页面","web","不同","构建","直接","方法","之二","iot","！","连接器","如下","把","魔法","¶","轻松","而","正是","3.8","外层","10","插件","12358","="," ","情况","但","怎么办","黑魔法","科学","意外","到","主目录","公室","办公室","mac","desktop","即","全局","致力于","特性","策略","第三方","算机","扩展","之一","卡","socket","提示","wifi","tmp","scratcher","利用","软件","获取","提到","club","beta","wedo2.0","问题","意味着","设备","path",".","启动","android","怎么","第三","+","要","以上","可能","文件目录","未来","带有","操作系统","硬件","etc","8","派","是不是","互联网",")","发行","普通","来","wuwenjie718","c","解决","、","webui","配置","联系","raspbian","支持","多数","其中","几乎","最后","存储","校验","它们","依赖","64","好","。","打开","3","发行版","killer","万物","hello","分布式","scratch3","刷新","状态","无论","本","2.0","extensions","开源","没","以下","请","python3","有","务器","常见","还是","比较","打包","client","4.0","）","电脑","提供","开发者","文件夹","7","关闭","详情","bluetooth","操作","模拟器","缺少","pc","指向","与","找","一些","给出","服务器","完全","192.168","包括","地址","能力","目前","控制","(","用户","可以","应用","替换","大多","如果","绿色","现在","\\","你们","存放","bit","用","websocket","方面","com","功能","无论是","甚至","tello","一样","下","接入","检查","这是","py","办公",":","https","协同工作","不到","处理","没有","计划","要求","不是","处于","token","之后","your","成功","文件","诸如","和","变量","致力","合作","/","自定","三方","将","31.140","python","_","link","官方","中","形","空格","路径","通过","linux","首先","?","只","公司","iphone","时刻","host","例子","文档","：","0","分布","技巧","放在","互联","梦里","属性","？","运行","服务","系统","找到","所在","很","允许","127.0","system32","参数","url","日志","正在","意味","普通用户","欢迎","里","信息","同工","zeromq","组织","node","右键","聊天","由于","编程","能","安全","windows","退出","环境","拓展","计算","自建","重新","菜单","对象","macos","移动","所在位置","一条","32","时","所以","你","10.13","通用","条款","我们","自定义","org",">","离网","（","system","当到","基本","离线","端","；","大多数","后","平台","codelab","只是","adapter","了","cli","注明","所有","会","webgl","本地","一旦","跨平台","安卓","实现","ai","~","mqtt","开放","或","drivers","ui","@","位","网址","ip","机上","home","world","redyin","当前","件夹","配置文件","断开","...","查看","联网","是否","同学","ble","兼容性","如何","工具栏","micro","上网","教育","无法","也","树莓","推荐","，","连接","位置","定义","gmail","blockly","模拟","隐私","协同","环境变","code","以及","其他","哪儿","neverland","指示","则","手机","代表","版本","配合","ev3","种","tynker","导致","指示灯","使用","派里","在位","高","它","显示","http","先","记住","不要","tips","都","不","协议","修改","user","是","ipad","my","3.0","21.104"],"title":"常见问题(FAQ)","title_tokens":["(","faq","常见","常见问题",")","问题"]},{"location":"user_guide/FAQ/#faq","text":"","text_tokens":[],"title":"FAQ","title_tokens":["faq"]},{"location":"user_guide/FAQ/#scratch-link","text":"兼容性方面： Scratch Link 目前有以下依赖： Windows 10 version 1709+ macOS 10.13+ Bluetooth 4.0 CodeLab Adapter 对平台和操作系统没有这么高的要求，我们支持： Windows 7、Windows 8、Windows 10（32 位/64 位都支持） macOS 大多数版本 Ubuntu 树莓派 其他 linux 发行版 Scratch Link ； 在连接能力上， Scratch Link 目前只支持 BLE，CodeLab Adapter 支持任何的连接： USB WIFI Bluetooth 2.0/Bluetooth 4.0 大多数的协议（http/websocket/mqtt/ZeroMQ/socket……） ... CodeLab Adapter killer 特性之一是允许普通用户（Scratcher） 使用 Python 拓展 Scratch 的能力 。 CodeLab Adapter killer 特性之二是允许开发者和公司使用 Python 构建自定义的插件，轻松将任何硬件/AI/IOT 设备接入到 Scratch 3.0 中。 Scratch 官方计划开源 Scratch Link ，一旦它们开源，我们将在 CodeLab Adapter 通过插件实现 Scratch Link 的所有功能。 如果你目前要使用以下三种硬件，我们推荐你先使用 Scratch Link。未来我们会和官方的功能完全一样。 Wedo2.0 micro:bit EV3 Scratch Link 和 CodeLab Adapter 可以协同工作。 CodeLab Adapter 致力于提供更好的跨平台支持和开放的 插件系统 ，CodeLab Adapter 的目标是连接万物，不只是连接教育硬件。","text_tokens":["这么","的","32","用户","可以","之一","上","socket","目标","你","wifi","10.13","通用","开发","scratcher","大多","如果","容性","我们","自定义","（","bit","version","wedo2.0","websocket","设备","方面","；","功能","大多数","平台","scratch","兼容","codelab","只是","adapter","usb","一样","+","1709","要","所有","会","ubuntu","接入","一旦","跨平台",":","在","实现","ai","mqtt","未来","协同工作","没有","开放","计划","操作系统","要求","位","硬件","8","…","派","和","致力","发行","普通","/","任何","自定","将","更好","python","link","中","官方","对","通过","、","linux","...","只","支持","公司","三种","多数","工作","它们","ble","兼容性","依赖","64","micro","。","：","教育","发行版","树莓","推荐","，","killer","万物","连接","构建","定义","之二","2.0","iot","开源","以下","系统","有","允许","协同","轻松","其他","4.0","）","普通用户","提供","版本","开发者","ev3","7","10","同工","bluetooth","操作","zeromq","插件","使用"," ","高","http","先","windows","都","不","协议","是","到","拓展","完全","3.0","致力于","能力","特性","目前","macos"],"title":"与官方的 Scratch Link 有什么差异？","title_tokens":["的","与","？","link"," ","什么","官方","差异","scratch","有"]},{"location":"user_guide/FAQ/#codelab-adapter-codelab-scratch3","text":"CodeLab Adapter 启动之后，可以看到 CodeLab Scratch3 指示灯显示绿色，代表连接成功。","text_tokens":["指示灯","启动","绿色","codelab","代表","，","adapter","可以","之后","看到","scratch3","指示"," ","成功","连接","。","显示"],"title":"CodeLab Adapter 与 CodeLab Scratch3 是否连接成功？","title_tokens":["是否","codelab","adapter","与","？","scratch3"," ","成功","连接"]},{"location":"user_guide/FAQ/#codelab-adapter-scratch3","text":"检查下是不是打开了科学上网的软件， 不要使用全局模式。","text_tokens":["检查","模式","的","不是","使用","软件","，","了","不要","科学","全局"," ","是不是","下","。","上网","打开"],"title":"启动 CodeLab Adapter 后，与 scratch3 无法通信怎么办？","title_tokens":["启动","无法","怎么办","codelab","，","怎么","adapter","与","？","scratch3"," ","后","通信"]},{"location":"user_guide/FAQ/#codelab-adapter","text":"CodeLab Adapter 可以支持其他编程平台吗？而不只是在 CodeLab 的平台上使用。 可以的！ CodeLab Adapter 几乎支持任何平台，无论是 Scratch 3.0 构建的还是 blockly 构建的（如 Tynker 和 code.org）的，或者你用其他什么黑魔法构建的，都没问题！ 这是目前的接入文档： codelab-adapter 支持第三方平台 。 相关的合作条款我们正在构建中。 期待接入 CodeLab Adapter 的公司或组织，欢迎联系我们： wuwenjie718@gmail.com 来信请注明公司/组织的一些基本信息，以及你们正在做的事情 ：）","text_tokens":["的","可以","吗","事情","上","你","条款","我们","org","（","来信","你们","做","基本","问题","用","com","什么","无论是","相关","平台","scratch",".","codelab","只是","adapter","第三","注明","接入","这是","-","在","或","@","和","合作","三方","任何","/","wuwenjie718","中","期待","联系","支持","公司","几乎","如","。","文档","：","，","或者","构建","无论","gmail","blockly","？","没","！","请","魔法","code","还是","以及","其他","而","）","正在","欢迎","信息","tynker","使用","组织"," ","编程","黑魔法","都","不","一些","3.0","目前","第三方"],"title":"CodeLab Adapter 可以支持其他平台吗？","title_tokens":["codelab","adapter","可以","吗","其他","？"," ","支持","平台"]},{"location":"user_guide/FAQ/#python-codelab-adapter-370","text":"我们在不同操作系统打包时，使用的 Python 版本不同。 Windows：3.7 macOS：3.8 Raspbian：3.7 Ubuntu：3.7 详情可以查看WebUI菜单里的 环境 > 查看","text_tokens":["的","版本","时","可以","3.8","里","在","。","：","详情","操作系统","操作","我们","使用","，",">"," ","不同","3.7","windows","python","系统","环境","webui","raspbian","查看","菜单","打包","ubuntu","macos"],"title":"Python 版本(CodeLab Adapter 3.7.0)","title_tokens":[".","codelab","版本","(","adapter","python"," ","3.7","0",")"]},{"location":"user_guide/FAQ/#python-scratch","text":"Python对象的连接器：EIM 插件 hello world(Adapter Extension) Adapter Node","text_tokens":["的","接器","插件","(","world","adapter","extension","node","python","hello"," ","对象","连接器","连接","eim","：",")"],"title":"如何使用 Python 拓展 Scratch 的能力？","title_tokens":["的","使用","？","python","如何"," ","能力","scratch","拓展"]},{"location":"user_guide/FAQ/#adapter","text":"Adapter 主目录，也是 Adapter 的日志目录，这儿存放了 Adapter 运行时使用的数据。 Mac/Linux 用户的 Adapter 主目录在： ~/codelab_adapter ，如果找不到插件目录（如 Windows 用户），可以通过 CodeLab Adapter Web UI 工具栏里的 插件->打开插件目录 打开它。","text_tokens":["的","-","时","用户","可以","里","在","~","不到","工具栏","。","：","如果","打开","ui","也","插件","使用","，",">","web","（","数据"," ","存放","它","这儿","/","工具","windows","目录","运行","_","找","是","主目录","通过","codelab","linux","adapter","了","mac","）","日志","如"],"title":"如何找到 Adapter 主目录","title_tokens":["adapter","目录","如何"," ","找到","主目录"]},{"location":"user_guide/FAQ/#_1","text":"Mac/Linux 用户的插件目录在： ~/codelab_adapter/extensions ，如果找不到插件目录（如 Windows 用户），可以通过 CodeLab Adapter Web UI 工具栏里的 插件->打开扩展目录 打开它，之后找到 extensions 文件夹。","text_tokens":["的","-","扩展","用户","可以","里","在","文件夹","~","不到","工具栏","。","：","如果","打开","ui","插件","，",">","web","（","之后"," ","文件","它","extensions","/","工具","windows","目录","找","_","找到","通过","件夹","codelab","linux","adapter","mac","）","如"],"title":"如何找到插件目录","title_tokens":["如何","插件","目录","找到"]},{"location":"user_guide/FAQ/#_2","text":"~/codelab_adapter/user_settings.py . Windows 用户如果找不到用户配置文件目录，可以通过 CodeLab Adapter Web UI 工具栏里的 插件->打开插件目录 先打开插件目录，用户配置文件在它的外层。","text_tokens":["的","-","用户","py","可以","里","在","~","外层","文件目录","不到","工具栏","。","如果","打开","ui","插件","，",">","web"," ","文件","它","先","settings","/","工具","windows","找","目录","_","user","通过",".","codelab","配置","adapter","配置文件"],"title":"用户配置文件放在哪儿","title_tokens":["用户","配置","配置文件","哪儿","文件","放在"]},{"location":"user_guide/FAQ/#codelab-adapter_1","text":"scratch-beta.codelab.club ，你不需要记住， 可以在 Web UI 中打开它。","text_tokens":["-","可以","在","你","。","打开","ui","，","web","club"," ","beta","它","记住","不","中","需要","scratch",".","codelab"],"title":"CodeLab Adapter 网址是什么","title_tokens":["codelab","adapter","网址"," ","什么","是"]},{"location":"user_guide/FAQ/#_3","text":"codelab_adapter_extensions 。","text_tokens":["extensions","codelab","adapter","_"," ","。"],"title":"目前都支持哪些插件","title_tokens":["插件","都","支持","目前","哪些"]},{"location":"user_guide/FAQ/#ipad","text":"Adapter 无法直接运行在移动端（可以运行在安卓的linux模拟器（如Termux）上） 在移动端上使用 Adapter 的方式是，将 Adapter 运行在计算机(如树莓派)上，之后通过url参数指向它: https://scratch-beta.codelab.club/?adapter_host=192.168.31.140 但由于不同平台对 https 的限制策略不同，可能需要一些处理技巧。 这是一个 例子 。","text_tokens":["的","-","算机","方式","(","这是","可以","可能","安卓","在",":","上","host","一个","https","处理","例子","。","模拟器","无法","树莓","使用","，","=","（","之后","派","club"," ","不同","由于","技巧","beta",")","直接","它","但","指向","termux","/","将","31.140","运行","端","_","模拟","一些","计算机","是","scratch","平台","对","通过","需要",".","codelab","192.168","linux","adapter","计算","限制","策略","?","参数","url","）","移动","如"],"title":"支持移动端吗（iPad/手机）","title_tokens":["/","（","吗","端","手机","支持","）","移动","ipad"]},{"location":"user_guide/FAQ/#_4","text":"使用环境变量 ADAPTER_HOME_PATH 来软件 home 目录， 例子： ADAPTER_HOME_PATH=/tmp/my_adapter_home ./codelab-adapter --cli","text_tokens":["-","tmp","例子","：","使用","软件","，","="," ","变量","home","/","来","目录","_","path","环境","my",".","环境变","codelab","adapter","cli","环境变量"],"title":"自定义存储目录","title_tokens":["定义","存储","自定义","自定","目录"]},{"location":"user_guide/FAQ/#_5","text":"CodeLab Adapter 支持离线使用，目前有 3 种方式使用它。 (推荐) 修改host，添加一条 127.0.0.1 codelab-adapter.codelab.club , 详情 配合 CodeLab Scratch Desktop（离线版） 使用。 将 Web UI 里的 codelab-adapter.codelab.club 替换为 127.0.0.1 ，形如 https://codelab-adapter.codelab.club:12358/?token=YOUR_TOKEN ，重新刷新页面。 推荐使用 方法 1 。 典型的应用场景是在电脑无法联网时，诸如使用 Tello 时。","text_tokens":[",","联网","一条","-","的","方式","(","配合","应用","时","里",":","host","版","替换","种","在","https","典型","。","详情","3","1","ui","无法","推荐","使用","，","页面","12358","web","（","token","=","club"," ","your","刷新","诸如","0.1","它",")","添加","方法","离线","/","将","_","修改","形","是","scratch","有",".","为","codelab","adapter","desktop","重新","tello","?","127.0","支持","场景","目前","）","电脑","如"],"title":"离线使用","title_tokens":["离线","使用"]},{"location":"user_guide/FAQ/#_6","text":"你将看到: 其中包含了当前 Adapter 所处的计算机环境相关的信息。","text_tokens":["的","算机",":","看到","你","信息","。","所处"," ","将","包含","当前","相关","计算机","环境","计算","了","adapter","其中"],"title":"查看本地环境","title_tokens":["查看","环境","本地"]},{"location":"user_guide/FAQ/#_7","text":"当最后一个 client(webui) 关闭时，Adapter将退出。 所以你在刷新webui时也能导致它退出(刷新意味着某个时刻断开)","text_tokens":["时刻","意味","(","时","一个","所以","在","你","。","关闭","导致","也","，","刷新"," ",")","它","意味着","能","将","退出","某个","webui","adapter","断开","当","client","最后"],"title":"软件意外退出","title_tokens":["退出","意外","软件"]},{"location":"user_guide/FAQ/#codelab-adapter_2","text":"@在梦里 同学 提到在树莓派里运行 Scratch 比较卡(需要WebGL)。 CodeLab Adapter 有很好的分布式支持: Adapter Node 可以与 CodeLab Adapter 分布式协同 CodeLab Adapter 可以与 Scratch 分布式协同 为了解决 树莓派里运行 Scratch 比较卡 的问题，我们 可以让Adapter 运行在树莓派里，Scratch 则运行在本机上。 首先在树莓派中运行CodeLab Adapter，复制 WebUI 的URL, 形如: https://codelab-adapter.codelab.club:12358/?token=765b3d2901ef47a0 将 codelab-adapter.codelab.club 修改为 树莓派的 IP 地址: https://192.168.21.104:12358/?token=765b3d2901ef47a0 。 现在你可以在 PC 里打开 树莓派里的 Adapter(需要安全校验) : 接着让我们在 CodeLab Scratch 里使用它, 打开: https://scratch-beta.codelab.club/?adapter_host=192.168.21.104 (adapter_host 是 adapter 所在计算机的 IP，即树莓派的 IP， 它甚至可以运行在互联网的任何设备，任何位置！包括手机！) Tips 考虑到隐私，CodeLab Neverland 自建了聊天服务器，利用的正是以上机制，CodeLab办公室里的计算机都接入 树莓派上的 Adapter。","text_tokens":[",","的","算机","(","可以","卡","为了","上","你","布式","现在","我们","利用","提到","club","beta","问题","设备","甚至","需要","scratch",".","为","codelab","adapter","了","接着","webgl","接入","让","-","以上","办公",":","在","机制","https","复制","@","token","765b3d2901ef47a0","ip","派","互联网",")","机上","/","任何","将","_","中","形","计算机","考虑","解决","webui","首先","?","支持","如","联网","同学","校验","host","好","。","打开","树莓","，","分布式","分布","本","位置","互联","梦里","运行","服务","！","隐私","所在","有","很","协同","务器","比较","neverland","则","url","手机","正是","里","使用","派里","12358","=","node","聊天"," ","pc","它","安全","与","tips","都","修改","是","到","服务器","公室","办公室","192.168","计算","包括","即","自建","地址","21.104"],"title":"分布式使用 CodeLab Adapter","title_tokens":["codelab","使用","adapter","分布式","分布","布式"," "]},{"location":"user_guide/FAQ/#codelab-adapter_3","text":"在某些情况下，可能处于离网状态（诸如控制 tello 时，需要连接到tello网络) @RedYin 给出了一个技巧: 修改hosts 添加如下host规则: 127.0.0.1 codelab-adapter.codelab.club 以下是不同系统的hosts文件所在位置 Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Android: /system/etc/hosts Mac/Linux: /etc/hosts iPhone: /etc/hosts","text_tokens":["所在位置","的","-","时","可能","一个",":","在","host","hosts","drivers","\\","，","处于","@","离网","（","etc","system","在位","club"," ","情况","状态","连接","诸如","技巧","0.1",")","不同","文件","某些","添加","位置","网络","/","redyin","windows","以下","修改","如下","给出","系统","c","到","需要","是","所在",".","codelab","android","linux","了","adapter","tello","mac","127.0","system32","规则","下","控制","iphone"],"title":"如何在离网状态下使用CodeLab Adapter","title_tokens":["codelab","使用","adapter","离网","在","如何"," ","状态","下"]},{"location":"user_guide/FAQ/#windows","text":"","text_tokens":[],"title":"Windows 系统常见文件","title_tokens":["常见","windows"," ","文件","系统"]},{"location":"user_guide/FAQ/#python3","text":"可能是你把 Adapter 当到了带有 空格 的文件夹里了。","text_tokens":["的","件夹","可能","adapter","了","文件夹","当到","里","你"," ","带有","把","文件","。","空格","是"],"title":"提示缺少Python3","title_tokens":["缺少","python3","提示"]},{"location":"user_guide/FAQ/#_8","text":"以下是windows 10 下的操作: 右键目标文件 -> 属性","text_tokens":["操作","的","-","windows",">",":","右键","属性","目标","以下"," ","10","文件","下","是"],"title":"如何获取文件路径","title_tokens":["如何","获取","文件","路径"]},{"location":"user_guide/Linda/","text":"Linda ¶ 用于协调不同的程序，使它们进行协作。 提醒 在 Adapter >= 4.0 中可用。 介绍 ¶ CodeLab Adapter 4.0 内置了 Linda server（Tuple Space），目前我们提供了以下客户端（持续增加中...）与 Linda Tuple Space 交互: Python Client Scratch Client REST API cli (命令行客户端) JavaScript Client(开发者) mush-lang Linda 最有趣的一个地方是，所有 Tuple Space 参与者（跨语言、跨系统、跨网络）都能够互操作，语义由参与者自己\"协调\", 所以 Alan Kay 将 Linda 称为\"协调语言\"。 基本操作(operate) ¶ 核心操作 ¶ out: 生成一个元组(tuple) 到 元组空间（tuple space） in: 在tuple space中匹配元组，如果匹配到则消耗它, 如果未匹配则一直等待 inp: in的非阻塞版本。 如果匹配到则消耗它, 如果未匹配则返回空元组 rd: read only, 在tuple space中匹配元组，如果匹配到则返回它(不移除), 如果未匹配则一直等待 rdp: 非阻塞版本的 rd eval: 暂不考虑实现 辅助操作 ¶ 不在 linda 的原始论文中，是我自己的扩展 dump: 获取元组空间所有元组 status: 获取元组空间状态 reboot: 重置元组空间 Python Client ¶ 安装依赖: pip install https://github.com/CodeLabClub/codelab_adapter_client_python/archive/master.zip 提供同步和异步两种基类: AdapterNode AdapterNodeAio AdapterNode ¶ from codelab_adapter_client import AdapterNode class MyNode ( AdapterNode ): NODE_ID = \"linda/test\" def __init__ ( self ): super () . __init__ () node = MyNode () node . receive_loop_as_thread () time . sleep ( 0.1 ) 创建Adapter Node之后，就可以通过node使用linda了。 res = node . linda_reboot () # reboot linda server, clean tuple space assert res == [] res = node . linda_out ([ 1 , 2 , 3 ]) # out assert res == [ 1 , 2 , 3 ] res = node . linda_out ([ 1 , 2 , 4 ]) # out res = node . linda_dump () assert res == [[ 1 , 2 , 3 ], [ 1 , 2 , 4 ]] res = node . linda_rd ([ 1 , 2 , 3 ]) # read and blocking assert res == [ 1 , 2 , 3 ] res = node . linda_rdp ([ 1 , 2 , \"*\" ]) # read but non-blocking assert res == [ 1 , 2 , 3 ] # 先入先出 res = node . linda_in ([ 1 , 2 , 3 ]) # read then remove (blocking) assert res == [ 1 , 2 , 3 ] AdapterNodeAio(异步) ¶ 同步和异步 API 保持一致 import asyncio from codelab_adapter_client import AdapterNodeAio class MyNode ( AdapterNodeAio ): NODE_ID = \"linda/test\" def __init__ ( self ): super () . __init__ () # 以下代码在 jupyter 中运行，如果你想在python脚本中使用，请考虑异步代码的生命周期，参考: https://github.com/CodeLabClub/codelab_adapter_client_python/blob/master/tests/test_linda_client.py#L26 task = asyncio . create_task ( node . receive_loop ()) await asyncio . sleep ( 0.1 ) # !! 等待zmq通信管道建立完成 _tuple = [ \"test_linda\" ] # reboot res = await node . linda_reboot () assert res == [] # out _tuple = [ \"hello\" , \"world\" ] await node . linda_out ( _tuple ) # rdp res = await node . linda_rdp ( _tuple ) assert res == _tuple # inp res = await node . linda_inp ( _tuple ) assert res == _tuple res = await node . linda_dump () assert res == [] 更多用法参考测试文件: test_linda_client.py Scratch Client ¶ REST API ¶ 使用 httpie 作为客户端。 := 表示后边跟的是 json 数据 out ¶ http post https://codelab-adapter.codelab.club:12358/api/linda operate=out tuple:='[\"hello\", \"linda\"]' in ¶ http post https://codelab-adapter.codelab.club:12358/api/linda operate=in tuple:='[\"hello\", \"linda\"]' dump ¶ http post https://codelab-adapter.codelab.club:12358/api/linda operate=dump 其他原语类似 cli (命令行客户端) ¶ pip install https://github.com/CodeLabClub/codelab_adapter_client_python/archive/master.zip # pip install codelab_adapter_client --upgrade # 暂未更新到 pypi codelab-linda --help codelab-linda out --help # reboot codelab-linda reboot # dump codelab-linda dump # out codelab-linda out --data '[1, \"hello\"]' # rd codelab-linda rd --data '[1, \"hello\"]' codelab-linda rd --data '[1, \"*\"]' # rdp codelab-linda rd --data '[1, 2, 3]' # [] # in codelab-linda rd --data '[1, \"*\"]' JavaScript Client ¶ 方便开发者，将 Linda 引入自己的web项目。 CodeLab 目前使用 JavaScript Client，将 Linda 带入 CodeLab Scratch、CodeLab Adapter WebUI 和 Lively。 import AdapterBaseClient from \"./codelab_adapter_base.js\" ; // https://github.com/CodeLabClub/scratch3_eim/blob/v3/codelab_adapter_base.js let NODE_ID = \"linda/js/client\" ; let HELP_URL = \"https://adapter.codelab.club/user_guide/Linda/\" ; let runtime = null ; let adapter_client = new AdapterBaseClient ( NODE_ID , HELP_URL , runtime ); await adapter_client . linda_out ([ 1 , 2 , 3 ]). then (( data )=>{ console . log ( \"linda\" , data ); return data }) tuple = await adapter_client . linda_in ([ \"hi\" , \"lively\" , \"*\" ]). then (( data )=>{ console . log ( \"linda\" , data ); return data }) tuple = await adapter_client . linda_in ([ \"hi\" , \"python\" , \"from Lively\" ]). then (( data )=>{ console . log ( \"linda\" , data ); return data }) tuple = await adapter_client . linda_in ([ \"hello\" , \"lively\" , \"*\" ]). then (( data )=>{ console . log ( \"linda\" , data ); return data }) await adapter_client . linda_in ([ 1 , 2 , 5 ], 1000 ). then (( data )=>{ console . log ( \"linda\" , data ); return data }) //超时 mush-lang ¶ LISP 是一种构建材料 -- Alan Kay 为了更好地探索 Linda 的可能性，我们围绕 Linda 的基本原语，构建了一门简单的语言 -- mush-lang 。 mush-lang 采用 LISP 风格的语法，可以视为 LISP 的一门玩具方言。 LISP 因其同构性(内外表示一致)，可能是所有语言中最简单的。 mush-lang 目前在 Python 中实现。 Demo ¶ 多个 Scratch 角色 的 实时同步 ¶ 在 Python 的例子中，我们甚至在Scratch里构建了 Server！ 两个Scratch角色同步的代码如下 linda-demo1 linda-demo2 python 与 Scratch 同步的代码如下: linda-demo1 Python核心部分代码为: node . linda_out ([ \"request\" , \"loudness\" , \"xxx\" ]) node . linda_in ([ \"response\" , \"loudness\" , \"*\" ]) Jupyter 与 Scratch 的互操作 ¶ 跨语言对象之间的互操作 用到了 Jupyter notebook 里的 ipywidgets. # 请使用 jupyter notebook，而不是jupyterlab from ipywidgets import interact , interactive , fixed , interact_manual from codelab_adapter_client import AdapterNode import time class MyNode ( AdapterNode ): NODE_ID = \"linda/jupyter\" def __init__ ( self ): super () . __init__ () node = MyNode () node . receive_loop_as_thread () @interact ( show = True , x = 100 , size = 100 ) def f ( show , x , size ): node . linda_out ([ \" %% x\" , x ], wait = False ) # f函数是非阻塞的回调函数，使用wait=False参数，使node.linda_out使非阻塞的，此时相当于流，记得使用 message tuple（见下文） node . linda_out ([ \" %% show\" , show ], wait = False ) node . linda_out ([ \" %% size\" , size ], wait = False ) return show , x , size 进阶 ¶ 消息风格 ¶ linda 的基本观点是数据不停生灭（由用户显式操控）。 如果我们想在 Linda 中实现 \"消息/流\" 的模式，可能会遇到tuple堆积（生产者太快）的问题（这是很严重的问题，似乎也不是正确使用linda的方式） 为了尽可能少地破坏概念完整性，我们引入了一种特殊的tuple来支持\"消息/流\"模式。 我们定义了一种叫做 message tuple 的 tuple，它像消息一样，每次只能流的瞬时截面: 一个数据 。 以下是几个message tuple的例子: (\"%%x\", 1) (\"%%y\", 50) (\"%%z\", \"hello\", \"world\") 在语法层面，message tuple只是普通的tuple，唯一区别是第一个元素需要是如下风格字符串， \"%%x\", x可以是任意值，可以把它看作message tuple的id，不同id的message tuple被视为不同tuple，支持tuple的所有操作符。 以下是一个例子: message_tuple demo 视角 站在变量的视角，你可以将其看作全局变量 FAQ ¶ 如何看到 Linda Tuple Space ¶ Adapter >=4.1.0 在 Scratch 里有些 in/rd 积木一直阻塞 ¶ 简单而言，按照以下顺序运行程序: 确保在linda in/rd 积木运行之前，先运行linda reboot 之后在启动Scratch程序 以下是原因分析(可以不看): 这个Linda背后的实现有关，Adapter Linda 目前是C/S架构。Scratch中的 in/rd 积木实际上 promise。 reboot针对的是linda server的操作。 如果程序在 in/rd 的时候，被reboot，则客户端(Scratch)的 in/rd 对应的promise永远不会被解决。 linda reboot 一下 速度 ¶ <!-- ZMQ_LOOP_TIME 以下是一个在scratch里进行速率测试的demo linda-rate → 默认情况下，30帧/s。 在Python客户端，通过修改参数，可以提高到300-600帧/s。 class MyNode ( AdapterNode ): NODE_ID = \"linda/test\" def __init__ ( self ): super () . __init__ ( recv_mode = \"block\" , bucket_fill_rate = 1000 , bucket_token = 1000 ) Linda 与 EIM ¶ Linda 与 EIM 将长期共存，一个 Adapter Node，即是Linda client，也是EIM client，它们各有所擅。长期来看，我们更偏好 Linda。 参考 ¶ 在 CodeLab Adapter 中实现 Linda 并发模型 Linda: 比 Actor 更好的并发模型 [译]Alan Kay 看待'对象'的几次观点转变 建立在异步消息之上的同步指令: 分别在 JavaScript、Python、Squeak 上实现 [译]Smalltalk 背后的设计原则","text_tokens":[",","的","tuple","一个","为了","看到","上","指令","超时","开发","demo","原因","内置","1","help","数据","最","协作","产者","→","scratch","通信","js","需要","模式","为","res","作为","操作符","背后","-","在","dump","tests","一种","第一","速率","0.1","任意","被","尽可能","更新","网络","更好","等待","唯一","模型","z","来看","考虑","后边","promise","rdp","分别","2","thread","blob","记得","eim","未","!","方式","遇到","函数","<","inp","reboot","assert","faq","web","可用","operate","不同","构建","脚本","这","await","玩具","！","操控","如下","特殊","把","命令","then","github","mynode","loudness","返回","几次","¶","似乎","先出","语法","跨","而","super","尽可能少","adapternodeaio","4","12358","=","new","持续"," ","情况","生灭","实际上","adapternode","暂","完整","严重","linda","生成","rest","到","角色","即","偏好","全局","show","扩展","其","部分","interact","探索","f","null","简单","获取","zmq","club","堆积","问题","read","as","import","]","设计",".","启动","and","当于","有关","擅","生命","console","可能","post","response","create","%%","hi","lang","叫做",")","普通","核心","此时","来","按照","增加","想","guide","c","全局变量","解决","、","webui","支持","提醒","进阶","runtime","称为","它们","}","表示","依赖","消耗","一直","视角","。","100","并发","init","3","zip","不会","元素","hello","scratch3","用到","状态","确保","匹配","第一个","message","参与","以下","方言","only","json","请","true","论文","各","异步","client","管道","4.0","项目","）","{","围绕","观点","基类","提供","开发者","互操作","程序","原始","字符串","方便","loop","class","显式","[","操作","破坏","log","只能","httpie","每次","与","代码","ipywidgets","base","消息","demo2","目前","创建","(","带入","用户","可以","wait","data","mode","如果","我","客户端","地","概念","周期","request","长期共存","非","跟","kay","com","甚至","status","对应","测试","介绍","长期","一样","下","值","xxx","py",":","https","manual","两个","install","性","暂未","不是","语言","token","之后","task","参考","使非","文件","和","interactive","变量","协调","__","顺序","可能性","/","将","squeak","python","_","from","太快","中","正确","通过","server","lisp","id","基本操作","瞬时","帧","建立","用法","能够","用于","codelabclub","例子","0","原语","元组","x","v3","由","见下文","语义","一致","运行","jupyterlab","系统","time","转变","很","使","remove","but","默认","交互","字符","参数","api","url","进行","out","upgrade","actor","里","几个","receive","针对","同步","流","之前","smalltalk","积木","in","更","node","是非","blocking","eval","fixed","共存","l26","原则","命令行","站","fill","这个","block","译","保持","阻塞","生命周期","5","一门","rd","asyncio","同构","对象","参与者","test","non","空","材料","安装","clean","所以","你","相当于","生产者","相当","pip","分析","比","我们","就","类似","多个",">","（","风格","之间","4.1","notebook","基本","'","辅助","看作","提高","rate","300","codelab","只是","截面","50","adapter","了","cli","recv","不停","所有","会","区别","移除","demo1","下文","实现","两种","时候","\"","s","实时","self","@","一下","jupyter","视为","保持一致","30","客户","地方","回调","alan","看待","world","自己","false","lively","adapterbaseclient","...","内外","架构","mush","*","如何","let","生产",";","也","，","完成","#","之上","引入","定义","多","完整性","space","永远","y","size","重置","因","尽可","1000","其他","速度","则","空间","版本","sleep","有所","像","而言","使用","实际","pypi","采用","先入","javascript","它","return","def","http","先","archive","master","都","不","修改","user","层面","是","有趣","bucket","600","不看","有些"],"title":"Linda","title_tokens":["linda"]},{"location":"user_guide/Linda/#linda","text":"用于协调不同的程序，使它们进行协作。 提醒 在 Adapter >= 4.0 中可用。","text_tokens":["的","它们","用于","程序","在","。","，",">","=","可用"," ","不同","协调","协作","中","使","adapter","提醒","4.0","进行"],"title":"Linda","title_tokens":["linda"]},{"location":"user_guide/Linda/#_1","text":"CodeLab Adapter 4.0 内置了 Linda server（Tuple Space），目前我们提供了以下客户端（持续增加中...）与 Linda Tuple Space 交互: Python Client Scratch Client REST API cli (命令行客户端) JavaScript Client(开发者) mush-lang Linda 最有趣的一个地方是，所有 Tuple Space 参与者（跨语言、跨系统、跨网络）都能够互操作，语义由参与者自己\"协调\", 所以 Alan Kay 将 Linda 称为\"协调语言\"。","text_tokens":[",","称为","的","-","提供","tuple","(","开发者","mush","一个",":","所有","参与者","能够","互操作","所以","开发","\"","。","内置","操作","我们","，","语言","客户端","（","由","持续"," ","lang","javascript","最","语义","客户",")","地方","协调","kay","命令行","网络","alan","将","与","自己","python","参与","以下","都","中","增加","linda","space","系统","rest","scratch","命令","是","server","codelab","有趣","、","adapter","了","cli","交互","跨","...","api","client","目前","4.0","）"],"title":"介绍","title_tokens":["介绍"]},{"location":"user_guide/Linda/#operate","text":"","text_tokens":[],"title":"基本操作(operate)","title_tokens":["操作","(","基本操作","operate","基本",")"]},{"location":"user_guide/Linda/#_2","text":"out: 生成一个元组(tuple) 到 元组空间（tuple space） in: 在tuple space中匹配元组，如果匹配到则消耗它, 如果未匹配则一直等待 inp: in的非阻塞版本。 如果匹配到则消耗它, 如果未匹配则返回空元组 rd: read only, 在tuple space中匹配元组，如果匹配到则返回它(不移除), 如果未匹配则一直等待 rdp: 非阻塞版本的 rd eval: 暂不考虑实现","text_tokens":[",","未","的","空","(","tuple","版本","一个",":","在","实现","消耗","一直","out","inp","。","元组","如果","，","in","（"," ","匹配","eval",")","它","read","非","暂","等待","不","中","only","生成","space","到","考虑","rdp","返回","阻塞","rd","则","移除","）","空间"],"title":"核心操作","title_tokens":["操作","核心"]},{"location":"user_guide/Linda/#_3","text":"不在 linda 的原始论文中，是我自己的扩展 dump: 获取元组空间所有元组 status: 获取元组空间状态 reboot: 重置元组空间","text_tokens":["的","扩展",":","在","原始","dump","元组","reboot","我","，","获取"," ","状态","自己","不","中","linda","是","status","重置","论文","所有","空间"],"title":"辅助操作","title_tokens":["操作","辅助"]},{"location":"user_guide/Linda/#python-client","text":"安装依赖: pip install https://github.com/CodeLabClub/codelab_adapter_client_python/archive/master.zip 提供同步和异步两种基类: AdapterNode AdapterNodeAio","text_tokens":["基类","提供","安装",":","adapternodeaio","依赖","codelabclub","https","两种","同步","install","pip","zip"," ","和","archive","/","master","adapternode","com","python","_","github",".","codelab","adapter","异步","client"],"title":"Python Client","title_tokens":[" ","python","client"]},{"location":"user_guide/Linda/#adapternode","text":"from codelab_adapter_client import AdapterNode class MyNode ( AdapterNode ): NODE_ID = \"linda/test\" def __init__ ( self ): super () . __init__ () node = MyNode () node . receive_loop_as_thread () time . sleep ( 0.1 ) 创建Adapter Node之后，就可以通过node使用linda了。 res = node . linda_reboot () # reboot linda server, clean tuple space assert res == [] res = node . linda_out ([ 1 , 2 , 3 ]) # out assert res == [ 1 , 2 , 3 ] res = node . linda_out ([ 1 , 2 , 4 ]) # out res = node . linda_dump () assert res == [[ 1 , 2 , 3 ], [ 1 , 2 , 4 ]] res = node . linda_rd ([ 1 , 2 , 3 ]) # read and blocking assert res == [ 1 , 2 , 3 ] res = node . linda_rdp ([ 1 , 2 , \"*\" ]) # read but non-blocking assert res == [ 1 , 2 , 3 ] # 先入先出 res = node . linda_in ([ 1 , 2 , 3 ]) # read then remove (blocking) assert res == [ 1 , 2 , 3 ]","text_tokens":[",","non","-","*","(","tuple","可以","clean",":","receive","sleep","out","4","\"","loop","。","class","dump","reboot","assert","init","[","3","1","self","就","，","使用","in","=","node","之后","先入","#","blocking"," ","0.1",")","read","def","__","as","/","adapternode","from","_","import","]","linda","space","time","通过","then",".","server","mynode","codelab","rdp","remove","res","adapter","了","id","thread","2","rd","and","but","先出","super","client","test","创建"],"title":"AdapterNode","title_tokens":["adapternode"]},{"location":"user_guide/Linda/#adapternodeaio","text":"同步和异步 API 保持一致 import asyncio from codelab_adapter_client import AdapterNodeAio class MyNode ( AdapterNodeAio ): NODE_ID = \"linda/test\" def __init__ ( self ): super () . __init__ () # 以下代码在 jupyter 中运行，如果你想在python脚本中使用，请考虑异步代码的生命周期，参考: https://github.com/CodeLabClub/codelab_adapter_client_python/blob/master/tests/test_linda_client.py#L26 task = asyncio . create_task ( node . receive_loop ()) await asyncio . sleep ( 0.1 ) # !! 等待zmq通信管道建立完成 _tuple = [ \"test_linda\" ] # reboot res = await node . linda_reboot () assert res == [] # out _tuple = [ \"hello\" , \"world\" ] await node . linda_out ( _tuple ) # rdp res = await node . linda_rdp ( _tuple ) assert res == _tuple # inp res = await node . linda_inp ( _tuple ) assert res == _tuple res = await node . linda_dump () assert res == [] 更多用法参考测试文件: test_linda_client.py","text_tokens":[",","的","(","tuple","你","如果","zmq","周期","com","import","]","通信",".","测试","codelab","res","adapter","生命","py",":","在","https","\"","dump","self","tests","task","create","jupyter","参考","保持一致","文件","0.1","和",")","__","/","world","等待","python","from","_","中","想","考虑","rdp","id","blob","建立","!","用法","codelabclub","inp","reboot","assert","init","，","完成","hello","#","脚本","一致","运行","await","多","以下","请","github","mynode","super","api","client","异步","管道","out","adapternodeaio","receive","sleep","loop","同步","class","[","使用","=","node","更"," ","def","l26","master","代码","linda","保持","生命周期","asyncio","test"],"title":"AdapterNodeAio(异步)","title_tokens":["异步","adapternodeaio",")","("]},{"location":"user_guide/Linda/#scratch-client","text":"","text_tokens":[],"title":"Scratch Client","title_tokens":[" ","scratch","client"]},{"location":"user_guide/Linda/#rest-api","text":"使用 httpie 作为客户端。 := 表示后边跟的是 json 数据","text_tokens":["后边","的","使用","作为","客户端","=",":","表示","数据"," ","httpie","。","客户","json","是","跟"],"title":"REST API","title_tokens":["rest"," ","api"]},{"location":"user_guide/Linda/#out","text":"http post https://codelab-adapter.codelab.club:12358/api/linda operate=out tuple:='[\"hello\", \"linda\"]'","text_tokens":[",","-","tuple",":","post","https","\"","[","12358","=","hello","club"," ","operate","'","http","/","]","linda",".","codelab","adapter","api","out"],"title":"out","title_tokens":["out"]},{"location":"user_guide/Linda/#in","text":"http post https://codelab-adapter.codelab.club:12358/api/linda operate=in tuple:='[\"hello\", \"linda\"]'","text_tokens":[",","-","tuple",":","post","https","\"","[","12358","=","in","hello","club"," ","operate","'","http","/","]","linda",".","codelab","adapter","api"],"title":"in","title_tokens":["in"]},{"location":"user_guide/Linda/#dump","text":"http post https://codelab-adapter.codelab.club:12358/api/linda operate=dump 其他原语类似","text_tokens":["-",":","post","https","dump","原语","类似","12358","=","club"," ","operate","http","/","linda",".","codelab","adapter","其他","api"],"title":"dump","title_tokens":["dump"]},{"location":"user_guide/Linda/#cli","text":"pip install https://github.com/CodeLabClub/codelab_adapter_client_python/archive/master.zip # pip install codelab_adapter_client --upgrade # 暂未更新到 pypi codelab-linda --help codelab-linda out --help # reboot codelab-linda reboot # dump codelab-linda dump # out codelab-linda out --data '[1, \"hello\"]' # rd codelab-linda rd --data '[1, \"hello\"]' codelab-linda rd --data '[1, \"*\"]' # rdp codelab-linda rd --data '[1, 2, 3]' # [] # in codelab-linda rd --data '[1, \"*\"]'","text_tokens":[",","-","*",":","codelabclub","https","out","data","\"","install","dump","reboot","pip","[","1","3","暂未","zip","in","pypi","help","hello","#"," ","'","更新","archive","/","master","com","python","_","]","linda","到","github",".","rdp","codelab","adapter","2","rd","client","upgrade"],"title":"cli (命令行客户端)","title_tokens":["命令行","(","客户端","cli"," ","客户",")","命令"]},{"location":"user_guide/Linda/#javascript-client","text":"方便开发者，将 Linda 引入自己的web项目。 CodeLab 目前使用 JavaScript Client，将 Linda 带入 CodeLab Scratch、CodeLab Adapter WebUI 和 Lively。 import AdapterBaseClient from \"./codelab_adapter_base.js\" ; // https://github.com/CodeLabClub/scratch3_eim/blob/v3/codelab_adapter_base.js let NODE_ID = \"linda/js/client\" ; let HELP_URL = \"https://adapter.codelab.club/user_guide/Linda/\" ; let runtime = null ; let adapter_client = new AdapterBaseClient ( NODE_ID , HELP_URL , runtime ); await adapter_client . linda_out ([ 1 , 2 , 3 ]). then (( data )=>{ console . log ( \"linda\" , data ); return data }) tuple = await adapter_client . linda_in ([ \"hi\" , \"lively\" , \"*\" ]). then (( data )=>{ console . log ( \"linda\" , data ); return data }) tuple = await adapter_client . linda_in ([ \"hi\" , \"python\" , \"from Lively\" ]). then (( data )=>{ console . log ( \"linda\" , data ); return data }) tuple = await adapter_client . linda_in ([ \"hello\" , \"lively\" , \"*\" ]). then (( data )=>{ console . log ( \"linda\" , data ); return data }) await adapter_client . linda_in ([ 1 , 2 , 5 ], 1000 ). then (( data )=>{ console . log ( \"linda\" , data ); return data }) //超时","text_tokens":[",","的","带入","(","tuple","data","开发","超时","1","null",">","help","club","com","import","]","scratch","js",".","codelab","adapter","console",":","https","\"","hi","和",")","/","将","自己","python","from","_","guide","、","webui","lively","id","2","adapterbaseclient","blob","eim","runtime","*","}","codelabclub","let","。","3",";","，","web","v3","hello","scratch3","引入","await","then","github","1000","client","url","项目","{","out","开发者","方便","[","使用","log","in","=","node","new"," ","javascript","return","linda","user","base","5","目前"],"title":"JavaScript Client","title_tokens":[" ","javascript","client"]},{"location":"user_guide/Linda/#mush-lang","text":"LISP 是一种构建材料 -- Alan Kay 为了更好地探索 Linda 的可能性，我们围绕 Linda 的基本原语，构建了一门简单的语言 -- mush-lang 。 mush-lang 采用 LISP 风格的语法，可以视为 LISP 的一门玩具方言。 LISP 因其同构性(内外表示一致)，可能是所有语言中最简单的。 mush-lang 目前在 Python 中实现。","text_tokens":["的","-","mush","(","材料","表示","可能","可以","在","实现","为了","。","其","性","原语","探索","我们","简单","，","语言","风格","地","采用","一种","lang"," ","视为","最","基本","构建",")","一致","kay","alan","可能性","更好","python","玩具","方言","中","linda","是","因","了","lisp","一门","语法","同构","内外","所有","目前","围绕"],"title":"mush-lang","title_tokens":["lang","-","mush"]},{"location":"user_guide/Linda/#demo","text":"","text_tokens":[],"title":"Demo","title_tokens":["demo"]},{"location":"user_guide/Linda/#scratch","text":"在 Python 的例子中，我们甚至在Scratch里构建了 Server！ 两个Scratch角色同步的代码如下 linda-demo1 linda-demo2 python 与 Scratch 同步的代码如下: linda-demo1 Python核心部分代码为: node . linda_out ([ \"request\" , \"loudness\" , \"xxx\" ]) node . linda_in ([ \"response\" , \"loudness\" , \"*\" ])","text_tokens":[",","xxx","的","-","demo1","(","*","里","在",":","response","例子","\"","同步","两个","部分","[","我们","，","in","node"," ","构建","request",")","核心","与","代码","python","_","中","！","如下","linda","]","甚至","scratch","server","角色","为",".","loudness","了","demo2","out"],"title":"多个 Scratch 角色 的 实时同步","title_tokens":["角色","实时","的","多个"," ","同步","scratch"]},{"location":"user_guide/Linda/#jupyter-scratch","text":"跨语言对象之间的互操作 用到了 Jupyter notebook 里的 ipywidgets. # 请使用 jupyter notebook，而不是jupyterlab from ipywidgets import interact , interactive , fixed , interact_manual from codelab_adapter_client import AdapterNode import time class MyNode ( AdapterNode ): NODE_ID = \"linda/jupyter\" def __init__ ( self ): super () . __init__ () node = MyNode () node . receive_loop_as_thread () @interact ( show = True , x = 100 , size = 100 ) def f ( show , x , size ): node . linda_out ([ \" %% x\" , x ], wait = False ) # f函数是非阻塞的回调函数，使用wait=False参数，使node.linda_out使非阻塞的，此时相当于流，记得使用 message tuple（见下文） node . linda_out ([ \" %% show\" , show ], wait = False ) node . linda_out ([ \" %% size\" , size ], wait = False ) return show , x , size","text_tokens":[",","的","(","tuple","wait","相当于","相当","interact","f","（","之间","notebook","as","import","]",".","codelab","了","adapter","当于",":","下文","\"","manual","不是","self","@","语言","%%","jupyter","使非","interactive",")","回调","__","/","此时","from","_","false","id","thread","记得","函数","100","init","x","，","#","见下文","用到","message","jupyterlab","time","请","size","mynode","true","使","跨","而","super","参数","client","out","）","互操作","里","receive","loop","class","流","[","操作","使用","=","node","是非"," ","fixed","return","def","adapternode","linda","ipywidgets","阻塞","show","对象"],"title":"Jupyter 与 Scratch 的互操作","title_tokens":["操作","的","互操作","与","jupyter"," ","scratch"]},{"location":"user_guide/Linda/#_4","text":"","text_tokens":[],"title":"进阶","title_tokens":["进阶"]},{"location":"user_guide/Linda/#_5","text":"linda 的基本观点是数据不停生灭（由用户显式操控）。 如果我们想在 Linda 中实现 \"消息/流\" 的模式，可能会遇到tuple堆积（生产者太快）的问题（这是很严重的问题，似乎也不是正确使用linda的方式） 为了尽可能少地破坏概念完整性，我们引入了一种特殊的tuple来支持\"消息/流\"模式。 我们定义了一种叫做 message tuple 的 tuple，它像消息一样，每次只能流的瞬时截面: 一个数据 。 以下是几个message tuple的例子: (\"%%x\", 1) (\"%%y\", 50) (\"%%z\", \"hello\", \"world\") 在语法层面，message tuple只是普通的tuple，唯一区别是第一个元素需要是如下风格字符串， \"%%x\", x可以是任意值，可以把它看作message tuple的id，不同id的message tuple被视为不同tuple，支持tuple的所有操作符。 以下是一个例子: message_tuple demo 视角 站在变量的视角，你可以将其看作全局变量","text_tokens":[",","的","tuple","(","用户","可以","一个","为了","你","生产者","demo","其","如果","1","我们","（","地","概念","风格","数据","堆积","基本","问题","产者","看作","需要","模式","只是","截面","50","了","不停","一样","操作符","所有","会","区别","值","可能",":","在","实现","\"","不是","%%","一种","第一","视为","叫做","任意","被","尽可能",")","变量","普通","/","world","将","来","唯一","_","太快","中","想","z","正确","全局变量","id","瞬时","支持","方式","遇到","例子","视角","。","生产","x","也","，","元素","由","hello","不同","引入","第一个","定义","message","这","以下","特殊","操控","完整性","如下","把","y","尽可","很","似乎","语法","字符","）","观点","尽可能少","几个","字符串","像","流","显式","操作","破坏","使用","只能"," ","它","生灭","每次","站","完整","严重","linda","层面","是","消息","全局"],"title":"消息风格","title_tokens":["消息","风格"]},{"location":"user_guide/Linda/#faq","text":"","text_tokens":[],"title":"FAQ","title_tokens":["faq"]},{"location":"user_guide/Linda/#linda-tuple-space","text":"Adapter >=4.1.0","text_tokens":[".","adapter","=",">","4.1"," ","0"],"title":"如何看到 Linda Tuple Space","title_tokens":["tuple","看到","如何"," ","linda","space"]},{"location":"user_guide/Linda/#scratch-inrd","text":"简单而言，按照以下顺序运行程序: 确保在linda in/rd 积木运行之前，先运行linda reboot 之后在启动Scratch程序 以下是原因分析(可以不看): 这个Linda背后的实现有关，Adapter Linda 目前是C/S架构。Scratch中的 in/rd 积木实际上 promise。 reboot针对的是linda server的操作。 如果程序在 in/rd 的时候，被reboot，则客户端(Scratch)的 in/rd 对应的promise永远不会被解决。 linda reboot 一下","text_tokens":["架构","的","(","可以",":","在","程序","实现","时候","针对","原因","。","之前","而言","reboot","s","如果","分析","操作","简单","，","积木","in","实际","之后","客户端","不会","一下"," ","确保","被","客户",")","先","顺序","实际上","/","运行","这个","按照","以下","中","linda","c","永远","是","scratch","对应","server","启动","promise","解决","adapter","有关","rd","背后","则","不看","目前"],"title":"在 Scratch 里有些 in/rd 积木一直阻塞","title_tokens":["/","积木","in","阻塞","里","在","rd","一直"," ","有些","scratch"]},{"location":"user_guide/Linda/#_6","text":"<!-- ZMQ_LOOP_TIME 以下是一个在scratch里进行速率测试的demo linda-rate → 默认情况下，30帧/s。 在Python客户端，通过修改参数，可以提高到300-600帧/s。 class MyNode ( AdapterNode ): NODE_ID = \"linda/test\" def __init__ ( self ): super () . __init__ ( recv_mode = \"block\" , bucket_fill_rate = 1000 , bucket_token = 1000 )","text_tokens":[",","!","的","-","(","可以","一个","里","在",":","<","demo","loop","。","class","\"","s","mode","init","self","，","客户端","=","node","token","zmq","速率"," ","情况","30","客户",")","def","__","/","adapternode","fill","python","_","以下","修改","linda","→","提高","time","是","scratch","到","通过","测试",".","rate","300","mynode","block","1000","bucket","recv","id","默认","super","600","帧","参数","下","进行","test"],"title":"速度","title_tokens":["速度"]},{"location":"user_guide/Linda/#linda-eim","text":"Linda 与 EIM 将长期共存，一个 Adapter Node，即是Linda client，也是EIM client，它们各有所擅。长期来看，我们更偏好 Linda。","text_tokens":["它们","一个","有所","。","也","我们","，","更","node"," ","长期共存","共存","将","与","linda","是","来看","长期","adapter","即","偏好","擅","各","eim","client"],"title":"Linda 与 EIM","title_tokens":["eim"," ","与","linda"]},{"location":"user_guide/Linda/#_7","text":"在 CodeLab Adapter 中实现 Linda 并发模型 Linda: 比 Actor 更好的并发模型 [译]Alan Kay 看待'对象'的几次观点转变 建立在异步消息之上的同步指令: 分别在 JavaScript、Python、Squeak 上实现 [译]Smalltalk 背后的设计原则","text_tokens":["观点","的",":","在","实现","上","指令","同步","并发","[","比","smalltalk"," ","javascript","之上","'","kay","原则","alan","看待","更好","squeak","python","中","模型","linda","]","设计","转变","译","codelab","、","分别","几次","adapter","消息","背后","对象","异步","actor","建立"],"title":"参考","title_tokens":["参考"]},{"location":"user_guide/advanced/","text":"进阶（advanced） ¶ 通过 extension_eim_trigger 和 extension_eim_monitor 插件， Scratcher 可以轻松使用 Python 拓展 Scratch 的能力。 eim trigger ：使用 Python 往 Scratch 中发送消息。 eim monitor ：使用 Python 处理来自 Scratch 的消息。","text_tokens":["的","可以","处理","。","：","scratcher","插件","使用","，","来自","（","extension"," ","trigger","和","advanced","往","python","_","中","scratch","monitor","通过","拓展","¶","消息","轻松","进阶","eim","能力","发送","）"],"title":"进阶(advanced)","title_tokens":["advanced",")","进阶","("]},{"location":"user_guide/advanced/#advanced","text":"通过 extension_eim_trigger 和 extension_eim_monitor 插件， Scratcher 可以轻松使用 Python 拓展 Scratch 的能力。 eim trigger ：使用 Python 往 Scratch 中发送消息。 eim monitor ：使用 Python 处理来自 Scratch 的消息。","text_tokens":["的","可以","处理","。","：","scratcher","插件","使用","，","来自","extension"," ","trigger","和","往","python","_","中","scratch","拓展","monitor","通过","消息","轻松","能力","eim","发送"],"title":"进阶（advanced）","title_tokens":["advanced","（","进阶","）"]},{"location":"user_guide/develop/","text":"测试版 ¶","text_tokens":["测试版","测试","¶"," "],"title":"测试版","title_tokens":["测试版","测试"]},{"location":"user_guide/develop/#_1","text":"","text_tokens":[],"title":"测试版","title_tokens":["测试版","测试"]},{"location":"user_guide/gallery-bak/","text":"演示视频（Gallery） ¶ Notice If you can't read Chinese, Please use Google Translate. 读书与思考 ¶ 收工，吃饭 ¶ 击灭那盏灯 ¶ 小房间与大房间（labo 套件） ¶ 姿势乐谱 ¶ 冲啊，先驱音速 ¶ hungry robot ¶ 巴甫洛夫的机器人 ¶ 击掌奏乐 ¶ Leap Motion 超级玛丽 ¶ 在 CodeLab Scratch3 中，无线控制 bit:bot ¶ 在 CodeLab Scratch3 中，使用 micro:bit 开/关灯 ¶ 参考 积木化编程与智能家居 。 在 CodeLab Scratch3 中，利用运动检测开/关灯 ¶ 在 CodeLab Scratch3 中，利用传感器做体感游戏 ¶ 参考 积木化编程与智能家居 。 在 CodeLab Scratch3 中，使用本地的机器视觉 ¶ 使用手势控制客厅的灯 ¶ 我们布置好了一个可编程的空间，使用 Scratch3 中的积木进行空间编程，控制室内的灯光、插座、空调、电视，如果你愿意，也可以去淘宝买一根哈利波特的木制魔杖（估计只要九块九），用我们提供的机器视觉积木训练一下，就可以用你自制的咒语（比如用魔杖划一个o）控制你的房间 参考 积木化编程与智能家居 。 门与电视的联动 ¶ 我们使用树莓派可将任何屏幕变为变为一个可编程的广告牌（哈哈只要 200 块哦，这块似乎也值得商业化[奸笑]）。加上简单的神经网络你可以做到，当穿着裙子的姑娘走近屏幕，屏幕立马给她安利新款纪梵希，而穿着格子衬衫的大叔靠近时，屏幕则以机械键盘蛊惑他。 参考 积木化编程与智能家居 。 纸做的开关 ¶ 参考 积木化编程与智能家居 。 Cozmo 接入在线课程平台 ¶ 参考 使用 Codelab_Adapter 连接 blockly 与硬件 。 Incendio（火焰咒） ¶ 控制优必选 Alpha 系列机器人 ¶ 参考 codelab-adapter 接入优必选 Alpha 系列机器人 接入 blender（连接游戏、电影与 VR） ¶ 做一个微信聊天界面 ¶ 要有光（微信 Scratch 物联网） ¶ 人脸地标（Python 程序接入 Scratch） ¶ 鼻梁上的老花镜（增强现实） ¶ hi-渡边君（chatbot） ¶ 智能音箱 ¶ 掌控板（reverse shell） ¶ unity、lego、scratch3-adapter（by 联想研究院） ¶ 四轴飞行器 ¶ oh my vector ¶ 模拟器（by 联想研究院） ¶ 眼动仪 ¶ Switch Labo ❤️ Vector ¶ Candy Language for Vector ¶ 接入 Arduino ¶ Physics extension and Leap Motion ¶ wechat extension ¶ Cozmo and Vector: Where did the human go? ¶ 渡边君（cozmo+vector） ¶ 灵光一现（脑电波＋智能家居） ¶ DJI Tello x Leap Motion ¶ DJI Tello x Switch Labo ¶ DJI Tello x Switch Joy-Con ¶ 霍格沃兹模式 ¶ CodeLab ❤️ Toio ¶ 给我一个 Toio，我可以转动地球 ¶ 在你转身之后，岁月无光 ¶ 天空没有留下鸟的痕迹，但 Toio 已飞过 ¶ 接入 3D 游戏 ¶ 山寨版龟派气功 ¶ CodeLab x leju robot ¶ 手势窗帘 ¶ 体验者初次学会适应变量 ¶ Toio etoys ¶ 魔法教室 ¶ 灰袍巫师 ¶ Scratch x 微信 x IoT ¶ Jupyter ＋ Scratch ¶ 谁动了我的糖果 ¶ Toio music interface ¶ Toio music interface2 ¶ I am reading (Python) ¶ cube symphony ¶ 自制门禁系统 ¶ CodeLab 有嘻哈 ¶ 目之所及 ¶ 兼容 iPad ¶ 可穿戴设备 & 魔杖 ¶ Fire! ¶ Inspired by DynamicLand ¶ 命运之手 ¶ 重力效应 ¶ 拍案惊球 ¶ Body Programming ¶ 二进制 ¶ 蜡笔调色盘 ¶ 一场烟火 ¶ Toio 泡泡龙 ¶ Seeing Spaces ¶ COVID-19 ¶ Dynamic Table ¶ 小型解释器 ¶ spelling ¶ 皮卡与皮卡丘 ¶ 如何画一只会跑的独角兽🦄️ ¶ 42 (DynamicTable4Math) ¶ 动画原理 ¶ 纸糊方向盘 ¶ 震动检测器 ¶ 生日贺卡 ¶ CodeLab Adapter ❤️ Teachable Machine ¶ Kano Wand ¶ 闪现 ¶ 积木消失了 ¶ \"RoboMaster EP\" ¶ Minecraft ¶ Sonic Pi ¶ Yanshee ¶ Hey Siri ¶ RoboMaster && Motion Sensor ¶ GameShell ¶","text_tokens":[",","走近","的","please","划","一个","解释","广告牌","上","toio","家居","比如","做","击掌","yanshee","dynamic","scratch","can","模式","独角兽","兼容","那","incendio","-","格子","在","机器人","covid","方向","cozmo","神经网络","微信","extension","pi","她","估计","网络","任何","研究院","鸟","dynamictable4math","游戏","physics","当","淘宝","arduino","!","感器","leju","运动","o","超级","关灯","iot","感","气功","神经网","魔法","¶","似乎","inspired","而","已","哦","愿意","联想研究院","纪梵希","这块","无","minecraft","衬衫","只要"," ","巫师","老花","但","❤","泡泡","一根","you","房间","if","19","奏乐","智能家居","by","套件","要有光","飞行","开关","光","shell","洛夫","跑","利用","商业","简单","眼动仪","化","他","read","客厅","设备","use","]","spaces","有嘻哈","t",".","where","for","and","reverse","+","机器","新款","脑电波","3d","买","物","二进制","天空","命运","硬件","hi","派","i",")","灰袍","增强","板","飞行器","检测","传感","裙子","传感器","演示","、","奸笑","糖果","好","。","sensor","加上","收工","scratch3","dji","姿势","motion","did","烟火","switch","🦄","拍案","消失","解释器","训练","）","靠近","无线","提供","robomaster","自制","程序","[","模拟器","进制","哈哈","哈利波","四轴","安利","思考","与","谁动","姑娘","神经","robot","cube","商业化","table","控制","机械","gameshell","必选","(","go","可以","wand","窗帘","google","花镜","如果","我","音速","hey","symphony","bit","＋","用","留下","门禁系统","纸糊","blender","人脸","&&","键盘","tello","效应","siri","咒语","machine","灵光","接入","地球","一现",":","哈利","目之所及","广告","没有","山寨","programming","wechat","alpha","200","之后","君","fire","参考","vector","开","变量","震动","/","电波","将","python","_","中","乐谱","一场","?","九块","电视","联想","优","con","x","给","格沃兹","视觉","室内","可编程","系列","检测器","巴甫洛夫","立马","unity","霍","系统","music","空调","体验","spelling","盏灯","在线","进行","独角","学会","界面","做体","dynamicland","老花镜","调色","积木","聊天","者","lego","泡泡龙","视频","编程","joy","做到","掌控","研究","human","皮卡","大叔","鼻梁","原理","时","渡边","你","大","冲","巴甫洛","我们","就","灯光","课程","超级玛丽","（","九","'","痕迹","初次","击灭","平台","教室","去","小房","codelab","了","adapter","皮卡丘","reading","以","插座","translate","会","值得","所及","hungry","本地","地标","\"","穿戴","手势","岁月","生日","变为","测器","版龟","释器","一下","jupyter","灯","画","飞过","玛丽","重力","转身","方向盘","42","interface","小房间","块","bot","联网","火焰","如何","读书","micro","ep","音箱","动画","也","树莓","，","现实","蛊惑","连接","特","可","blockly","调色盘","模拟","蜡笔","先驱","kano","chinese","转动","interface2","小型","一只","穿着","则","am","空间","vr","body","️","之手","魔杖","&","智能","leap","咒","teachable","使用","seeing","联动","candy","language","门禁","纸","闪现","适应","屏幕","电影","啊","gallery","etoys","可编","the","惊球","布置","贺卡","木制","my","ipad","sonic","chatbot","labo","门","notice","oh","吃饭"],"title":"演示视频（Gallery）","title_tokens":["演示","）","gallery","（","视频"]},{"location":"user_guide/gallery-bak/#gallery","text":"Notice If you can't read Chinese, Please use Google Translate.","text_tokens":["if","t","chinese",",",".","please","use","notice"," ","you","google","translate","'","read","can"],"title":"演示视频（Gallery）","title_tokens":["演示","）","gallery","（","视频"]},{"location":"user_guide/gallery-bak/#_1","text":"","text_tokens":[],"title":"读书与思考","title_tokens":["与","读书","思考"]},{"location":"user_guide/gallery-bak/#_2","text":"","text_tokens":[],"title":"收工，吃饭","title_tokens":["吃饭","收工","，"]},{"location":"user_guide/gallery-bak/#_3","text":"","text_tokens":[],"title":"击灭那盏灯","title_tokens":["击灭","盏灯","那"]},{"location":"user_guide/gallery-bak/#labo","text":"","text_tokens":[],"title":"小房间与大房间（labo 套件）","title_tokens":["小房","大","labo","与","（"," ","套件","小房间","）","房间"]},{"location":"user_guide/gallery-bak/#_4","text":"","text_tokens":[],"title":"姿势乐谱","title_tokens":["乐谱","姿势"]},{"location":"user_guide/gallery-bak/#_5","text":"","text_tokens":[],"title":"冲啊，先驱音速","title_tokens":["音速","，","啊","先驱","冲"]},{"location":"user_guide/gallery-bak/#hungry-robot","text":"","text_tokens":[],"title":"hungry robot","title_tokens":["robot"," ","hungry"]},{"location":"user_guide/gallery-bak/#_6","text":"","text_tokens":[],"title":"巴甫洛夫的机器人","title_tokens":["巴甫洛","的","机器人","巴甫洛夫","机器","洛夫"]},{"location":"user_guide/gallery-bak/#_7","text":"","text_tokens":[],"title":"击掌奏乐","title_tokens":["击掌","奏乐"]},{"location":"user_guide/gallery-bak/#leap-motion","text":"","text_tokens":[],"title":"Leap Motion 超级玛丽","title_tokens":["超级","超级玛丽","玛丽"," ","leap","motion"]},{"location":"user_guide/gallery-bak/#codelab-scratch3-bitbot","text":"","text_tokens":[],"title":"在 CodeLab Scratch3 中，无线控制 bit:bot","title_tokens":["codelab","，",":","在","scratch3"," ","中","bit","控制","无线","bot"]},{"location":"user_guide/gallery-bak/#codelab-scratch3-microbit","text":"参考 积木化编程与智能家居 。","text_tokens":["积木","化","与","参考","智能家居"," ","家居","智能","。","编程"],"title":"在 CodeLab Scratch3 中，使用 micro:bit 开/关灯","title_tokens":["codelab","使用","，","/","关灯",":","在","scratch3"," ","中","micro","开","bit"]},{"location":"user_guide/gallery-bak/#codelab-scratch3","text":"","text_tokens":[],"title":"在 CodeLab Scratch3 中，利用运动检测开/关灯","title_tokens":["codelab","利用","，","/","关灯","在","scratch3"," ","中","检测","开","运动"]},{"location":"user_guide/gallery-bak/#codelab-scratch3_1","text":"参考 积木化编程与智能家居 。","text_tokens":["积木","化","与","参考","智能家居"," ","家居","智能","。","编程"],"title":"在 CodeLab Scratch3 中，利用传感器做体感游戏","title_tokens":["感器","codelab","利用","，","游戏","感","在","做体","scratch3"," ","中","传感","传感器"]},{"location":"user_guide/gallery-bak/#codelab-scratch3_2","text":"","text_tokens":[],"title":"在 CodeLab Scratch3 中，使用本地的机器视觉","title_tokens":["的","codelab","使用","，","本地","视觉","在","scratch3"," ","中","机器"]},{"location":"user_guide/gallery-bak/#_8","text":"我们布置好了一个可编程的空间，使用 Scratch3 中的积木进行空间编程，控制室内的灯光、插座、空调、电视，如果你愿意，也可以去淘宝买一根哈利波特的木制魔杖（估计只要九块九），用我们提供的机器视觉积木训练一下，就可以用你自制的咒语（比如用魔杖划一个o）控制你的房间 参考 积木化编程与智能家居 。","text_tokens":["化","的","提供","买","九块","电视","一个","愿意","可以","哈利","魔杖","自制","划","你","好","智能","。","如果","o","我们","也","使用","，","积木","室内","灯光","淘宝","（","视觉","可编程","只要","scratch3","一下","哈利波"," ","九","就","比如","参考","特","家居","用","编程","估计","与","一根","可编","中","布置","房间","空调","木制","去","、","了","空间","训练","咒语","智能家居","机器","插座","进行","）","控制"],"title":"使用手势控制客厅的灯","title_tokens":["的","使用","客厅","灯","控制","手势"]},{"location":"user_guide/gallery-bak/#_9","text":"我们使用树莓派可将任何屏幕变为变为一个可编程的广告牌（哈哈只要 200 块哦，这块似乎也值得商业化[奸笑]）。加上简单的神经网络你可以做到，当穿着裙子的姑娘走近屏幕，屏幕立马给她安利新款纪梵希，而穿着格子衬衫的大叔靠近时，屏幕则以机械键盘蛊惑他。 参考 积木化编程与智能家居 。","text_tokens":["化","走近","的","时","可以","一个","简单","给","格子","广告牌","衬衫","你","纪梵希","广告","这块","机械","。","智能","[","加上","我们","树莓","使用","变为","，","也","200","（","哈哈","商业","可编程","只要","蛊惑","派","立马"," ","他","参考","安利","家居","她","可","编程","屏幕","网络","任何","将","与","做到","可编","姑娘","]","裙子","神经","神经网","值得","奸笑","键盘","似乎","商业化","而","大叔","穿着","智能家居","则","神经网络","当","新款","以","积木","）","靠近","块","哦"],"title":"门与电视的联动","title_tokens":["的","电视","与","门","联动"]},{"location":"user_guide/gallery-bak/#_10","text":"参考 积木化编程与智能家居 。","text_tokens":["积木","化","与","参考","智能家居"," ","家居","智能","。","编程"],"title":"纸做的开关","title_tokens":["的","纸","做","开关"]},{"location":"user_guide/gallery-bak/#cozmo","text":"参考 使用 Codelab_Adapter 连接 blockly 与硬件 。","text_tokens":["codelab","使用","blockly","adapter","硬件","与","_","参考"," ","连接","。"],"title":"Cozmo 接入在线课程平台","title_tokens":["课程","在线"," ","cozmo","接入","平台"]},{"location":"user_guide/gallery-bak/#incendio","text":"","text_tokens":[],"title":"Incendio（火焰咒）","title_tokens":["咒","（","火焰","incendio","）"]},{"location":"user_guide/gallery-bak/#alpha","text":"参考 codelab-adapter 接入优必选 Alpha 系列机器人","text_tokens":["优","必选","-","codelab","adapter","alpha","机器人","系列","参考"," ","机器","接入"],"title":"控制优必选 Alpha 系列机器人","title_tokens":["优","必选","alpha","机器人","系列"," ","机器","控制"]},{"location":"user_guide/gallery-bak/#blender-vr","text":"","text_tokens":[],"title":"接入 blender（连接游戏、电影与 VR）","title_tokens":["vr","电影","、","游戏","（","与","blender"," ","连接","接入","）"]},{"location":"user_guide/gallery-bak/#_11","text":"","text_tokens":[],"title":"做一个微信聊天界面","title_tokens":["微信","一个","界面","聊天","做"]},{"location":"user_guide/gallery-bak/#scratch","text":"","text_tokens":[],"title":"要有光（微信 Scratch 物联网）","title_tokens":["联网","微信","（","scratch","物"," ","）","要有光"]},{"location":"user_guide/gallery-bak/#python-scratch","text":"","text_tokens":[],"title":"人脸地标（Python 程序接入 Scratch）","title_tokens":["地标","（","程序","python"," ","接入","）","scratch","人脸"]},{"location":"user_guide/gallery-bak/#_12","text":"","text_tokens":[],"title":"鼻梁上的老花镜（增强现实）","title_tokens":["的","增强","现实","（","上","鼻梁","）","老花","花镜","老花镜"]},{"location":"user_guide/gallery-bak/#hi-chatbot","text":"","text_tokens":[],"title":"hi-渡边君（chatbot）","title_tokens":["-","渡边","chatbot","（","君","hi","）"]},{"location":"user_guide/gallery-bak/#_13","text":"","text_tokens":[],"title":"智能音箱","title_tokens":["音箱","智能"]},{"location":"user_guide/gallery-bak/#reverse-shell","text":"","text_tokens":[],"title":"掌控板（reverse shell）","title_tokens":["板","（","shell","reverse","掌控"," ","）"]},{"location":"user_guide/gallery-bak/#unitylegoscratch3-adapterby","text":"","text_tokens":[],"title":"unity、lego、scratch3-adapter（by 联想研究院）","title_tokens":["-","、","adapter","联想","（","研究院","scratch3","联想研究院"," ","研究","by","lego","）","unity"]},{"location":"user_guide/gallery-bak/#_14","text":"","text_tokens":[],"title":"四轴飞行器","title_tokens":["飞行","飞行器","四轴"]},{"location":"user_guide/gallery-bak/#oh-my-vector","text":"","text_tokens":[],"title":"oh my vector","title_tokens":["oh"," ","vector","my"]},{"location":"user_guide/gallery-bak/#by","text":"","text_tokens":[],"title":"模拟器（by 联想研究院）","title_tokens":["模拟器","联想","（","研究院","模拟","联想研究院"," ","研究","by","）"]},{"location":"user_guide/gallery-bak/#_15","text":"","text_tokens":[],"title":"眼动仪","title_tokens":["眼动仪"]},{"location":"user_guide/gallery-bak/#switch-labo-vector","text":"","text_tokens":[],"title":"Switch Labo ❤️ Vector","title_tokens":["❤","switch","labo","️"," ","vector"]},{"location":"user_guide/gallery-bak/#candy-language-for-vector","text":"","text_tokens":[],"title":"Candy Language for Vector","title_tokens":["for","candy","vector"," ","language"]},{"location":"user_guide/gallery-bak/#arduino","text":"","text_tokens":[],"title":"接入 Arduino","title_tokens":["接入"," ","arduino"]},{"location":"user_guide/gallery-bak/#physics-extension-and-leap-motion","text":"","text_tokens":[],"title":"Physics extension and Leap Motion","title_tokens":["and","extension","physics"," ","leap","motion"]},{"location":"user_guide/gallery-bak/#wechat-extension","text":"","text_tokens":[],"title":"wechat extension","title_tokens":[" ","extension","wechat"]},{"location":"user_guide/gallery-bak/#cozmo-and-vector-where-did-the-human-go","text":"","text_tokens":[],"title":"Cozmo and Vector: Where did the human go?","title_tokens":["human","where","and","go",":","?"," ","vector","the","did","cozmo"]},{"location":"user_guide/gallery-bak/#cozmovector","text":"","text_tokens":[],"title":"渡边君（cozmo+vector）","title_tokens":["渡边","（","君","+","vector","cozmo","）"]},{"location":"user_guide/gallery-bak/#_16","text":"","text_tokens":[],"title":"灵光一现（脑电波＋智能家居）","title_tokens":["一现","电波","（","＋","智能家居","家居","智能","灵光","）","脑电波"]},{"location":"user_guide/gallery-bak/#dji-tello-x-leap-motion","text":"","text_tokens":[],"title":"DJI Tello x Leap Motion","title_tokens":["x","tello"," ","dji","leap","motion"]},{"location":"user_guide/gallery-bak/#dji-tello-x-switch-labo","text":"","text_tokens":[],"title":"DJI Tello x Switch Labo","title_tokens":["x","switch","labo","tello"," ","dji"]},{"location":"user_guide/gallery-bak/#dji-tello-x-switch-joy-con","text":"","text_tokens":[],"title":"DJI Tello x Switch Joy-Con","title_tokens":["con","x","switch","-","joy","tello"," ","dji"]},{"location":"user_guide/gallery-bak/#_17","text":"","text_tokens":[],"title":"霍格沃兹模式","title_tokens":["格沃兹","模式","霍"]},{"location":"user_guide/gallery-bak/#codelab-toio","text":"","text_tokens":[],"title":"CodeLab ❤️ Toio","title_tokens":["❤","codelab","️","toio"," "]},{"location":"user_guide/gallery-bak/#toio","text":"","text_tokens":[],"title":"给我一个 Toio，我可以转动地球","title_tokens":["给","，","转动","可以","一个","toio"," ","地球","我"]},{"location":"user_guide/gallery-bak/#_18","text":"","text_tokens":[],"title":"在你转身之后，岁月无光","title_tokens":["，","光","之后","在","转身","你","无","岁月"]},{"location":"user_guide/gallery-bak/#toio_1","text":"","text_tokens":[],"title":"天空没有留下鸟的痕迹，但 Toio 已飞过","title_tokens":["天空","的","，","飞过","toio","已"," ","痕迹","没有","鸟","留下","但"]},{"location":"user_guide/gallery-bak/#3d","text":"","text_tokens":[],"title":"接入 3D 游戏","title_tokens":["接入"," ","3d","游戏"]},{"location":"user_guide/gallery-bak/#_19","text":"","text_tokens":[],"title":"山寨版龟派气功","title_tokens":["派","版龟","气功","山寨"]},{"location":"user_guide/gallery-bak/#codelab-x-leju-robot","text":"","text_tokens":[],"title":"CodeLab x leju robot","title_tokens":["x","robot","codelab","leju"," "]},{"location":"user_guide/gallery-bak/#_20","text":"","text_tokens":[],"title":"手势窗帘","title_tokens":["手势","窗帘"]},{"location":"user_guide/gallery-bak/#_21","text":"","text_tokens":[],"title":"体验者初次学会适应变量","title_tokens":["体验","学会","者","初次","变量","适应"]},{"location":"user_guide/gallery-bak/#toio-etoys","text":"","text_tokens":[],"title":"Toio etoys","title_tokens":["etoys"," ","toio"]},{"location":"user_guide/gallery-bak/#_22","text":"","text_tokens":[],"title":"魔法教室","title_tokens":["魔法","教室"]},{"location":"user_guide/gallery-bak/#_23","text":"","text_tokens":[],"title":"灰袍巫师","title_tokens":["灰袍","巫师"]},{"location":"user_guide/gallery-bak/#scratch-x-x-iot","text":"","text_tokens":[],"title":"Scratch x 微信 x IoT","title_tokens":["x","iot","微信"," ","scratch"]},{"location":"user_guide/gallery-bak/#jupyter-scratch","text":"","text_tokens":[],"title":"Jupyter ＋ Scratch","title_tokens":["jupyter"," ","＋","scratch"]},{"location":"user_guide/gallery-bak/#_24","text":"","text_tokens":[],"title":"谁动了我的糖果","title_tokens":["的","了","谁动","糖果","我"]},{"location":"user_guide/gallery-bak/#toio-music-interface","text":"","text_tokens":[],"title":"Toio music interface","title_tokens":["interface"," ","music","toio"]},{"location":"user_guide/gallery-bak/#toio-music-interface2","text":"","text_tokens":[],"title":"Toio music interface2","title_tokens":[" ","music","toio","interface2"]},{"location":"user_guide/gallery-bak/#i-am-reading-python","text":"","text_tokens":[],"title":"I am reading (Python)","title_tokens":["(","reading","python"," ","am","i",")"]},{"location":"user_guide/gallery-bak/#cube-symphony","text":"","text_tokens":[],"title":"cube symphony","title_tokens":["symphony","cube"," "]},{"location":"user_guide/gallery-bak/#_25","text":"","text_tokens":[],"title":"自制门禁系统","title_tokens":["门禁","门禁系统","自制","系统"]},{"location":"user_guide/gallery-bak/#codelab","text":"","text_tokens":[],"title":"CodeLab 有嘻哈","title_tokens":["有嘻哈"," ","codelab"]},{"location":"user_guide/gallery-bak/#_26","text":"","text_tokens":[],"title":"目之所及","title_tokens":["目之所及","所及"]},{"location":"user_guide/gallery-bak/#ipad","text":"","text_tokens":[],"title":"兼容 iPad","title_tokens":[" ","兼容","ipad"]},{"location":"user_guide/gallery-bak/#_27","text":"","text_tokens":[],"title":"可穿戴设备 &amp; 魔杖","title_tokens":[";","设备","魔杖","&"," ","穿戴","可","amp"]},{"location":"user_guide/gallery-bak/#fire","text":"","text_tokens":[],"title":"Fire!","title_tokens":["!","fire"]},{"location":"user_guide/gallery-bak/#inspired-by-dynamicland","text":"","text_tokens":[],"title":"Inspired by DynamicLand","title_tokens":[" ","inspired","dynamicland","by"]},{"location":"user_guide/gallery-bak/#_28","text":"","text_tokens":[],"title":"命运之手","title_tokens":["命运","之手"]},{"location":"user_guide/gallery-bak/#_29","text":"","text_tokens":[],"title":"重力效应","title_tokens":["重力","效应"]},{"location":"user_guide/gallery-bak/#_30","text":"","text_tokens":[],"title":"拍案惊球","title_tokens":["惊球","拍案"]},{"location":"user_guide/gallery-bak/#body-programming","text":"","text_tokens":[],"title":"Body Programming","title_tokens":["programming","body"," "]},{"location":"user_guide/gallery-bak/#_31","text":"","text_tokens":[],"title":"二进制","title_tokens":["二进制","进制"]},{"location":"user_guide/gallery-bak/#_32","text":"","text_tokens":[],"title":"蜡笔调色盘","title_tokens":["调色盘","蜡笔","调色"]},{"location":"user_guide/gallery-bak/#_33","text":"","text_tokens":[],"title":"一场烟火","title_tokens":["一场","烟火"]},{"location":"user_guide/gallery-bak/#toio_2","text":"","text_tokens":[],"title":"Toio 泡泡龙","title_tokens":["泡泡","泡泡龙"," ","toio"]},{"location":"user_guide/gallery-bak/#seeing-spaces","text":"","text_tokens":[],"title":"Seeing Spaces","title_tokens":[" ","seeing","spaces"]},{"location":"user_guide/gallery-bak/#covid-19","text":"","text_tokens":[],"title":"COVID-19","title_tokens":["19","-","covid"]},{"location":"user_guide/gallery-bak/#dynamic-table","text":"","text_tokens":[],"title":"Dynamic Table","title_tokens":["dynamic"," ","table"]},{"location":"user_guide/gallery-bak/#_34","text":"","text_tokens":[],"title":"小型解释器","title_tokens":["释器","小型","解释","解释器"]},{"location":"user_guide/gallery-bak/#spelling","text":"","text_tokens":[],"title":"spelling","title_tokens":["spelling"]},{"location":"user_guide/gallery-bak/#_35","text":"","text_tokens":[],"title":"皮卡与皮卡丘","title_tokens":["与","皮卡","皮卡丘"]},{"location":"user_guide/gallery-bak/#_36","text":"","text_tokens":[],"title":"如何画一只会跑的独角兽🦄️","title_tokens":["画","独角兽","的","🦄","️","一只","如何","会","独角","跑"]},{"location":"user_guide/gallery-bak/#42-dynamictable4math","text":"","text_tokens":[],"title":"42 (DynamicTable4Math)","title_tokens":["dynamictable4math","("," ","42",")"]},{"location":"user_guide/gallery-bak/#_37","text":"","text_tokens":[],"title":"动画原理","title_tokens":["动画","原理"]},{"location":"user_guide/gallery-bak/#_38","text":"","text_tokens":[],"title":"纸糊方向盘","title_tokens":["方向","方向盘","纸糊"]},{"location":"user_guide/gallery-bak/#_39","text":"","text_tokens":[],"title":"震动检测器","title_tokens":["检测器","测器","震动","检测"]},{"location":"user_guide/gallery-bak/#_40","text":"","text_tokens":[],"title":"生日贺卡","title_tokens":["贺卡","生日"]},{"location":"user_guide/gallery-bak/#codelab-adapter-teachable-machine","text":"","text_tokens":[],"title":"CodeLab Adapter ❤️ Teachable Machine","title_tokens":["❤","teachable","codelab","adapter","️"," ","machine"]},{"location":"user_guide/gallery-bak/#kano-wand","text":"","text_tokens":[],"title":"Kano Wand","title_tokens":[" ","wand","kano"]},{"location":"user_guide/gallery-bak/#_41","text":"","text_tokens":[],"title":"闪现","title_tokens":["闪现"]},{"location":"user_guide/gallery-bak/#_42","text":"","text_tokens":[],"title":"积木消失了","title_tokens":["积木","消失","了"]},{"location":"user_guide/gallery-bak/#robomaster-ep","text":"","text_tokens":[],"title":"\"RoboMaster EP\"","title_tokens":["robomaster","ep"," ","\""]},{"location":"user_guide/gallery-bak/#minecraft","text":"","text_tokens":[],"title":"Minecraft","title_tokens":["minecraft"]},{"location":"user_guide/gallery-bak/#sonic-pi","text":"","text_tokens":[],"title":"Sonic Pi","title_tokens":["sonic"," ","pi"]},{"location":"user_guide/gallery-bak/#yanshee","text":"","text_tokens":[],"title":"Yanshee","title_tokens":["yanshee"]},{"location":"user_guide/gallery-bak/#hey-siri","text":"","text_tokens":[],"title":"Hey Siri","title_tokens":[" ","siri","hey"]},{"location":"user_guide/gallery-bak/#robomaster-motion-sensor","text":"","text_tokens":[],"title":"RoboMaster &amp;&amp; Motion Sensor","title_tokens":["sensor",";","robomaster","&"," ","motion","amp"]},{"location":"user_guide/gallery-bak/#gameshell","text":"","text_tokens":[],"title":"GameShell","title_tokens":["gameshell"]},{"location":"user_guide/gallery/","text":"演示视频（Gallery） ¶ 请点击 玩给你看","text_tokens":["看","演示","）","玩","给","gallery","¶","（","你"," ","点击","视频","请"],"title":"展示视频(gallery)","title_tokens":["展示","(","gallery","视频",")"]},{"location":"user_guide/gallery/#gallery","text":"请点击 玩给你看","text_tokens":["看","玩","给","你"," ","点击","请"],"title":"演示视频（Gallery）","title_tokens":["演示","）","gallery","（","视频"]},{"location":"user_guide/install/","text":"安装（install）","text_tokens":["安装","install","（","）"],"title":"Install","title_tokens":["install"]},{"location":"user_guide/settings/","text":"配置文件 ¶ CodeLab Adapter 允许用户的自定义配置。配置文件位于: ~/codelab_adapter/user_settings.py 。 支持使用环境变量覆盖这些配置项，诸如 AUTO_OPEN_WEBUI=false codelab-adapter 以下是一些常见配置项： ADAPTER_MODE ¶ 有三种模式： NORMAL, 普通用户模式，CodeLab Adapter 作为客户端程序，增强 Scratch，支持自定义插件……关注易用性与安全性。 DEV（开发）模式，关注灵活性，同时也带来安全风险。 NEVERLAND_HUB 模式， 用于Neverland 2.0 LONGAN_HUB 模式, 关注健壮性 KEEP_LAST_CLIENT ¶ 是否强行保留最后一个web client（webUI 或 Scratch） 默认是 False ALWAYS_KEEP_ADAPTER_RUNNING ¶ 当所有web client退出时， Adapter 软件是否也退出 默认是 False OPEN_MESSAGE_HUB ¶ 是否允许本地（localhost）之外的 Adapter Node 与 CodeLab Adapter 通信，默认是 OPEN_MESSAGE_HUB=False 。 将 OPEN_MESSAGE_HUB 设为 True 的一个典型用例是将树莓派作为消息中心，把硬件能力提供给移动端（iPad/mobile）使用。 USE_SSL ¶ 是否以 https 运行 Adapter Node 的 http/websocketss 服务。 默认 USE_SSL=True 。 将 USE_SSL 设为 False 的一个典型用例是 CodeLab Adapter 作为服务集成到 Electron 中。将 USE_SSL 设为 False 之后就不会存在证书过期问题（无需 https 证书）。 AUTO_OPEN_WEBUI ¶ 是否自动打开 Web UI 默认 AUTO_OPEN_WEBUI = True 。 如果你希望将 CodeLab Adapter 用作内部服务，可以将 AUTO_OPEN_WEBUI 设为 False。 PYTHON3_PATH ¶ 系统的 Python3 路径， 只在 lite 版本（linux）中可用，默认为 \"/usr/bin/python3\" , 你可以自行指定。 DEFAULT_ADAPTER_HOST ¶ 默认 DEFAULT_ADAPTER_HOST = \"codelab-adapter.codelab.club\" 如果你使用自己的 https 证书，可以替换为自己的域名。 OPEN_WEBSOCKET_API ¶ 默认 OPEN_WEBSOCKET_API = True OPEN_REST_API 用于打开/关闭 WEBSOCKET API。 OPEN_REST_API ¶ 默认 OPEN_REST_API = True OPEN_REST_API 用于打开/关闭 REST API 。 TOKEN ¶ 默认为 None ，软件每次启动都将随机生成 TOKEN。 取消注释 # TOKEN = \"<random string>\" ，则永久固定 TOKEN。 <random string> 在软件初次运行的时候在本地随机生成。 RC_EXTENSIONS ¶ 默认启动的 EXTENSIONS 默认为 [] RC_NODES ¶ 默认启动的 NODES 在mac下 RC_NODES 默认为: [\"node_status_bar.py\"] , 它是一个 menu bar 在windows/linux 下 RC_NODES默认为 [] USER_WHITELIST_HOSTNAME ¶ 白名单 只有加入白名单的域名才能与 Adapter 通信。 ZMQ_LOOP_TIME ¶ 决定消息收发的速度，由于Adapter本质上是个消息系统，所以 ZMQ_LOOP_TIME 直接影响Adapter的运行速度。 ZMQ_LOOP_TIME 默认值 0.02 （秒），ZMQ_LOOP_TIME 越小，Adapter 消息速度(EIM、Linda)越快。 相应的代价是 Adapter 会占用更多CPU。 OPEN_LINDA_REST_API ¶ 是否开启 Linda REST API 默认是开启(True)","text_tokens":[",","的","(","时","用户","可以","一个","所以","替换","上","易用性","你","通用","开发","典型","mode","如果","cpu","就","自定义","软件","客户端",">","（","longan","zmq","club","用作","none","问题","取消","证书","settings","websocket","名单","use","内部","default","端","健壮","]","path","初次","这些","scratch","通信","status","模式",".","为","启动","codelab","作为","adapter","保留","活性","自动","以","所有","下","会","-","本地","usr","py",":","在","~","https","时候","\"","或","nodes","hub","0.02","ui","健壮性","token","硬件","之后","…","强行","派","文件","诸如","带来","灵活性","客户","变量",")","代价","普通","增强","ssl","/","自定","将","存在","自己","_","中","相应","路径","dev","灵活","项","用例","永久","false","menu","webui","、","配置","linux","配置文件","环境变量","支持","三种","last","当","只","eim","最后","收发","是否","快","localhost","用于","mobile","host","electron","<","白名单","集成","秒","normal","。","：","bin","hostname","打开","关注","也","树莓","给","，","不会","web","指定","希望","可用","#","越","注释","直接","定义","message","2.0","extensions","always","安全性","易用","运行","多","以下","服务","只有","把","系统","time","auto","python3","有","允许","lite","才能","环境变","true","常见","¶","自行","客户端程序","默认","neverland","覆盖","速度","string","则","api","client","设","）","本质","过期","越小","普通用户","提供","版本","加入","keep","程序","占用","风险","rc","loop","关闭","决定","位于","[","固定","插件","随机","使用","running","=","node","random","更","无需"," ","由于","websocketss","它","open","个","http","安全","每次","whitelist","windows","与","中心","都","一些","影响","退出","生成","user","linda","是","到","环境","域名","ipad","rest","默认值","之外","开启","消息","mac","同时","能力","bar","移动"],"title":"配置文件(settings)","title_tokens":["settings","(","配置","配置文件","文件",")"]},{"location":"user_guide/settings/#_1","text":"CodeLab Adapter 允许用户的自定义配置。配置文件位于: ~/codelab_adapter/user_settings.py 。 支持使用环境变量覆盖这些配置项，诸如 AUTO_OPEN_WEBUI=false codelab-adapter 以下是一些常见配置项：","text_tokens":["的","-","用户","py",":","~","。","：","位于","自定义","使用","，","="," ","文件","诸如","变量","open","定义","settings","/","自定","_","以下","一些","user","这些","auto","是","环境","项","允许",".","环境变","codelab","webui","false","配置","adapter","常见","配置文件","覆盖","环境变量","支持"],"title":"配置文件","title_tokens":["配置","配置文件","文件"]},{"location":"user_guide/settings/#adapter_mode","text":"有三种模式： NORMAL, 普通用户模式，CodeLab Adapter 作为客户端程序，增强 Scratch，支持自定义插件……关注易用性与安全性。 DEV（开发）模式，关注灵活性，同时也带来安全风险。 NEVERLAND_HUB 模式， 用于Neverland 2.0 LONGAN_HUB 模式, 关注健壮性","text_tokens":[",","普通用户","用户","用于","程序","易用性","风险","normal","通用","。","：","开发","关注","hub","插件","也","自定义","，","健壮性","客户端","（","longan","…"," ","带来","灵活性","客户","普通","增强","定义","安全","2.0","自定","安全性","与","易用","_","健壮","dev","scratch","灵活","有","模式","codelab","作为","adapter","客户端程序","neverland","支持","三种","活性","同时","）"],"title":"ADAPTER_MODE","title_tokens":["_","adapter","mode"]},{"location":"user_guide/settings/#keep_last_client","text":"是否强行保留最后一个web client（webUI 或 Scratch） 默认是 False","text_tokens":["是否","false","webui","是","保留","一个","web","（","默认","强行"," ","client","或","）","scratch","最后"],"title":"KEEP_LAST_CLIENT","title_tokens":["_","client","keep","last"]},{"location":"user_guide/settings/#always_keep_adapter_running","text":"当所有web client退出时， Adapter 软件是否也退出 默认是 False","text_tokens":["退出","是否","也","false","所有","时","，","web","adapter","软件","默认"," ","当","client","是"],"title":"ALWAYS_KEEP_ADAPTER_RUNNING","title_tokens":["always","adapter","running","keep","_"]},{"location":"user_guide/settings/#open_message_hub","text":"是否允许本地（localhost）之外的 Adapter Node 与 CodeLab Adapter 通信，默认是 OPEN_MESSAGE_HUB=False 。 将 OPEN_MESSAGE_HUB 设为 True 的一个典型用例是将树莓派作为消息中心，把硬件能力提供给移动端（iPad/mobile）使用。","text_tokens":["是否","的","提供","本地","localhost","一个","mobile","典型","。","hub","树莓","给","，","使用","=","（","node","硬件","派"," ","open","message","/","将","与","端","_","中心","把","是","通信","ipad","允许","为","之外","false","codelab","true","用例","作为","adapter","消息","默认","能力","设","）","移动"],"title":"OPEN_MESSAGE_HUB","title_tokens":["_","hub","message","open"]},{"location":"user_guide/settings/#use_ssl","text":"是否以 https 运行 Adapter Node 的 http/websocketss 服务。 默认 USE_SSL=True 。 将 USE_SSL 设为 False 的一个典型用例是 CodeLab Adapter 作为服务集成到 Electron 中。将 USE_SSL 设为 False 之后就不会存在证书过期问题（无需 https 证书）。","text_tokens":["是否","的","一个","electron","https","集成","典型","。","就","不会","=","node","之后","（","无需"," ","websocketss","问题","http","证书","ssl","/","将","存在","use","运行","_","服务","中","是","到","用例","为","false","true","codelab","作为","adapter","默认","以","设","）","过期"],"title":"USE_SSL","title_tokens":["_","use","ssl"]},{"location":"user_guide/settings/#auto_open_webui","text":"是否自动打开 Web UI 默认 AUTO_OPEN_WEBUI = True 。 如果你希望将 CodeLab Adapter 用作内部服务，可以将 AUTO_OPEN_WEBUI 设为 False。","text_tokens":["是否","可以","你","。","如果","打开","ui","，","web","=","希望"," ","用作","open","将","内部","_","服务","auto","为","false","true","webui","codelab","adapter","默认","自动","设"],"title":"AUTO_OPEN_WEBUI","title_tokens":["_","auto","open","webui"]},{"location":"user_guide/settings/#python3_path","text":"系统的 Python3 路径， 只在 lite 版本（linux）中可用，默认为 \"/usr/bin/python3\" , 你可以自行指定。","text_tokens":[",","的","版本","usr","可以","在","你","\"","。","bin","，","指定","（","可用"," ","/","中","系统","路径","python3","lite","为","linux","自行","默认","只","）"],"title":"PYTHON3_PATH","title_tokens":["_","python3","path"]},{"location":"user_guide/settings/#default_adapter_host","text":"默认 DEFAULT_ADAPTER_HOST = \"codelab-adapter.codelab.club\" 如果你使用自己的 https 证书，可以替换为自己的域名。","text_tokens":["的","-","可以","host","替换","你","https","\"","。","如果","使用","，","=","club"," ","证书","自己","default","_","域名",".","为","codelab","adapter","默认"],"title":"DEFAULT_ADAPTER_HOST","title_tokens":["_","adapter","default","host"]},{"location":"user_guide/settings/#open_websocket_api","text":"默认 OPEN_WEBSOCKET_API = True OPEN_REST_API 用于打开/关闭 WEBSOCKET API。","text_tokens":["websocket","true","/","=","用于","默认","_","。"," ","api","关闭","rest","open","打开"],"title":"OPEN_WEBSOCKET_API","title_tokens":["_","websocket","open","api"]},{"location":"user_guide/settings/#open_rest_api","text":"默认 OPEN_REST_API = True OPEN_REST_API 用于打开/关闭 REST API 。","text_tokens":["true","/","=","用于","默认","_","。"," ","api","关闭","rest","open","打开"],"title":"OPEN_REST_API","title_tokens":["_","rest","open","api"]},{"location":"user_guide/settings/#token","text":"默认为 None ，软件每次启动都将随机生成 TOKEN。 取消注释 # TOKEN = \"<random string>\" ，则永久固定 TOKEN。 <random string> 在软件初次运行的时候在本地随机生成。","text_tokens":["的","本地","在","<","时候","\"","。","固定","随机","，","软件","token","=","random",">","#"," ","注释","none","取消","每次","将","运行","都","生成","初次","为","启动","永久","默认","string","则"],"title":"TOKEN","title_tokens":["token"]},{"location":"user_guide/settings/#rc_extensions","text":"默认启动的 EXTENSIONS 默认为 []","text_tokens":["[","启动","的","为","extensions","默认"," ","]"],"title":"RC_EXTENSIONS","title_tokens":["_","rc","extensions"]},{"location":"user_guide/settings/#rc_nodes","text":"默认启动的 NODES 在mac下 RC_NODES 默认为: [\"node_status_bar.py\"] , 它是一个 menu bar 在windows/linux 下 RC_NODES默认为 []","text_tokens":[",","的","py","一个",":","在","rc","\"","nodes","[","node"," ","它","/","windows","_","]","是","status",".","启动","为","menu","linux","mac","默认","下","bar"],"title":"RC_NODES","title_tokens":["_","rc","nodes"]},{"location":"user_guide/settings/#user_whitelist_hostname","text":"白名单 只有加入白名单的域名才能与 Adapter 通信。","text_tokens":["才能","的","加入","名单","adapter","与","白名单","只有"," ","通信","。","域名"],"title":"USER_WHITELIST_HOSTNAME","title_tokens":["_","user","whitelist","hostname"]},{"location":"user_guide/settings/#zmq_loop_time","text":"决定消息收发的速度，由于Adapter本质上是个消息系统，所以 ZMQ_LOOP_TIME 直接影响Adapter的运行速度。 ZMQ_LOOP_TIME 默认值 0.02 （秒），ZMQ_LOOP_TIME 越小，Adapter 消息速度(EIM、Linda)越快。 相应的代价是 Adapter 会占用更多CPU。","text_tokens":["越小","的","快","(","所以","上","秒","占用","loop","决定","。","0.02","cpu","，","更","（","zmq","越"," ","由于",")","直接","个","代价","）","运行","多","_","相应","系统","影响","linda","time","是","默认值","、","adapter","消息","默认","速度","eim","会","本质","收发"],"title":"ZMQ_LOOP_TIME","title_tokens":["_","time","loop","zmq"]},{"location":"user_guide/settings/#open_linda_rest_api","text":"是否开启 Linda REST API 默认是开启(True)","text_tokens":["是否","开启","是","(","true","默认"," ","api","linda","rest",")"],"title":"OPEN_LINDA_REST_API","title_tokens":["_","api","linda","rest","open"]},{"location":"user_guide/usage/","text":"使用说明（usage） ¶ 我们以内置的插件为例，来讲解如何使用 CodeLab Adapter。 如果你手头有 micro:bit，推荐阅读 micro:bit 的例子，其次建议阅读微信的例子；如果你空无一物，请阅读 EIM 的例子。 micro:bit ¶ 在 Codelab Scratch 3.0 中使用 micro:bit，基于 USB，支持 Mac、Windows（支持 Windows 7 及以上版本）、Ubuntu、Raspbian（树莓派）。 使用说明： micro:bit 。 微信插件 ¶ 首先确保你的微信能登陆 网页微信 （ps：有些微信账号不能登陆网页微信）。 使用说明： 微信插件 。 EIM ¶ 使用说明： EIM 。","text_tokens":["的","版本","基于","以上",":","在","如何","你","7","建议","例子","micro","。","：","内置","如果","其次","有些","我们","插件","使用","，","推荐","微信","树莓","（","派","一物"," ","说明","阅读","确保","bit","为例","不能","能","windows","来","；","及","中","讲解","scratch","请","有","登陆","usage","codelab","、","ps","首先","¶","adapter","手头","usb","mac","空无一物","3.0","raspbian","账号","支持","网页","以","eim","ubuntu","无一物","）"],"title":"使用说明（usage）","title_tokens":["usage","使用","（","说明","）"]},{"location":"user_guide/usage/#usage","text":"我们以内置的插件为例，来讲解如何使用 CodeLab Adapter。 如果你手头有 micro:bit，推荐阅读 micro:bit 的例子，其次建议阅读微信的例子；如果你空无一物，请阅读 EIM 的例子。","text_tokens":["的",":","如何","你","建议","例子","micro","。","内置","如果","其次","插件","我们","使用","，","推荐","微信","一物"," ","阅读","bit","为例","来","；","讲解","请","有","codelab","adapter","手头","空无一物","以","eim","无一物"],"title":"使用说明（usage）","title_tokens":["usage","使用","（","说明","）"]},{"location":"user_guide/usage/#microbit","text":"在 Codelab Scratch 3.0 中使用 micro:bit，基于 USB，支持 Mac、Windows（支持 Windows 7 及以上版本）、Ubuntu、Raspbian（树莓派）。 使用说明： micro:bit 。","text_tokens":["版本","基于","以上",":","在","7","micro","。","：","树莓","使用","，","（","派"," ","说明","bit","windows","及","中","scratch","codelab","、","usb","mac","3.0","raspbian","支持","ubuntu","）"],"title":"micro:bit","title_tokens":[":","bit","micro"]},{"location":"user_guide/usage/#_1","text":"首先确保你的微信能登陆 网页微信 （ps：有些微信账号不能登陆网页微信）。 使用说明： 微信插件 。","text_tokens":["的","你","。","：","插件","使用","微信","（"," ","说明","确保","不能","能","登陆","ps","首先","账号","网页","有些","）"],"title":"微信插件","title_tokens":["微信","插件"]},{"location":"user_guide/usage/#eim","text":"使用说明： EIM 。","text_tokens":["使用"," ","说明","eim","。","："],"title":"EIM","title_tokens":["eim"]},{"location":"user_guide/与外部系统通信/","text":"与外部系统通信 ¶ 既可以使用以下的 REST api， 也可以使用 OSC (高速) 和 ZeroMQ（超高速） 外部系统 -> Adapter ¶ 接收外部的https请求， 消息最后流向 Scratch https://codelab-adapter.codelab.club:12358/api/message/eim?message=hello kano wand 和 calypso 都是案例 codelab_adapter_client ¶ Python对象的连接器：EIM 插件 Python client ¶ requests ¶ import requests requests . get ( \"https://codelab-adapter.codelab.club:12358/api/message/eim?message=hello\" , verify = False ) 也可以是呀post import requests requests . post ( \"https://codelab-adapter.codelab.club:12358/api/message/eim\" , json = { \"message\" : \"hello\" }, verify = False ) urllib.request ¶ import urllib.parse import urllib.request import ssl from socket import timeout message = urllib . parse . quote ( \"hello\" ) url = f 'https://codelab-adapter.codelab.club:12358/api/message/eim?message={message}' try : f = urllib . request . urlopen ( url , context = ssl . _create_unverified_context (), timeout = 1 ) except timeout : print ( \"message to adapter timeout\" ) JavaScript client ¶ fetch ¶ fetch ( \"https://codelab-adapter.codelab.club:12358/api/message/eim?message=hi\" ) XMLHttpRequest ¶ // 浏览器可能会提醒 CORS(跨域) 依然可用 var xhr = new XMLHttpRequest(); var url = \"https://codelab-adapter.codelab.club:12358/api/message/eim?message=hi\" xhr.open(\"GET\", url, true); xhr.send(); teachable machine插件 基于这个原理。 Adapter -> 外部系统 ¶ 由于 Adapter 允许自定义 Python 插件，所以根据外部系统接口自行实现即可。 也可采用 Python对象的连接器：EIM 插件","text_tokens":[",","的","接收","(","可以","所以","wand","var","socket","xhr","calypso","f","1","自定义",">","（","send","club","request","'","浏览器","print","import","scratch","通信",".","codelab","adapter","urllib","machine","会","即可","-","基于","可能",":","接口","post","实现","请求","https","fetch","\"","unverified","根据","try","create","hi","和","既",")","超高速","get","呀","ssl","/","自定","python","_","from","接器","false","案例","timeout","?","提醒","eim","最后","}","浏览","外部","。","：",";","也","，","可用","hello","to","流向","连接","可","requests","高速","message","定义","以下","系统","连接器","json","kano","允许","context","quote","true","¶","依然","自行","api","client","url","{","）","超高","zeromq","插件","teachable","使用","12358","=","采用","new"," ","javascript","由于","cors","open","与","这个","都","except","rest","是","verify","parse","消息","xmlhttprequest","原理","对象","urlopen","osc","跨域"],"title":"与外部系统通信","title_tokens":["与","通信","系统","外部"]},{"location":"user_guide/与外部系统通信/#_1","text":"既可以使用以下的 REST api， 也可以使用 OSC (高速) 和 ZeroMQ（超高速）","text_tokens":["的","(","可以","超高","zeromq","也","使用","，","（"," ","和","既",")","超高速","高速","以下","rest","api","osc","）"],"title":"与外部系统通信","title_tokens":["与","通信","系统","外部"]},{"location":"user_guide/与外部系统通信/#-adapter","text":"接收外部的https请求， 消息最后流向 Scratch https://codelab-adapter.codelab.club:12358/api/message/eim?message=hello kano wand 和 calypso 都是案例","text_tokens":["的","-","接收",":","wand","请求","外部","https","calypso","，","12358","=","hello","club"," ","流向","和","message","/","都","是","scratch","kano",".","codelab","案例","adapter","消息","?","api","eim","最后"],"title":"外部系统 -&gt; Adapter","title_tokens":[";","-","adapter","&","外部"," ","系统","gt"]},{"location":"user_guide/与外部系统通信/#codelab_adapter_client","text":"Python对象的连接器：EIM 插件","text_tokens":["的","接器","插件","python"," ","对象","连接器","连接","eim","："],"title":"codelab_adapter_client","title_tokens":["_","adapter","codelab","client"]},{"location":"user_guide/与外部系统通信/#python-client","text":"","text_tokens":[],"title":"Python client","title_tokens":[" ","python","client"]},{"location":"user_guide/与外部系统通信/#requests","text":"import requests requests . get ( \"https://codelab-adapter.codelab.club:12358/api/message/eim?message=hello\" , verify = False ) 也可以是呀post import requests requests . post ( \"https://codelab-adapter.codelab.club:12358/api/message/eim\" , json = { \"message\" : \"hello\" }, verify = False )","text_tokens":[",","-","(","}","可以",":","post","https","\"","也","12358","=","hello","club"," ",")","get","呀","requests","message","/","import","json","是","verify",".","false","codelab","adapter","?","api","eim","{"],"title":"requests","title_tokens":["requests"]},{"location":"user_guide/与外部系统通信/#urllibrequest","text":"import urllib.parse import urllib.request import ssl from socket import timeout message = urllib . parse . quote ( \"hello\" ) url = f 'https://codelab-adapter.codelab.club:12358/api/message/eim?message={message}' try : f = urllib . request . urlopen ( url , context = ssl . _create_unverified_context (), timeout = 1 ) except timeout : print ( \"message to adapter timeout\" )","text_tokens":[",","-","(","}",":","socket","https","\"","unverified","f","try","1","12358","=","create","hello","to","club"," ","request",")","'","message","ssl","/","print","from","import","_","except",".","context","quote","codelab","parse","timeout","adapter","?","urllib","api","eim","urlopen","url","{"],"title":"urllib.request","title_tokens":["urllib",".","request"]},{"location":"user_guide/与外部系统通信/#javascript-client","text":"","text_tokens":[],"title":"JavaScript client","title_tokens":[" ","javascript","client"]},{"location":"user_guide/与外部系统通信/#fetch","text":"fetch ( \"https://codelab-adapter.codelab.club:12358/api/message/eim?message=hi\" )","text_tokens":["-","(",":","https","fetch","\"","12358","=","hi","club"," ",")","message","/",".","codelab","adapter","?","api","eim"],"title":"fetch","title_tokens":["fetch"]},{"location":"user_guide/与外部系统通信/#xmlhttprequest","text":"// 浏览器可能会提醒 CORS(跨域) 依然可用 var xhr = new XMLHttpRequest(); var url = \"https://codelab-adapter.codelab.club:12358/api/message/eim?message=hi\" xhr.open(\"GET\", url, true); xhr.send(); teachable machine插件 基于这个原理。","text_tokens":[",","-","(","基于","可能",":","浏览","var","https","\"","xhr","。",";","teachable","插件","12358","=","send","可用","new","hi","club"," ","cors",")","open","get","浏览器","message","/","url","这个",".","codelab","true","adapter","依然","?","xmlhttprequest","原理","提醒","machine","api","eim","会","跨域"],"title":"XMLHttpRequest","title_tokens":["xmlhttprequest"]},{"location":"user_guide/与外部系统通信/#adapter-","text":"由于 Adapter 允许自定义 Python 插件，所以根据外部系统接口自行实现即可。 也可采用 Python对象的连接器：EIM 插件","text_tokens":["即可","的","所以","接口","实现","外部","。","：","根据","插件","也","自定义","，","采用"," ","由于","连接","可","定义","自定","python","系统","连接器","允许","接器","adapter","自行","对象","eim"],"title":"Adapter -&gt; 外部系统","title_tokens":[";","-","adapter","&","外部"," ","系统","gt"]},{"location":"user_guide/嵌入scratch/","text":"将 Scratch 项目嵌入网站 ¶ 服务于教学和内容设计，也可用于构建和发布 microworld（《Mindstorms》）。 开发者和教师可以利用 CodeLab Scratch，将 sb3 项目嵌入到自己的网站和课程中。 一些例子 ¶ Pong Starter ¶ Pong Starter < iframe src = \"https://scratch-beta.codelab.club/player.html?sb3url=https://adapter.codelab.club/sb3/Pong_Starter.sb3\" allowtransparency = \"true\" width = \"500\" height = \"450\" frameborder = \"0\" scrolling = \"no\" allowfullscreen ></ iframe > Dress Up Tera ¶ < iframe src = \"https://scratch-beta.codelab.club/player.html?sb3url=https://adapter.codelab.club/sb3/Dress_Up_Tera.sb3\" allowtransparency = \"true\" width = \"500\" height = \"450\" frameborder = \"0\" scrolling = \"no\" allowfullscreen ></ iframe > 交响乐 ¶ 交响乐 < iframe src = \"https://scratch-beta.codelab.club/player.html?sb3url=https://adapter.codelab.club/sb3/交响乐.sb3\" allowtransparency = \"true\" width = \"500\" height = \"450\" frameborder = \"0\" scrolling = \"no\" allowfullscreen ></ iframe > 如何将 sb3 文件保存到线上 ¶ 可以保存到任何服务器上（https），只要允许跨域资源共享（CORS），以下是 nginx 的配置： add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'GET, OPTIONS'; 如果你没有自己的服务器, 可以将你的 sb3 文件提交到 CodeLab 的仓库里： codelab-adapter-docs ，我们将为你代为托管。 当然你也可以将其放在云存储上（诸如七牛云）。 参考 ¶ How to Embed a Project phosphorus phosphorus 3D Remix: Experimental render-ordering using clones Mario Land 2 - gb.sb2 3D Framework v0.48h +timings Alone in the depths Epic Ninja v1.12","text_tokens":[",","的","using","可以","教学","上","你","gb","开发","player","其","h","如果","我们","利用","课程",">","（","club","嵌入","control","beta","'","于","clones","mindstorms","交响","sb2","methods","设计","scratch",".","starter","为","codelab","》","adapter","网站","how","七牛云","+","embed","ninja","仓库","3d","land","-","height","内容","epic",":","https","\"","没有","remix","dress","add","header","参考","文件","诸如","到线","和","教师","get","/","任何","nginx","将","自己","up","_","中","allowtransparency","配置","当然","ordering","2","?","云","scrolling","allowfullscreen","存储","*","html","用于","保存","<","如何","例子","。","：","origin","0",";","render","也","，","iframe","to","project","构建","《","放在","可","options","mario","交响乐","服务","以下","资源","允许","true","frameborder","务器","depths","¶","allow","width","资源共享","项目","a","）","microworld","开发者","里","450","托管","access","in","=","docs","只要"," ","alone","src","cors","framework","phosphorus","提交","tera","the","一些","sb3url","no","experimental","到","服务器","是","timings","代为","pong","500","sb3","v1.12","共享","跨域","v0.48","发布"],"title":"将 Scratch 项目嵌入网站","title_tokens":["将","网站","嵌入"," ","项目","scratch"]},{"location":"user_guide/嵌入scratch/#scratch","text":"服务于教学和内容设计，也可用于构建和发布 microworld（《Mindstorms》）。 开发者和教师可以利用 CodeLab Scratch，将 sb3 项目嵌入到自己的网站和课程中。","text_tokens":["的","开发者","内容","可以","用于","教学","开发","。","也","利用","，","课程","（"," ","嵌入","构建","《","和","教师","可","于","mindstorms","将","自己","服务","中","设计","到","scratch","codelab","》","网站","sb3","项目","）","发布","microworld"],"title":"将 Scratch 项目嵌入网站","title_tokens":["将","网站","嵌入"," ","项目","scratch"]},{"location":"user_guide/嵌入scratch/#_1","text":"","text_tokens":[],"title":"一些例子","title_tokens":["例子","一些"]},{"location":"user_guide/嵌入scratch/#pong-starter","text":"Pong Starter < iframe src = \"https://scratch-beta.codelab.club/player.html?sb3url=https://adapter.codelab.club/sb3/Pong_Starter.sb3\" allowtransparency = \"true\" width = \"500\" height = \"450\" frameborder = \"0\" scrolling = \"no\" allowfullscreen ></ iframe >","text_tokens":["-","height","html",":","<","https","\"","player","450","0","iframe",">","=","club"," ","beta","src","/","_","no","sb3url","allowtransparency","scratch",".","starter","codelab","true","frameborder","adapter","pong","?","500","width","sb3","scrolling","allowfullscreen"],"title":"Pong Starter","title_tokens":["starter"," ","pong"]},{"location":"user_guide/嵌入scratch/#dress-up-tera","text":"< iframe src = \"https://scratch-beta.codelab.club/player.html?sb3url=https://adapter.codelab.club/sb3/Dress_Up_Tera.sb3\" allowtransparency = \"true\" width = \"500\" height = \"450\" frameborder = \"0\" scrolling = \"no\" allowfullscreen ></ iframe >","text_tokens":["-","height","html",":","<","https","\"","player","450","0","dress","iframe",">","=","club"," ","beta","src","/","up","_","tera","no","sb3url","allowtransparency","scratch",".","codelab","true","frameborder","adapter","?","500","width","sb3","scrolling","allowfullscreen"],"title":"Dress Up Tera","title_tokens":["tera","dress"," ","up"]},{"location":"user_guide/嵌入scratch/#_2","text":"交响乐 < iframe src = \"https://scratch-beta.codelab.club/player.html?sb3url=https://adapter.codelab.club/sb3/交响乐.sb3\" allowtransparency = \"true\" width = \"500\" height = \"450\" frameborder = \"0\" scrolling = \"no\" allowfullscreen ></ iframe >","text_tokens":["-","height","html",":","<","https","\"","player","450","0","iframe",">","=","club"," ","beta","src","/","交响乐","交响","no","sb3url","allowtransparency","scratch",".","codelab","true","frameborder","adapter","?","500","width","sb3","scrolling","allowfullscreen"],"title":"交响乐","title_tokens":["交响乐","交响"]},{"location":"user_guide/嵌入scratch/#sb3","text":"可以保存到任何服务器上（https），只要允许跨域资源共享（CORS），以下是 nginx 的配置： add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'GET, OPTIONS'; 如果你没有自己的服务器, 可以将你的 sb3 文件提交到 CodeLab 的仓库里： codelab-adapter-docs ，我们将为你代为托管。 当然你也可以将其放在云存储上（诸如七牛云）。","text_tokens":[",","的","-","*","存储","可以","里","保存","上","你","https","没有","。","：","origin","其","托管","如果","access",";","我们","也","，","add","（","header","docs","只要","control"," ","共享","文件","诸如","cors","'","仓库","get","放在","options","任何","nginx","将","自己","_","服务","以下","提交","methods","服务器","到","是","资源","允许","为","代为","务器","codelab","配置","adapter","allow","当然","云","七牛云","sb3","资源共享","跨域","）"],"title":"如何将 sb3 文件保存到线上","title_tokens":["将","保存","上","如何"," ","sb3","文件","到线"]},{"location":"user_guide/嵌入scratch/#_3","text":"How to Embed a Project phosphorus phosphorus 3D Remix: Experimental render-ordering using clones Mario Land 2 - gb.sb2 3D Framework v0.48h +timings Alone in the depths Epic Ninja v1.12","text_tokens":["land","-","using","epic",":","gb","h","remix","render","in","to","project"," ","alone","framework","clones","mario","phosphorus","the","sb2","experimental","timings",".","depths","ordering","2","how","+","embed","ninja","v1.12","a","v0.48","3d"],"title":"参考","title_tokens":["参考"]},{"location":"utils/dependence/","text":"安装 CodeLab Adapter 安装 Chrome 浏览器 目前 Scratch 官方团队在陆续支持更多浏览器版本，现阶段使用 Firefox/Chrome 浏览器效果最佳. 建议将其设为默认浏览器.","text_tokens":["版本","其设","安装","浏览","在","建议","最佳","firefox","使用","，","更"," ","效果","浏览器","/","将","多","官方","scratch","团队","现阶段",".","为","chrome","codelab","adapter","默认","支持","目前","陆续","阶段"],"title":"Dependence","title_tokens":["dependence"]},{"location":"utils/install_python/","text":"建议通过搜索引擎，学习如何安装 Python3( >=3.6 ). 或者参考 python.org Python 3 Installation & Setup Guide","text_tokens":["(","安装","搜索引擎","如何","&","建议","3","，","或者",">","=","org","参考","引擎"," ",")","搜索","索引","setup","python","guide","python3","通过",".","installation","3.6","学习"],"title":"Install python","title_tokens":["install"," ","python"]},{"location":"utils/manual_comment/","text":"","text_tokens":[],"title":"Manual comment","title_tokens":["manual"," ","comment"]},{"location":"utils/neverland_require/","text":"依赖 需要身处CodeLab Neverland空间里 。","text_tokens":["codelab","里","依赖","身处","neverland"," ","。","需要","空间"],"title":"Neverland require","title_tokens":[" ","require","neverland"]},{"location":"utils/open_adapter/","text":"双击打开 Codelab Adapter。 Codelab Adapter 启动之后，将打开默认浏览器。","text_tokens":["浏览器","启动","codelab","，","双击","adapter","将","之后","浏览","默认"," ","。","打开"],"title":"Open adapter","title_tokens":["adapter"," ","open"]},{"location":"utils/open_scratch/","text":"点击 Web UI 上的 scratch3 链接, 或者点击 这儿 , 将打开如下页面: 图中箭头所指的小圆点呈现绿色 说明 Codelab Adapter 与 Scratch3.0 的连接正常。","text_tokens":[",","小圆点","呈现","的",":","上","。","箭头","打开","绿色","ui","或者","页面","web","scratch3"," ","链接","说明","连接","正常","这儿","将","与","圆点","如下","图中","codelab","adapter","scratch3.0","所指","点击"],"title":"Open scratch","title_tokens":[" ","scratch","open"]},{"location":"utils/update/","text":"如果你之前使用过旧版本的软件，更新到新版本后，建议也更新一下插件目录( ~/codelab_adapter/extensions/ ) 提醒 也可以直接删除 ~/codelab_adapter/ 目录来更新, 请确保此时Adapter已经退出，否则你将遇到 token error 问题，此时需要在任务管理器里关闭Adapter。 旧的插件会被备份到同级目录(如 extensions_1540437691 )。","text_tokens":[",","的","如","管理器","版本","(","遇到","可以","error","里","在","~","你","建议","关闭","。","之前","如果","也","插件","使用","软件","，","token","1540437691","一下","同级"," ","旧版","确保","被",")","直接","问题","更新","extensions","/","此时","将","来","任务","目录","_","旧","退出","后","管理","到","需要","请","过","codelab","旧版本","否则","adapter","备份","删除","理器","提醒","新","会","已经"],"title":"Update","title_tokens":["update"]},{"location":"utils/upload_sb3/","text":"","text_tokens":[],"title":"Upload sb3","title_tokens":["upload"," ","sb3"]}]}